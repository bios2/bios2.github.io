---
title: "Introduction to Shiny Apps"
description: |
  Introduction to interactive app development with R Shiny. 
author:
  - name: Katherine Hébert
  - name: Andrew MacDonald
  - name: Jake Lawlor
  - name: Vincent Bellevance
date: 06-22-2021
output:
  distill::distill_article:
    self_contained: false
draft: false
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = FALSE)
```

```{r katherine-content, child="katherine.Rmd", eval = TRUE}
```


```{r jake-content, child="jake.Rmd", eval = TRUE}
```


## Why do you want to use Shiny? 

There are many reasons to consider using Shiny for a project:

* sharing results from a paper with your readers
* helping you explore a model, mathematics, simulations 
* letting non R users use R. 




## Hello Shiny

```{r eval = FALSE}
# Define UI for app that draws a histogram ----
ui <- fluidPage(

  # App title ----
  titlePanel("Hello Shiny!"),

  # Sidebar layout with input and output definitions ----
  sidebarLayout(

    # Sidebar panel for inputs ----
    sidebarPanel(

      # Input: Slider for the number of bins ----
      sliderInput(inputId = "bins",
                  label = "Number of bins:",
                  min = 1,
                  max = 50,
                  value = 30)

    ),

    # Main panel for displaying outputs ----
    mainPanel(

      # Output: Histogram ----
      plotOutput(outputId = "distPlot")

    )
  )
)
```



### Golem


First step is creating your own golem project:

![](Capture d’écran, le 2021-06-23 à 05.25.32.png)

golem provides you with some very helpful "workflow" scripts:

Edit the Description by filling in this function in `01_dev.R`



Then, add all the dependencies


Together, this edits the `DESCRIPTION` of your R package to look something like this:



Now we can start building the app. 

```{r eval = FALSE}
app_ui <- function(request) {
  tagList(
    # Leave this function for adding external resources
    golem_add_external_resources(),
    # Your application UI logic 
    shinydashboard::dashboardPage(
      header = shinydashboard::dashboardHeader(
        title = "Exploring Volcanoes of the World",
        titleWidth = 350 # since we have a long title, we need to extend width element in pixels
      ),
      sidebar = shinydashboard::dashboardSidebar(disable = TRUE), # here, we only have one tab, so we don't need a sidebar
      body = shinydashboard::dashboardBody(
        # make first row of elements (actually, this will be the only row)
        fluidRow(
          # make first column, 25% of page - width = 3 of 12 colums
          column(width = 3,
                 # box 1 : input for selecting volcano type
                 #-----------------------------------------------
                 shinydashboard::box(width = NULL, status = "primary",
                     title  = "Selection Criteria", solidHeader = T
                     
                     ## CHECKBOX HERE
                     
                 ), # end box 1
                 # box 2: ggplot of selected volcanoes by continent
                 #------------------------------------------------
                 shinydashboard::box(width = NULL, status = "primary",
                     solidHeader = TRUE, collapsible = T,
                     title = "Volcanoes by Continent"
                     
                     ## PLOT HERE

                 ) # end box 2
          ), # end column 1
          
          # second column - 75% of page (9 of 12 columns)
          column(width = 9,
                 
                 # Box 3: leaflet map
                 shinydashboard::box(width = NULL, background = "light-blue"
                                     
                                     ## MAP HERE 
                                     
                 ) # end box with map
          ) # end second column
        ) # end fluidrow
      ) # end body
    )
  )
}
```

This indicates where each of the three components of the app would go.

At this point we can run the app to get a very empty-looking UI: 

![](Capture d’écran, le 2021-06-23 à 05.58.08.png)

### Golem modules

We could split this app into three different sections, corresponding to each of the three boxes:

1. Filter the type of volcano we see
1. take the filtered volcanoes and plot a stacked bar chart
1. take the filtered volcanoes and plot a map

### Selecting the volcanoes

```{r, eval=FALSE}
#' volcano_select UI Function
#'
#' @description A shiny Module.
#'
#' @param id,input,output,session Internal parameters for {shiny}.
#'
#' @noRd 
#'
#' @importFrom shiny NS tagList 
mod_volcano_select_ui <- function(id){
  ns <- NS(id)
  tagList(
    # Widget specifying the species to be included on the plot
    shinyWidgets::checkboxGroupButtons(
      inputId = ns("volcano_type"),
      label = "Volcano Type",
      choices = c("Stratovolcano" , "Shield" ,"Cone" ,   "Caldera" ,    "Volcanic Field",
                  "Complex" , "Other",   "Lava Dome"  , "Submarine"    ),
      checkIcon = list(
        yes = tags$i(class = "fa fa-check-square", 
                     style = "color: steelblue"),
        no = tags$i(class = "fa fa-square-o", 
                    style = "color: steelblue"))
    ) # end checkboxGroupButtons
  )
}
    
#' volcano_select Server Functions
#'
#' @noRd 
mod_volcano_select_server <- function(id, volcano){
  moduleServer( id, function(input, output, session){
    ns <- session$ns
    
    # make reactive dataset
    # ------------------------------------------------
    # Make a subset of the data as a reactive value
    # this subset pulls volcano rows only in the selected types of volcano
    selected_volcanoes <- reactive({
      
      req(input$volcano_type)
      
      volcano %>%
        
        # select only volcanoes in the selected volcano type (by checkboxes in the UI)
        dplyr::filter(volcano_type_consolidated %in% input$volcano_type) %>%
        # Space to add your suggested filter here!! 
        # --- --- --- --- --- --- --- --- --- --- --- --- ---
        # filter() %>%
        # --- --- --- --- --- --- --- --- --- --- --- --- ---
        # change volcano type into factor (this makes plotting it more consistent)
        dplyr::mutate(volcano_type_consolidated = factor(volcano_type_consolidated,
                                                  levels = c("Stratovolcano" , "Shield",  "Cone",   "Caldera", "Volcanic Field",
                                                             "Complex" ,  "Other" ,  "Lava Dome" , "Submarine" ) ) )
    })
    
  })
}
    
## To be copied in the UI
# mod_volcano_select_ui("volcano_select_1")
    
## To be copied in the server
# mod_volcano_select_server("volcano_select_1")

```


I also like to test my modules by using them to create a toy Shiny app. 
The best place to do this is by using a testthat directory.
This is another great advantage of using a package workflow. 
You can set this up easily with `usethis::use_test()`: just run `usethis::use_test` from the R console when you have the module open. 

Then write a simple test like this

```{r eval=FALSE}
test_that("volcano selection module works", {
  
  testthat::skip_if_not(interactive())
  
  
  ui <- fluidPage(
  ## To be copied in the UI
  mod_volcano_select_ui("volcano_select_1"),
  tableOutput("table")
  )
  
  server <- function(input, output) {
    ## To be copied in the server
    volcano_data <- readRDS("data/volcanoes.rds")
    selected_data <- mod_volcano_select_server("volcano_select_1",
                                               volcano = volcano_data)
    
    output$table <- renderTable(selected_data())
  }
  
  shinyApp(ui = ui, server = server)
  
})
```

Which generates the following simple app:

![](Capture d’écran, le 2021-06-23 à 06.25.38.png)

### Barplot of continents


```{r eval=FALSE}
#' continentplot UI Function
#'
#' @description A shiny Module.
#'
#' @param id,input,output,session Internal parameters for {shiny}.
#'
#' @noRd 
#'
#' @importFrom shiny NS tagList 
mod_continentplot_ui <- function(id){
  ns <- NS(id)
  tagList(
    plotOutput(ns("barplot"), # this calls to object continentplot that is made in the server page
               height = 350)
  )
}
    
#' continentplot Server Functions
#'
#' @noRd 
mod_continentplot_server <- function(id, volcano, selected_volcanoes){
  
  # kind of helpful
  stopifnot(is.reactive(selected_volcanoes))
  
  moduleServer( id, function(input, output, session){
    ns <- session$ns
 
    output$barplot <- renderPlot({
      
      # create basic barplot
      barplot <- ggplot2::ggplot(data = volcano,
                                 ggplot2::aes(x=continent,
                            fill = volcano_type_consolidated))+
        # update theme and axis labels:
        ggplot2::theme_bw()+
        ggplot2::theme(plot.background  = ggplot2::element_rect(color="transparent",fill = "transparent"),
                       panel.background = ggplot2::element_rect(color="transparent",fill="transparent"),
                       panel.border     = ggplot2::element_rect(color="transparent",fill="transparent"))+
        ggplot2::labs(x=NULL, y=NULL, title = NULL) +
        ggplot2::theme(axis.text.x = ggplot2::element_text(angle=45,hjust=1))
      
      
      # IF a selected_volcanoes() object exists, update the blank ggplot. 
      # basically this makes it not mess up when nothing is selected
      
      barplot <- barplot +
        ggplot2::geom_bar(data = selected_volcanoes(), show.legend = F) +
        ggplot2::scale_fill_manual(values = RColorBrewer::brewer.pal(9,"Set1"), drop=F) +
        ggplot2::scale_x_discrete(drop=F)
      
      
      # print the plot
      barplot
      
    }) # end renderplot command
    
    
  })
}
    
## To be copied in the UI
# mod_continentplot_ui("continentplot_1")
    
## To be copied in the server
# mod_continentplot_server("continentplot_1")

```



the test

```{r eval=FALSE}
test_that("volano barplot works", {
  
  testthat::skip_if_not(interactive())
  
  
  ui <- fluidPage(
    ## To be copied in the UI
    mod_continentplot_ui("continentplot_1"),
    tableOutput("table")
  )
  
  server <- function(input, output) {
    ## To be copied in the server
    volcano_data <- readRDS("data/volcanoes.rds")
    volcano_recent <- subset(volcano_data, last_eruption_year > 2000)
    mod_continentplot_server("continentplot_1",
                                              volcano = volcano_data,
                                              selected_volcanoes = reactive(volcano_recent))
  }
  
  shinyApp(ui = ui, server = server)
})
```

