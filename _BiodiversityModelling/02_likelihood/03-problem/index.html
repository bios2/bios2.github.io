<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Introduction</title>
    <meta charset="utf-8" />
    <meta name="author" content="Dominique Gravel" />
    <link href="assets/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="assets/remark-css-0.0.1/hygge.css" rel="stylesheet" />
    <link rel="stylesheet" href="../assets/ecl707.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">


class: title-slide, middle

&lt;style type="text/css"&gt;
  .title-slide {
    background-image: url('../assets/img/bg.jpg');
    background-color: #23373B;
    background-size: contain;
    border: 0px;
    background-position: 600px 0;
    line-height: 1;
  }
&lt;/style&gt;


# Maximum likelihood

&lt;hr width="65%" align="left" size="0.3" color="orange"&gt;&lt;/hr&gt;

## Technical problem

&lt;hr width="65%" align="left" size="0.3" color="orange" style="margin-bottom:40px;" alt="@Martin Sanchez"&gt;&lt;/hr&gt;

.instructors[
  **ECL707/807** - Dominique Gravel
]

&lt;img src="../assets/img/logo.png" width="25%" style="margin-top:20px;"&gt;&lt;/img&gt;

---

# Distribution of biomes in Qu√©bec

&lt;div style='text-align:center;'&gt;
&lt;img src="assets/img/bioclim.png" height="500px"&gt;&lt;/img&gt;
&lt;/div&gt;

---
# A metacommunity model of forest dynamics
&lt;div style='text-align:center;'&gt;
&lt;img src="assets/img/modele_vissault.png" height="500px"&gt;&lt;/img&gt;
&lt;/div&gt;

---
# States

- 'B' if there are only boreal tree species
- 'T' if there are only temperate tree species
- 'M' for mixtures
- 'R' if there are no trees (regeneration)


---
# Transition matrix between states

$$
`\begin{bmatrix}
P(B_{t+1}|B_t) &amp; P(B_{t+1}|T_t) &amp; P(B_{t+1}|M_t) &amp; P(B_{t+1}|R_t) \\
P(T_{t+1}|B_t) &amp; P(T_{t+1}|T_t) &amp; P(T_{t+1}|M_t) &amp; P(T_{t+1}|R_t) \\
P(M_{t+1}|B_t) &amp; P(M_{t+1}|T_t) &amp; P(M_{t+1}|M_t) &amp; P(M_{t+1}|R_t) \\  
P(R_{t+1}|B_t) &amp; P(R_{t+1}|T_t) &amp; P(R_{t+1}|M_t) &amp; P(R_{t+1}|R_t) \\
\end{bmatrix}`
$$

Where rows are states at time `\(t+1\)` and columns states at time `\(t\)`. A column is therefore a vector of probabilities corresponding to a multinomial distribution. Each column must therefore sum to 1. 

---
# Transition matrix between states

$$
`\begin{bmatrix}
P(B_{t+1}|B_t) &amp; P(B_{t+1}|T_t) &amp; P(B_{t+1}|M_t) &amp; P(B_{t+1}|R_t) \\
P(T_{t+1}|B_t) &amp; P(T_{t+1}|T_t) &amp; P(T_{t+1}|M_t) &amp; P(T_{t+1}|R_t) \\
P(M_{t+1}|B_t) &amp; P(M_{t+1}|T_t) &amp; P(M_{t+1}|M_t) &amp; P(M_{t+1}|R_t) \\  
P(R_{t+1}|B_t) &amp; P(R_{t+1}|T_t) &amp; P(R_{t+1}|M_t) &amp; P(R_{t+1}|R_t) \\
\end{bmatrix}`
$$

A single entry reads as follows : `\(P(M_{t+1} | T_t)\)` is the probability that a cell that was in state `\(T\)` at time `\(t\)` becomes a cell in state `\(M\)` at time `\(t+1\)`. Ecologically speaking, this would indicate a colonization by a `\(B\)` tree. 

---

# What we will do

- Evaluate the transition matrix (each row is a multinomial model) 

- Use a grid search to evaluate paramaters 

- Putting some constraints on parameters to answer ecological questions 

---

# The problem 

The multinomial distribution is a generalization of the binomial to `\(n\)` discrete states. 

It is therefore more complicated to evaluate the different probabilities because the sum for the different states must equal to 1. You can't throw as many values as there are states when you try candidate parameters, you need to find a way that the sum is always 1. 

---

# Steps

1. Try first the transition from the state `\(B\)` (you will have to subset the data)

2. Write a likelihood function that has 4 parameters (the transition probabilities)

3. Test your function with candidate parameter values 

4. Propose alternative candidate parameter values and compare

5. Redo the whole thing with a grid search to find your maximum likelihood estimates

---

# Scientific questions

1. Are all transition probabilities $ &gt; 0$ ? 

2. Compare a model where transitions `\(P(R_{t+1}|B_t)\)`, `\(P(R_{t+1}|M_t)\)` and `\(P(R_{t+1}|T_t)\)` are the same. Is the likelihood lower or higher ?

3. Divide the data in three categories according to annual average temperature and recompute the transition matrices for each section. Then after, compute the likelihood for the entire dataset, with specific models for the different subsections. Is the model better ? 

---

# Playing with the models 

Markov chains are commonly used in forest ecology to simulate dynamics over the long term. You can run the model to get at the equilibrium distribution with a simple R code, where `\(\mathbf{T}\)`
is a transition matrix and `\(\mathbf{X_t}\)` is a vector of initial conditions (relative abundance of the different states). You run the following : 


```r
Xt1 &lt;- T %*% Xt
```

Once you are done with evaluation of the global and the local transition matrices, you can run the model for a few time steps (you can use pretty much any initial condition you want, as long as the vector sums to 1) and compare the solutions.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="../macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "monokai",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
