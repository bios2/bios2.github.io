<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.253">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Philippe Marchand">
<meta name="dcterms.date" content="2021-01-12">
<meta name="description" content="Training session about statistical analysis of spatial data in ecology, hosted by Philippe Marchand (UQAT). | Session de formation sur l’analyse statistique des données spatiales en écologie, animée par Pr. Philippe Marchand (UQAT).">

<title>BIOS² Education resources - 4-Day Training in Spatial Statistics with Philippe Marchand</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../Bios2_reverse.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">BIOS² Education resources</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-biodiversity-modelling-summer-schools" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Biodiversity Modelling Summer Schools</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-biodiversity-modelling-summer-schools">    
        <li>
    <a class="dropdown-item" href="https://bios2.github.io/biodiversity_modelling_2021/">
 <span class="dropdown-text">Biodiversity Modelling Summer School 2021</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../summer-schools/BiodiversityModelling2022.html">
 <span class="dropdown-text">Biodiversity Modelling Summer School 2022</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="https://bios2.usherbrooke.ca/">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/bios2/bios2.github.io"><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/_bios2"><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">4-Day Training in Spatial Statistics with Philippe Marchand</h1>
                  <div>
        <div class="description">
          <p>Training session about statistical analysis of spatial data in ecology, hosted by Philippe Marchand (UQAT). | Session de formation sur l’analyse statistique des données spatiales en écologie, animée par Pr. Philippe Marchand (UQAT).</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">FR</div>
                <div class="quarto-category">EN</div>
                <div class="quarto-category">Technical</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Philippe Marchand </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 12, 2021</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#spatial-statistics-in-ecology" id="toc-spatial-statistics-in-ecology" class="nav-link active" data-scroll-target="#spatial-statistics-in-ecology"><span class="toc-section-number">1</span>  Spatial statistics in ecology</a>
  <ul class="collapse">
  <li><a href="#course-outline" id="toc-course-outline" class="nav-link" data-scroll-target="#course-outline">Course outline</a></li>
  </ul></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction"><span class="toc-section-number">2</span>  Introduction to spatial statistics</a>
  <ul class="collapse">
  <li><a href="#types-of-spatial-analyses" id="toc-types-of-spatial-analyses" class="nav-link" data-scroll-target="#types-of-spatial-analyses">Types of spatial analyses</a></li>
  <li><a href="#stationarity-and-isotropy" id="toc-stationarity-and-isotropy" class="nav-link" data-scroll-target="#stationarity-and-isotropy">Stationarity and isotropy</a></li>
  <li><a href="#georeferenced-data" id="toc-georeferenced-data" class="nav-link" data-scroll-target="#georeferenced-data">Georeferenced data</a></li>
  </ul></li>
  <li><a href="#point-pattern" id="toc-point-pattern" class="nav-link" data-scroll-target="#point-pattern"><span class="toc-section-number">3</span>  Point pattern analysis</a>
  <ul class="collapse">
  <li><a href="#point-pattern-and-point-process" id="toc-point-pattern-and-point-process" class="nav-link" data-scroll-target="#point-pattern-and-point-process">Point pattern and point process</a></li>
  <li><a href="#complete-spatial-randomness" id="toc-complete-spatial-randomness" class="nav-link" data-scroll-target="#complete-spatial-randomness">Complete spatial randomness</a></li>
  <li><a href="#exploratory-or-inferential-analysis-for-a-point-pattern" id="toc-exploratory-or-inferential-analysis-for-a-point-pattern" class="nav-link" data-scroll-target="#exploratory-or-inferential-analysis-for-a-point-pattern">Exploratory or inferential analysis for a point pattern</a></li>
  <li><a href="#ripleys-k-function" id="toc-ripleys-k-function" class="nav-link" data-scroll-target="#ripleys-k-function">Ripley’s K function</a></li>
  <li><a href="#edge-effects" id="toc-edge-effects" class="nav-link" data-scroll-target="#edge-effects">Edge effects</a></li>
  <li><a href="#example" id="toc-example" class="nav-link" data-scroll-target="#example">Example</a>
  <ul class="collapse">
  <li><a href="#exercise-1" id="toc-exercise-1" class="nav-link" data-scroll-target="#exercise-1">Exercise 1</a></li>
  </ul></li>
  <li><a href="#effect-of-heterogeneity" id="toc-effect-of-heterogeneity" class="nav-link" data-scroll-target="#effect-of-heterogeneity">Effect of heterogeneity</a>
  <ul class="collapse">
  <li><a href="#exercise-2" id="toc-exercise-2" class="nav-link" data-scroll-target="#exercise-2">Exercise 2</a></li>
  </ul></li>
  <li><a href="#relationship-between-two-point-patterns" id="toc-relationship-between-two-point-patterns" class="nav-link" data-scroll-target="#relationship-between-two-point-patterns">Relationship between two point patterns</a>
  <ul class="collapse">
  <li><a href="#questions" id="toc-questions" class="nav-link" data-scroll-target="#questions">Questions</a></li>
  </ul></li>
  <li><a href="#marked-point-patterns" id="toc-marked-point-patterns" class="nav-link" data-scroll-target="#marked-point-patterns">Marked point patterns</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul></li>
  <li><a href="#solutions" id="toc-solutions" class="nav-link" data-scroll-target="#solutions"><span class="toc-section-number">4</span>  Solutions</a>
  <ul class="collapse">
  <li><a href="#exercise-1-1" id="toc-exercise-1-1" class="nav-link" data-scroll-target="#exercise-1-1">Exercise 1</a></li>
  <li><a href="#exercise-2-1" id="toc-exercise-2-1" class="nav-link" data-scroll-target="#exercise-2-1">Exercise 2</a></li>
  </ul></li>
  <li><a href="#spatial-correlation" id="toc-spatial-correlation" class="nav-link" data-scroll-target="#spatial-correlation"><span class="toc-section-number">5</span>  Spatial correlation of a variable</a>
  <ul class="collapse">
  <li><a href="#intrinsic-or-induced-dependence" id="toc-intrinsic-or-induced-dependence" class="nav-link" data-scroll-target="#intrinsic-or-induced-dependence">Intrinsic or induced dependence</a></li>
  <li><a href="#different-ways-to-model-spatial-effects" id="toc-different-ways-to-model-spatial-effects" class="nav-link" data-scroll-target="#different-ways-to-model-spatial-effects">Different ways to model spatial effects</a></li>
  </ul></li>
  <li><a href="#geostat-models" id="toc-geostat-models" class="nav-link" data-scroll-target="#geostat-models"><span class="toc-section-number">6</span>  Geostatistical models</a>
  <ul class="collapse">
  <li><a href="#variogram" id="toc-variogram" class="nav-link" data-scroll-target="#variogram">Variogram</a></li>
  <li><a href="#theoretical-models-for-the-variogram" id="toc-theoretical-models-for-the-variogram" class="nav-link" data-scroll-target="#theoretical-models-for-the-variogram">Theoretical models for the variogram</a></li>
  <li><a href="#empirical-variogram" id="toc-empirical-variogram" class="nav-link" data-scroll-target="#empirical-variogram">Empirical variogram</a></li>
  <li><a href="#regression-model-with-spatial-correlation" id="toc-regression-model-with-spatial-correlation" class="nav-link" data-scroll-target="#regression-model-with-spatial-correlation">Regression model with spatial correlation</a></li>
  </ul></li>
  <li><a href="#geostatistical-models-in-r" id="toc-geostatistical-models-in-r" class="nav-link" data-scroll-target="#geostatistical-models-in-r"><span class="toc-section-number">7</span>  Geostatistical models in R</a>
  <ul class="collapse">
  <li><a href="#regression-with-spatial-correlation" id="toc-regression-with-spatial-correlation" class="nav-link" data-scroll-target="#regression-with-spatial-correlation">Regression with spatial correlation</a></li>
  <li><a href="#exercise" id="toc-exercise" class="nav-link" data-scroll-target="#exercise">Exercise</a></li>
  </ul></li>
  <li><a href="#kriging" id="toc-kriging" class="nav-link" data-scroll-target="#kriging"><span class="toc-section-number">8</span>  Kriging</a></li>
  <li><a href="#solutions-1" id="toc-solutions-1" class="nav-link" data-scroll-target="#solutions-1"><span class="toc-section-number">9</span>  Solutions</a></li>
  <li><a href="#areal-data" id="toc-areal-data" class="nav-link" data-scroll-target="#areal-data"><span class="toc-section-number">10</span>  Areal data</a></li>
  <li><a href="#moran-i" id="toc-moran-i" class="nav-link" data-scroll-target="#moran-i"><span class="toc-section-number">11</span>  Moran’s I</a></li>
  <li><a href="#spatial-autoreg" id="toc-spatial-autoreg" class="nav-link" data-scroll-target="#spatial-autoreg"><span class="toc-section-number">12</span>  Spatial autoregression models</a>
  <ul class="collapse">
  <li><a href="#conditional-autoregressive-car-model" id="toc-conditional-autoregressive-car-model" class="nav-link" data-scroll-target="#conditional-autoregressive-car-model">Conditional autoregressive (CAR) model</a></li>
  <li><a href="#simultaneous-autoregressive-sar-model" id="toc-simultaneous-autoregressive-sar-model" class="nav-link" data-scroll-target="#simultaneous-autoregressive-sar-model">Simultaneous autoregressive (SAR) model</a></li>
  </ul></li>
  <li><a href="#analysis-areal" id="toc-analysis-areal" class="nav-link" data-scroll-target="#analysis-areal"><span class="toc-section-number">13</span>  Analysis of areal data in R</a>
  <ul class="collapse">
  <li><a href="#definition-of-the-neighbourhood-network" id="toc-definition-of-the-neighbourhood-network" class="nav-link" data-scroll-target="#definition-of-the-neighbourhood-network">Definition of the neighbourhood network</a></li>
  <li><a href="#spatial-autoregression-models" id="toc-spatial-autoregression-models" class="nav-link" data-scroll-target="#spatial-autoregression-models">Spatial autoregression models</a></li>
  <li><a href="#exercise-3" id="toc-exercise-3" class="nav-link" data-scroll-target="#exercise-3">Exercise</a></li>
  <li><a href="#reference" id="toc-reference" class="nav-link" data-scroll-target="#reference">Reference</a></li>
  </ul></li>
  <li><a href="#glmm-spatial-gaussian" id="toc-glmm-spatial-gaussian" class="nav-link" data-scroll-target="#glmm-spatial-gaussian"><span class="toc-section-number">14</span>  GLMM with spatial Gaussian process</a>
  <ul class="collapse">
  <li><a href="#data" id="toc-data" class="nav-link" data-scroll-target="#data">Data</a></li>
  <li><a href="#non-spatial-glmm" id="toc-non-spatial-glmm" class="nav-link" data-scroll-target="#non-spatial-glmm">Non-spatial GLMM</a></li>
  <li><a href="#spatial-glmm-with-spamm" id="toc-spatial-glmm-with-spamm" class="nav-link" data-scroll-target="#spatial-glmm-with-spamm">Spatial GLMM with spaMM</a></li>
  <li><a href="#gaussian-process-models-vs.-smoothing-splines" id="toc-gaussian-process-models-vs.-smoothing-splines" class="nav-link" data-scroll-target="#gaussian-process-models-vs.-smoothing-splines">Gaussian process models vs.&nbsp;smoothing splines</a></li>
  <li><a href="#bayesian-methods-for-glmms-with-gaussian-processes" id="toc-bayesian-methods-for-glmms-with-gaussian-processes" class="nav-link" data-scroll-target="#bayesian-methods-for-glmms-with-gaussian-processes">Bayesian methods for GLMMs with Gaussian processes</a></li>
  </ul></li>
  <li><a href="#glmm-spatial-autoreg" id="toc-glmm-spatial-autoreg" class="nav-link" data-scroll-target="#glmm-spatial-autoreg"><span class="toc-section-number">15</span>  GLMM with spatial autoregression</a>
  <ul class="collapse">
  <li><a href="#reference-1" id="toc-reference-1" class="nav-link" data-scroll-target="#reference-1">Reference</a></li>
  </ul></li>
  <li><a href="#statistiques-spatiales-en-écologie" id="toc-statistiques-spatiales-en-écologie" class="nav-link" data-scroll-target="#statistiques-spatiales-en-écologie"><span class="toc-section-number">16</span>  Statistiques spatiales en écologie</a>
  <ul class="collapse">
  <li><a href="#plan-du-cours" id="toc-plan-du-cours" class="nav-link" data-scroll-target="#plan-du-cours">Plan du cours</a></li>
  </ul></li>
  <li><a href="#introduction-fr" id="toc-introduction-fr" class="nav-link" data-scroll-target="#introduction-fr"><span class="toc-section-number">17</span>  Introduction aux statistiques spatiales</a>
  <ul class="collapse">
  <li><a href="#types-danalyses-spatiales" id="toc-types-danalyses-spatiales" class="nav-link" data-scroll-target="#types-danalyses-spatiales">Types d’analyses spatiales</a></li>
  <li><a href="#stationnarité-et-isotropie" id="toc-stationnarité-et-isotropie" class="nav-link" data-scroll-target="#stationnarité-et-isotropie">Stationnarité et isotropie</a></li>
  <li><a href="#données-géoréférencées" id="toc-données-géoréférencées" class="nav-link" data-scroll-target="#données-géoréférencées">Données géoréférencées</a></li>
  </ul></li>
  <li><a href="#point-pattern-fr" id="toc-point-pattern-fr" class="nav-link" data-scroll-target="#point-pattern-fr"><span class="toc-section-number">18</span>  Analyse des patrons de points</a>
  <ul class="collapse">
  <li><a href="#patron-de-points-et-processus-ponctuel" id="toc-patron-de-points-et-processus-ponctuel" class="nav-link" data-scroll-target="#patron-de-points-et-processus-ponctuel">Patron de points et processus ponctuel</a></li>
  <li><a href="#structure-spatiale-totalement-aléatoire" id="toc-structure-spatiale-totalement-aléatoire" class="nav-link" data-scroll-target="#structure-spatiale-totalement-aléatoire">Structure spatiale totalement aléatoire</a></li>
  <li><a href="#analyse-exploratoire-ou-inférentielle-pour-un-patron-de-points" id="toc-analyse-exploratoire-ou-inférentielle-pour-un-patron-de-points" class="nav-link" data-scroll-target="#analyse-exploratoire-ou-inférentielle-pour-un-patron-de-points">Analyse exploratoire ou inférentielle pour un patron de points</a></li>
  <li><a href="#indice-k-de-ripley" id="toc-indice-k-de-ripley" class="nav-link" data-scroll-target="#indice-k-de-ripley">Indice <span class="math inline">\(K\)</span> de Ripley</a></li>
  <li><a href="#effets-de-bordure" id="toc-effets-de-bordure" class="nav-link" data-scroll-target="#effets-de-bordure">Effets de bordure</a></li>
  <li><a href="#exemple" id="toc-exemple" class="nav-link" data-scroll-target="#exemple">Exemple</a>
  <ul class="collapse">
  <li><a href="#exercice-1" id="toc-exercice-1" class="nav-link" data-scroll-target="#exercice-1">Exercice 1</a></li>
  </ul></li>
  <li><a href="#effet-de-lhétérogénéité" id="toc-effet-de-lhétérogénéité" class="nav-link" data-scroll-target="#effet-de-lhétérogénéité">Effet de l’hétérogénéité</a>
  <ul class="collapse">
  <li><a href="#exercice-2" id="toc-exercice-2" class="nav-link" data-scroll-target="#exercice-2">Exercice 2</a></li>
  </ul></li>
  <li><a href="#relation-entre-deux-patrons-de-points" id="toc-relation-entre-deux-patrons-de-points" class="nav-link" data-scroll-target="#relation-entre-deux-patrons-de-points">Relation entre deux patrons de points</a>
  <ul class="collapse">
  <li><a href="#questions-1" id="toc-questions-1" class="nav-link" data-scroll-target="#questions-1">Questions</a></li>
  </ul></li>
  <li><a href="#patrons-de-points-marqués" id="toc-patrons-de-points-marqués" class="nav-link" data-scroll-target="#patrons-de-points-marqués">Patrons de points marqués</a></li>
  <li><a href="#références" id="toc-références" class="nav-link" data-scroll-target="#références">Références</a></li>
  </ul></li>
  <li><a href="#solutions-2" id="toc-solutions-2" class="nav-link" data-scroll-target="#solutions-2"><span class="toc-section-number">19</span>  Solutions</a>
  <ul class="collapse">
  <li><a href="#exercice-1-1" id="toc-exercice-1-1" class="nav-link" data-scroll-target="#exercice-1-1">Exercice 1</a></li>
  <li><a href="#exercice-2-1" id="toc-exercice-2-1" class="nav-link" data-scroll-target="#exercice-2-1">Exercice 2</a></li>
  </ul></li>
  <li><a href="#spatial-correlation-fr" id="toc-spatial-correlation-fr" class="nav-link" data-scroll-target="#spatial-correlation-fr"><span class="toc-section-number">20</span>  Corrélation spatiale d’une variable</a>
  <ul class="collapse">
  <li><a href="#dépendance-intrinsèque-ou-induite" id="toc-dépendance-intrinsèque-ou-induite" class="nav-link" data-scroll-target="#dépendance-intrinsèque-ou-induite">Dépendance intrinsèque ou induite</a></li>
  <li><a href="#différentes-façons-de-modéliser-les-effets-spatiaux" id="toc-différentes-façons-de-modéliser-les-effets-spatiaux" class="nav-link" data-scroll-target="#différentes-façons-de-modéliser-les-effets-spatiaux">Différentes façons de modéliser les effets spatiaux</a></li>
  </ul></li>
  <li><a href="#geostat-models-fr" id="toc-geostat-models-fr" class="nav-link" data-scroll-target="#geostat-models-fr"><span class="toc-section-number">21</span>  Modèles géostatistiques</a>
  <ul class="collapse">
  <li><a href="#variogramme" id="toc-variogramme" class="nav-link" data-scroll-target="#variogramme">Variogramme</a></li>
  <li><a href="#modèles-théoriques-du-variogramme" id="toc-modèles-théoriques-du-variogramme" class="nav-link" data-scroll-target="#modèles-théoriques-du-variogramme">Modèles théoriques du variogramme</a></li>
  <li><a href="#variogramme-empirique" id="toc-variogramme-empirique" class="nav-link" data-scroll-target="#variogramme-empirique">Variogramme empirique</a></li>
  <li><a href="#modèle-de-régression-avec-corrélation-spatiale" id="toc-modèle-de-régression-avec-corrélation-spatiale" class="nav-link" data-scroll-target="#modèle-de-régression-avec-corrélation-spatiale">Modèle de régression avec corrélation spatiale</a></li>
  </ul></li>
  <li><a href="#modèles-géostatistiques-dans-r" id="toc-modèles-géostatistiques-dans-r" class="nav-link" data-scroll-target="#modèles-géostatistiques-dans-r"><span class="toc-section-number">22</span>  Modèles géostatistiques dans R</a>
  <ul class="collapse">
  <li><a href="#régression-avec-corrélation-spatiale" id="toc-régression-avec-corrélation-spatiale" class="nav-link" data-scroll-target="#régression-avec-corrélation-spatiale">Régression avec corrélation spatiale</a></li>
  <li><a href="#exercice" id="toc-exercice" class="nav-link" data-scroll-target="#exercice">Exercice</a></li>
  </ul></li>
  <li><a href="#krigeage" id="toc-krigeage" class="nav-link" data-scroll-target="#krigeage"><span class="toc-section-number">23</span>  Krigeage</a></li>
  <li><a href="#solutions-3" id="toc-solutions-3" class="nav-link" data-scroll-target="#solutions-3"><span class="toc-section-number">24</span>  Solutions</a></li>
  <li><a href="#areal-data-fr" id="toc-areal-data-fr" class="nav-link" data-scroll-target="#areal-data-fr"><span class="toc-section-number">25</span>  Données aréales</a></li>
  <li><a href="#moran-i-fr" id="toc-moran-i-fr" class="nav-link" data-scroll-target="#moran-i-fr"><span class="toc-section-number">26</span>  Indice de Moran</a></li>
  <li><a href="#spatial-autoreg-fr" id="toc-spatial-autoreg-fr" class="nav-link" data-scroll-target="#spatial-autoreg-fr"><span class="toc-section-number">27</span>  Modèles d’autorégression spatiale</a>
  <ul class="collapse">
  <li><a href="#autorégression-conditionnelle-car" id="toc-autorégression-conditionnelle-car" class="nav-link" data-scroll-target="#autorégression-conditionnelle-car">Autorégression conditionnelle (CAR)</a></li>
  <li><a href="#autorégression-simultanée-sar" id="toc-autorégression-simultanée-sar" class="nav-link" data-scroll-target="#autorégression-simultanée-sar">Autorégression simultanée (SAR)</a></li>
  </ul></li>
  <li><a href="#analysis-areal-fr" id="toc-analysis-areal-fr" class="nav-link" data-scroll-target="#analysis-areal-fr"><span class="toc-section-number">28</span>  Analyse des données aréales dans R</a>
  <ul class="collapse">
  <li><a href="#définition-du-réseau-de-voisinage" id="toc-définition-du-réseau-de-voisinage" class="nav-link" data-scroll-target="#définition-du-réseau-de-voisinage">Définition du réseau de voisinage</a></li>
  <li><a href="#modèles-dautorégression-spatiale" id="toc-modèles-dautorégression-spatiale" class="nav-link" data-scroll-target="#modèles-dautorégression-spatiale">Modèles d’autorégression spatiale</a></li>
  <li><a href="#exercice-3" id="toc-exercice-3" class="nav-link" data-scroll-target="#exercice-3">Exercice</a></li>
  <li><a href="#référence" id="toc-référence" class="nav-link" data-scroll-target="#référence">Référence</a></li>
  </ul></li>
  <li><a href="#glmm-spatial-gaussian-fr" id="toc-glmm-spatial-gaussian-fr" class="nav-link" data-scroll-target="#glmm-spatial-gaussian-fr"><span class="toc-section-number">29</span>  GLMM avec processus spatial gaussien</a>
  <ul class="collapse">
  <li><a href="#données" id="toc-données" class="nav-link" data-scroll-target="#données">Données</a></li>
  <li><a href="#glmm-non-spatial" id="toc-glmm-non-spatial" class="nav-link" data-scroll-target="#glmm-non-spatial">GLMM non spatial</a></li>
  <li><a href="#glmm-spatial-avec-spamm" id="toc-glmm-spatial-avec-spamm" class="nav-link" data-scroll-target="#glmm-spatial-avec-spamm">GLMM spatial avec spaMM</a></li>
  <li><a href="#processus-gaussiens-vs.-splines-de-lissage" id="toc-processus-gaussiens-vs.-splines-de-lissage" class="nav-link" data-scroll-target="#processus-gaussiens-vs.-splines-de-lissage">Processus gaussiens vs.&nbsp;splines de lissage</a></li>
  <li><a href="#méthodes-bayésiennes-pour-les-glmm-avec-processus-gaussiens" id="toc-méthodes-bayésiennes-pour-les-glmm-avec-processus-gaussiens" class="nav-link" data-scroll-target="#méthodes-bayésiennes-pour-les-glmm-avec-processus-gaussiens">Méthodes bayésiennes pour les GLMM avec processus gaussiens</a></li>
  </ul></li>
  <li><a href="#glmm-spatial-autoreg-fr" id="toc-glmm-spatial-autoreg-fr" class="nav-link" data-scroll-target="#glmm-spatial-autoreg-fr"><span class="toc-section-number">30</span>  GLMM avec autorégression spatiale</a>
  <ul class="collapse">
  <li><a href="#référence-1" id="toc-référence-1" class="nav-link" data-scroll-target="#référence-1">Référence</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>Version en français <a href="#statistiques-spatiales-en-écologie">à la suite</a>.</p>
<section id="spatial-statistics-in-ecology" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Spatial statistics in ecology</h1>
<p>BIOS² hosted an online training session about statistical analysis of spatial data in ecology, led by Pr. Philippe Marchand (UQAT). This 12-hour training was conducted in 4 sessions: January 12, 14, 19 &amp; 21 (2021) from 1:00 to 4:00 pm EST.</p>
<p>The content included three types of spatial statistical analyses and their applications to ecology: (1) point pattern analysis to study the distribution of individuals or events in space; (2) geostatistical models to represent the spatial correlation of variables sampled at geolocated points; and (3) areal data models, which apply to measurements taken on areas in space and model spatial relationships as networks of neighbouring regions. The training also included practical exercises using the R statistical programming environment.</p>
<p><a href="https://github.com/pmarchand1">Philippe Marchand</a> is a professor in ecology and biostatistics at Institut de recherche sur les forêts, Université du Québec en Abitibi-Témiscamingue (UQAT) and BIOS² academic member. His research focuses on modeling processes that influence the spatial distribution of populations, including: seed dispersal and seedling establishment, animal movement, and the spread of forest diseases.</p>
<p><strong>If you wish to consult the lesson materials and follow the exercises at your own pace, you can access them through <a href="https://bios2.github.io/Marchand.html#category:EN">this link</a>. Basic knowledge of linear regression models and experience fitting them in R is recommended. Original repository can be found <a href="https://github.com/pmarchand1/BIOS2-spatial-stats">here</a>.</strong></p>
<section id="course-outline" class="level2">
<h2 class="anchored" data-anchor-id="course-outline">Course outline</h2>
<table class="table">
<thead>
<tr class="header">
<th>Day</th>
<th style="text-align: left;">Topics (EN)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td style="text-align: left;">• <a href="#introduction">Introduction to spatial statistics</a> <br> • <a href="#point-pattern">Point pattern analysis</a><br></td>
</tr>
<tr class="even">
<td>2</td>
<td style="text-align: left;">• <a href="#spatial-correlation">Spatial correlation</a> <br> • <a href="#geostat-models">Geostatistical models</a></td>
</tr>
<tr class="odd">
<td>3</td>
<td style="text-align: left;">• <a href="#areal-data">Areal data</a> <br> • <a href="#moran-i">Moran’s I</a> <br> • <a href="#spatial-autoreg">Spatial autoregression models</a> <br> • <a href="#analysis-areal">Analysis of areal data in R</a></td>
</tr>
<tr class="even">
<td>4</td>
<td style="text-align: left;">• <a href="#glmm-spatial-gaussian">GLMM with spatial Gaussian process</a> <br> • <a href="#glmm-spatial-autoreg">GLMM with spatial autoregression</a></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="introduction" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Introduction to spatial statistics</h1>
<section id="types-of-spatial-analyses" class="level2">
<h2 class="anchored" data-anchor-id="types-of-spatial-analyses">Types of spatial analyses</h2>
<p>In this training, we will discuss three types of spatial analyses: point pattern analysis, geostatistical models and models for areal data.</p>
<p>In <strong>point pattern analysis</strong>, we have point data representing the position of individuals or events in a study area and we assume that all individuals or events have been identified in that area. That analysis focuses on the distribution of the positions of the points themselves. Here are some typical questions for the analysis of point patterns:</p>
<ul>
<li><p>Are the points randomly arranged or clustered?</p></li>
<li><p>Are two types of points arranged independently?</p></li>
</ul>
<p><strong>Geostatistical models</strong> represent the spatial distribution of continuous variables that are measured at certain sampling points. They assume that measurements of those variables at different points are correlated as a function of the distance between the points. Applications of geostatistical models include the smoothing of spatial data (e.g., producing a map of a variable over an entire region based on point measurements) and the prediction of those variables for non-sampled points.</p>
<p><strong>Areal data</strong> are measurements taken not at points, but for regions of space represented by polygons (e.g.&nbsp;administrative divisions, grid cells). Models representing these types of data define a network linking each region to its neighbours and include correlations in the variable of interest between neighbouring regions.</p>
</section>
<section id="stationarity-and-isotropy" class="level2">
<h2 class="anchored" data-anchor-id="stationarity-and-isotropy">Stationarity and isotropy</h2>
<p>Several spatial analyses assume that the variables are <strong>stationary</strong> in space. As with stationarity in the time domain, this property means that summary statistics (mean, variance and correlations between measures of a variable) do not vary with translation in space. For example, the spatial correlation between two points may depend on the distance between them, but not on their absolute position.</p>
<p>In particular, there cannot be a large-scale trend (often called <em>gradient</em> in a spatial context), or this trend must be taken into account before modelling the spatial correlation of residuals.</p>
<p>In the case of point pattern analysis, stationarity (also called homogeneity) means that point density does not follow a large-scale trend.</p>
<p>In a <strong>isotropic</strong> statistical model, the spatial correlations between measurements at two points depend only on the distance between the points, not on the direction. In this case, the summary statistics do not change under a spatial rotation of the data.</p>
</section>
<section id="georeferenced-data" class="level2">
<h2 class="anchored" data-anchor-id="georeferenced-data">Georeferenced data</h2>
<p>Environmental studies increasingly use data from geospatial data sources, i.e.&nbsp;variables measured over a large part of the globe (e.g.&nbsp;climate, remote sensing). The processing of these data requires concepts related to Geographic Information Systems (GIS), which are not covered in this workshop, where we focus on the statistical aspects of spatially varying data.</p>
<p>The use of geospatial data does not necessarily mean that spatial statistics are required. For example, we will often extract values of geographic variables at study points to explain a biological response observed in the field. In this case, the use of spatial statistics is only necessary when there is a spatial correlation in the residuals, after controlling for the effect of the predictors.</p>
</section>
</section>
<section id="point-pattern" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Point pattern analysis</h1>
<section id="point-pattern-and-point-process" class="level2">
<h2 class="anchored" data-anchor-id="point-pattern-and-point-process">Point pattern and point process</h2>
<p>A <em>point pattern</em> describes the spatial position (most often in 2D) of individuals or events, represented by points, in a given study area, often called the observation “window”.</p>
<p>It is assumed that each point has a negligible spatial extent relative to the distances between the points. More complex methods exist to deal with spatial patterns of objects that have a non-negligible width, but this topic is beyond the scope of this workshop.</p>
<p>A <em>point process</em> is a statistical model that can be used to simulate point patterns or explain an observed point pattern.</p>
</section>
<section id="complete-spatial-randomness" class="level2">
<h2 class="anchored" data-anchor-id="complete-spatial-randomness">Complete spatial randomness</h2>
<p>Complete spatial randomness (CSR) is one of the simplest point patterns, which serves as a null model for evaluating the characteristics of real point patterns. In this pattern, the presence of a point at a given position is independent of the presence of points in a neighbourhood.</p>
<p>The process creating this pattern is a homogeneous Poisson process. According to this model, the number of points in any area <span class="math inline">\(A\)</span> follows a Poisson distribution: <span class="math inline">\(N(A) \sim \text{Pois}(\lambda A)\)</span>, where <span class="math inline">\(\lambda\)</span> is the <em>intensity</em> of the process (i.e.&nbsp;the density of points per unit area). <span class="math inline">\(N\)</span> is independent between two disjoint regions, no matter how those regions are defined.</p>
<p>In the graph below, only the pattern on the right is completely random. The pattern on the left shows point aggregation (higher probability of observing a point close to another point), while the pattern in the center shows repulsion (low probability of observing a point very close to another).</p>
<div class="cell" data-fig.dim="[9,3]" data-hash="index_cache/html/unnamed-chunk-2_c019229dfeb24b4b22a136e6b038583d">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid" width="864"></p>
</div>
</div>
</section>
<section id="exploratory-or-inferential-analysis-for-a-point-pattern" class="level2">
<h2 class="anchored" data-anchor-id="exploratory-or-inferential-analysis-for-a-point-pattern">Exploratory or inferential analysis for a point pattern</h2>
<p>Several summary statistics are used to describe the characteristics of a point pattern. The simplest is the intensity <span class="math inline">\(\lambda\)</span>, which as mentioned above represents the density of points per unit area. If the point pattern is heterogeneous, the intensity is not constant, but depends on the position: <span class="math inline">\(\lambda(x, y)\)</span>.</p>
<p>Compared to intensity, which is a first-order statistic, second-order statistics describe how the probability of the presence of a point in a region depends on the presence of other points. The Ripley’s <span class="math inline">\(K\)</span> function presented in the next section is an example of a second-order summary statistic.</p>
<p>Statistical inferences on point patterns usually consist of testing the hypothesis that the point pattern corresponds to a given null model, such as CSR or a more complex null model. Even for the simplest null models, we rarely know the theoretical distribution for a summary statistic of the point pattern under the null model. Hypothesis tests on point patterns are therefore performed by simulation: a large number of point patterns are simulated from the null model and the distribution of the summary statistics of interest for these simulations is compared to their values for the observed point pattern.</p>
</section>
<section id="ripleys-k-function" class="level2">
<h2 class="anchored" data-anchor-id="ripleys-k-function">Ripley’s K function</h2>
<p>Ripley’s K function <span class="math inline">\(K(r)\)</span> is defined as the mean number of points within a circle of radius <span class="math inline">\(r\)</span> around a point in the pattern, standardized by the intensity <span class="math inline">\(\lambda\)</span>.</p>
<p>Under the CSR null model, the mean number of points in any circle of radius <span class="math inline">\(r\)</span> is <span class="math inline">\(\lambda \pi r^2\)</span>, thus in theory <span class="math inline">\(K(r) = \pi r^2\)</span> for that model. A higher value of <span class="math inline">\(K(r)\)</span> means that there is an aggregation of points at the scale <span class="math inline">\(r\)</span>, whereas a lower value means that there is repulsion.</p>
<p>In practice, <span class="math inline">\(K(r)\)</span> is estimated for a specific point pattern by the equation:</p>
<p><span class="math display">\[ K(r) = \frac{A}{n(n-1)} \sum_i \sum_{j &gt; i} I \left( d_{ij} \le r \right) w_{ij}\]</span></p>
<p>where <span class="math inline">\(A\)</span> is the area of the observation window and <span class="math inline">\(n\)</span> is the number of points in the pattern, so <span class="math inline">\(n(n-1)\)</span> is the number of distinct pairs of points. We take the sum for all pairs of points of the indicator function <span class="math inline">\(I\)</span>, which takes a value of 1 if the distance between points <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> is less than or equal to <span class="math inline">\(r\)</span>. Finally, the term <span class="math inline">\(w_{ij}\)</span> is used to give extra weight to certain pairs of points to account for edge effects, as discussed in the next section.</p>
<p>For example, the graphs below show the estimated <span class="math inline">\(K(r)\)</span> function for the patterns shown above, for values of <span class="math inline">\(r\)</span> up to 1/4 of the window width. The red dashed curve shows the theoretical value for CSR and the gray area is an “envelope” produced by 99 simulations of that null pattern. The aggregated pattern shows an excess of neighbours up to <span class="math inline">\(r = 0.25\)</span> and the pattern with repulsion shows a significant deficit of neighbours for small values of <span class="math inline">\(r\)</span>.</p>
<div class="cell" data-fig.dim="[9,3]" data-hash="index_cache/html/unnamed-chunk-4_93b9963febba16ed4365408bd10b6c70">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid" width="864"></p>
</div>
</div>
<p>In addition to <span class="math inline">\(K\)</span>, there are other statistics to describe the second-order properties of point patterns, such as the mean distance between a point and its nearest <span class="math inline">\(N\)</span> neighbours. You can refer to the Wiegand and Moloney (2013) textbook in the references to learn more about different summary statistics for point patterns.</p>
</section>
<section id="edge-effects" class="level2">
<h2 class="anchored" data-anchor-id="edge-effects">Edge effects</h2>
<p>In the context of point pattern analysis, edge effects are due to the fact that we have incomplete knowledge of the neighbourhood of points near the edge of the observation window, which can induce a bias in the calculation of statistics such as Ripley’s <span class="math inline">\(K\)</span>.</p>
<p>Different methods have been developed to correct the bias due to edge effects. In Ripley’s edge correction method, the contribution of a neighbour <span class="math inline">\(j\)</span> located at a distance <span class="math inline">\(r\)</span> from a point <span class="math inline">\(i\)</span> receives a weight <span class="math inline">\(w_{ij} = 1/\phi_i(r)\)</span>, where <span class="math inline">\(\phi_i(r)\)</span> is the fraction of the circle of radius <span class="math inline">\(r\)</span> around <span class="math inline">\(i\)</span> contained in the observation window. For example, if 2/3 of the circle is in the window, this neighbour counts as 3/2 neighbours in the calculation of a statistic like <span class="math inline">\(K\)</span>.</p>
<p><img src="images/ripley_edge.png" class="img-fluid"></p>
<p>Ripley’s method is one of the simplest to correct for edge effects, but is not necessarily the most efficient; in particular, larger weights given to certain pairs of points tend to increase the variance of the calculated statistic. Other correction methods are presented in specialized textbooks, such as Wiegand and Moloney (2013).</p>
</section>
<section id="example" class="level2">
<h2 class="anchored" data-anchor-id="example">Example</h2>
<p>For this example, we use the dataset <a href="data/semis_xy.csv">semis_xy.csv</a>, which represents the <span class="math inline">\((x, y)\)</span> coordinates for seedlings of two species (<em>sp</em>, B = birch and P = poplar) in a 15 x 15 m plot.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-5_0f8146040b7a6a70fa3c497cc0385db2">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>semis <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">"data/semis_xy.csv"</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(semis)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      x    y sp
1 14.73 0.05  P
2 14.72 1.71  P
3 14.31 2.06  P
4 14.16 2.64  P
5 14.12 4.15  B
6  9.88 4.08  B</code></pre>
</div>
</div>
<p>The <em>spatstat</em> package provides tools for point pattern analysis in R. The first step consists in transforming our data frame into a <code>ppp</code> object (point pattern) with the function of the same name. In this function, we specify which columns contain the coordinates <em>x</em> and <em>y</em> as well as the <em>marks</em>, which here will be the species codes. We also need to specify an observation window (<code>window</code>) using the <code>owin</code> function, where we provide the plot limits in <em>x</em> and <em>y</em>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-6_57149b36e4a5be5442a99b8f45b2dbdd">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(spatstat)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>semis <span class="ot">&lt;-</span> <span class="fu">ppp</span>(<span class="at">x =</span> semis<span class="sc">$</span>x, <span class="at">y =</span> semis<span class="sc">$</span>y, <span class="at">marks =</span> <span class="fu">as.factor</span>(semis<span class="sc">$</span>sp),</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>             <span class="at">window =</span> <span class="fu">owin</span>(<span class="at">xrange =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">15</span>), <span class="at">yrange =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">15</span>)))</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>semis</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Marked planar point pattern: 281 points
Multitype, with levels = B, P 
window: rectangle = [0, 15] x [0, 15] units</code></pre>
</div>
</div>
<p>Marks can be numeric or categorical. Note that for categorical marks as is the case here, the variable must be explicitly converted to a factor.</p>
<p>The <code>plot</code> function applied to a point pattern shows a diagram of the pattern.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-7_ba656f4aa5befb58b9e9845ae787d99d">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(semis)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The <code>intensity</code> function calculates the density of points of each species by unit area (here, by <span class="math inline">\(m^2\)</span>).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-8_0b22d4b3b39bd4dc862f8c161efb9330">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">intensity</span>(semis)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        B         P 
0.6666667 0.5822222 </code></pre>
</div>
</div>
<p>To first analyze the distribution of each species separately, we split the pattern with <code>split</code>. Since the pattern contains categorical marks, it is automatically split according to the values of those marks. The result is a list of two point patterns.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-9_5ff3f6384afcf7ed706bbf891accd2fa">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>semis_split <span class="ot">&lt;-</span> <span class="fu">split</span>(semis)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(semis_split)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The <code>Kest</code> function calculates Ripley’s <span class="math inline">\(K\)</span> for a series of distances up to (by default) 1/4 of the width of the window. Here we apply it to the first pattern (birch) by choosing <code>semis_split[[1]]</code>. Note that double square brackets are necessary to choose an item from a list in R.</p>
<p>The argument <code>correction = "iso"</code> tells the function to apply Ripley’s correction for edge effects.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-10_67e4bd9ed190d1af69a48250adb1bc3d">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>k <span class="ot">&lt;-</span> <span class="fu">Kest</span>(semis_split[[<span class="dv">1</span>]], <span class="at">correction =</span> <span class="st">"iso"</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(k)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-10-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>According to this graph, there seems to be an excess of neighbours for distances of 1 m and above. To check if this is a significant difference, we produce a simulation envelope with the <code>envelope</code> function. The first argument of <code>envelope</code> is a point pattern to which the simulations will be compared, the second one is a function to be computed (here, <code>Kest</code>) for each simulated pattern, then we add the arguments of the <code>Kest</code> function (here, only <code>correction</code>).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-11_ebe814599d9537b0a51121b965182658">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">envelope</span>(semis_split[[<span class="dv">1</span>]], Kest, <span class="at">correction =</span> <span class="st">"iso"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Generating 99 simulations of CSR  ...
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,  99.

Done.</code></pre>
</div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-11-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>As indicated by the message, by default the function performs 99 simulations of the null model corresponding to complete spatial randomness (CSR).</p>
<p>The observed curve falls outside the envelope of the 99 simulations near <span class="math inline">\(r = 2\)</span>. We must be careful not to interpret too quickly a result that is outside the envelope. Although there is about a 1% probability of obtaining a more extreme result under the null hypothesis at a given distance, the envelope is calculated for a large number of values of <span class="math inline">\(r\)</span> and is not corrected for multiple comparisons. Thus, a significant difference for a very small range of values of <span class="math inline">\(r\)</span> may be simply due to chance.</p>
<section id="exercise-1" class="level3">
<h3 class="anchored" data-anchor-id="exercise-1">Exercise 1</h3>
<p>Looking at the graph of the second point pattern (poplar seedlings), can you predict where Ripley’s <span class="math inline">\(K\)</span> will be in relation to the null hypothesis of complete spatial randomness? Verify your prediction by calculating Ripley’s <span class="math inline">\(K\)</span> for this point pattern in R.</p>
</section>
</section>
<section id="effect-of-heterogeneity" class="level2">
<h2 class="anchored" data-anchor-id="effect-of-heterogeneity">Effect of heterogeneity</h2>
<p>The graph below illustrates a <em>heterogeneous</em> point pattern, i.e.&nbsp;it shows an density gradient (more points on the left than on the right).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-13_36849871c75ced31ddf5bd09edb7ace9">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-13-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>A density gradient can be confused with an aggregation of points, as can be seen on the graph of the corresponding Ripley’s <span class="math inline">\(K\)</span>. In theory, these are two different processes:</p>
<ul>
<li><p>Heterogeneity: The density of points varies in the study area, for example due to the fact that certain local conditions are more favorable to the presence of the species of interest.</p></li>
<li><p>Aggregation: The mean density of points is homogeneous, but the presence of one point increases the presence of other points in its vicinity, for example due to positive interactions between individuals.</p></li>
</ul>
<p>However, it may be difficult to differentiate between the two in practice, especially since some patterns may be both heterogeneous and aggregated.</p>
<p>Let’s take the example of the poplar seedlings from the previous exercise. The <code>density</code> function applied to a point pattern performs a kernel density estimation of the density of the seedlings across the plot. By default, this function uses a Gaussian kernel with a standard deviation <code>sigma</code> specified in the function, which determines the scale at which density fluctuations are “smoothed”. Here, we use a value of 2 m for <code>sigma</code> and we first represent the estimated density with <code>plot</code>, before overlaying the points (<code>add = TRUE</code> means that the points are added to the existing plot rather than creating a new plot).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-14_3332987af85b2014bbebfa360ce15a9b">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>dens_p <span class="ot">&lt;-</span> <span class="fu">density</span>(semis_split[[<span class="dv">2</span>]], <span class="at">sigma =</span> <span class="dv">2</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(dens_p)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(semis_split[[<span class="dv">2</span>]], <span class="at">add =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-14-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>To measure the aggregation or repulsion of points in a heterogeneous pattern, we must use the inhomogeneous version of the <span class="math inline">\(K\)</span> statistic (<code>Kinhom</code> in <em>spatstat</em>). This statistic is still equal to the mean number of neighbours within a radius <span class="math inline">\(r\)</span> of a point in the pattern, but rather than standardizing this number by the overall intensity of the pattern, it is standardized by the local estimated density. As above, we specify <code>sigma = 2</code> to control the level of smoothing for the varying density estimate.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-15_f82857163481aaf3f03a5dd201df8615">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">Kinhom</span>(semis_split[[<span class="dv">2</span>]], <span class="at">sigma =</span> <span class="dv">2</span>, <span class="at">correction =</span> <span class="st">"iso"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-15-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Taking into account the heterogeneity of the pattern at a scale <code>sigma</code> of 2 m, there seems to be a deficit of neighbours starting at a radius of about 1.5 m. We can now check whether this deviation is significant.</p>
<p>As before, we use <code>envelope</code> to simulate the <code>Kinhom</code> statistic under the null model. However, the null model here is not a homogeneous Poisson process (CSR). It is instead a heterogeneous Poisson process simulated by the function <code>rpoispp(dens_p)</code>, i.e.&nbsp;the points are independent of each other, but their density is heterogeneous and given by <code>dens_p</code>. The <code>simulate</code> argument of the <code>envelope</code> function specifies the function used for simulations under the null model; this function must have one argument, here <code>x</code>, even if it is not used.</p>
<p>Finally, in addition to the arguments needed for <code>Kinhom</code>, i.e.&nbsp;<code>sigma</code> and <code>correction</code>, we also specify <code>nsim = 199</code> to perform 199 simulations and <code>nrank = 5</code> to eliminate the 5 most extreme results on each side of the envelope, i.e.&nbsp;the 10 most extreme results out of 199, to achieve an interval containing about 95% of the probability under the null hypothesis.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-16_7119c82106369cf2aa8fe32fff918b5e">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>khet_p <span class="ot">&lt;-</span> <span class="fu">envelope</span>(semis_split[[<span class="dv">2</span>]], Kinhom, <span class="at">sigma =</span> <span class="dv">2</span>,  <span class="at">correction =</span> <span class="st">"iso"</span>,</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>                   <span class="at">nsim =</span> <span class="dv">199</span>, <span class="at">nrank =</span> <span class="dv">5</span>, <span class="at">simulate =</span> <span class="cf">function</span>(x) <span class="fu">rpoispp</span>(dens_p))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Generating 199 simulations by evaluating function  ...
1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114.116.118.120
.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154.156.158.160
.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194.196.198 199.

Done.</code></pre>
</div>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(khet_p)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-16-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p><em>Note</em>: For a hypothesis test based on simulations of a null hypothesis, the <span class="math inline">\(p\)</span>-value is estimated by <span class="math inline">\((m + 1)/(n + 1)\)</span>, where <span class="math inline">\(n\)</span> is the number of simulations and <span class="math inline">\(m\)</span> is the number of simulations where the value of the statistic is more extreme than that of the observed data. This is why the number of simulations is often chosen to be 99, 199, etc.</p>
<section id="exercise-2" class="level3">
<h3 class="anchored" data-anchor-id="exercise-2">Exercise 2</h3>
<p>Repeat the heterogeneous density estimation and <code>Kinhom</code> calculation with a standard deviation <code>sigma</code> of 5 rather than 2. How does the smoothing level for the density estimation influence the conclusions?</p>
<p>To differentiate between a variation in the density of points from an interaction (aggregation or repulsion) between these points with this type of analysis, it is generally assumed that the two processes operate at different scales. Typically, we can test whether the points are aggregated at a small scale after accounting for a variation in density at a larger scale.</p>
</section>
</section>
<section id="relationship-between-two-point-patterns" class="level2">
<h2 class="anchored" data-anchor-id="relationship-between-two-point-patterns">Relationship between two point patterns</h2>
<p>Let’s consider a case where we have two point patterns, for example the position of trees of two species in a plot (orange and green points in the graph below). Each of the two patterns may or may not present an aggregation of points.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-17_b4289a87928bcb641b5e8e2bd2b6abf1">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-17-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Regardless of whether points are aggregated at the species level, we want to determine whether the two species are arranged independently. In other words, does the probability of observing a tree of one species depend on the presence of a tree of the other species at a given distance?</p>
<p>The bivariate version of Ripley’s <span class="math inline">\(K\)</span> allows us to answer this question. For two patterns noted 1 and 2, the function <span class="math inline">\(K_{12}(r)\)</span> calculates the mean number of points in pattern 2 within a radius <span class="math inline">\(r\)</span> from a point in pattern 1, standardized by the density of pattern 2.</p>
<p>In theory, this function is symmetrical, so <span class="math inline">\(K_{12}(r) = K_{21}(r)\)</span> and the result would be the same whether the points of pattern 1 or 2 are chosen as “focal” points for the analysis. However, the estimation of the two quantities for an observed pattern may differ, in particular because of edge effects. The variance of <span class="math inline">\(K_{12}\)</span> and <span class="math inline">\(K_{21}\)</span> between simulations of a null model may also differ, so the null hypothesis test may have more or less power depending on the choice of the focal species.</p>
<p>The choice of an appropriate null model is important here. In order to determine whether there is a significant attraction or repulsion between the two patterns, the position of one of the patterns must be randomly moved relative to that of the other pattern, while keeping the spatial structure of each pattern taken in isolation.</p>
<p>One way to do this randomization is to shift one of the two patterns horizontally and/or vertically by a random distance. The part of the pattern that “comes out” on one side of the window is attached to the other side. This method is called a toroidal shift, because by connecting the top and bottom as well as the left and right of a rectangular surface, we obtain the shape of a torus (a three-dimensional “donut”).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-18_2719c0934b27fb43697dae326b9542d1">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-18-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The graph above shows a translation of the green pattern to the right, while the orange pattern remains in the same place. The green points in the shaded area are brought back on the other side. Note that while this method generally preserves the structure of each pattern while randomizing their relative position, it can have some drawbacks, such as dividing point clusters that are near the cutoff point.</p>
<p>Let’s now check whether the position of the two species (birch and poplar) is independent in our plot. The function <code>Kcross</code> calculates the bivariate <span class="math inline">\(K_{ij}\)</span>, we must specify which type of point (mark) is considered as the focal species <span class="math inline">\(i\)</span> and the neighbouring species <span class="math inline">\(j\)</span>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-19_4dcee95d46a21e9800bad80559da1926">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">Kcross</span>(semis, <span class="at">i =</span> <span class="st">"P"</span>, <span class="at">j =</span> <span class="st">"B"</span>, <span class="at">correction =</span> <span class="st">"iso"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-19-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Here, the observed <span class="math inline">\(K\)</span> is lower than the theoretical value, indicating a possible repulsion between the two patterns.</p>
<p>To determine the envelope of the <span class="math inline">\(K\)</span> under the null hypothesis of independence of the two patterns, we must specify that the simulations are based on a translation of the patterns. We indicate that the simulations use the function <code>rshift</code> (random translation) with the argument <code>simulate = function(x) rshift(x, which = "B")</code>; here, the <code>x</code> argument in <code>simulate</code> corresponds to the original point pattern and the <code>which</code> argument indicates which of the patterns is translated. As in the previous case, the arguments needed for <code>Kcross</code>, i.e.&nbsp;<code>i</code>, <code>j</code> and <code>correction</code>, must be repeated in the <code>envelope</code> function.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-20_0ac003a9d3ff5047aa7ab53d990626d2">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">envelope</span>(semis, Kcross, <span class="at">i =</span> <span class="st">"P"</span>, <span class="at">j =</span> <span class="st">"B"</span>, <span class="at">correction =</span> <span class="st">"iso"</span>, </span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>              <span class="at">nsim =</span> <span class="dv">199</span>, <span class="at">nrank =</span> <span class="dv">5</span>, <span class="at">simulate =</span> <span class="cf">function</span>(x) <span class="fu">rshift</span>(x, <span class="at">which =</span> <span class="st">"B"</span>)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Generating 199 simulations by evaluating function  ...
1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114.116.118.120
.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154.156.158.160
.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194.196.198 199.

Done.</code></pre>
</div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-20-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Here, the observed curve is totally within the envelope, so we do not reject the null hypothesis of independence of the two patterns.</p>
<section id="questions" class="level3">
<h3 class="anchored" data-anchor-id="questions">Questions</h3>
<ol type="1">
<li><p>What would be one reason for our choice to translate the points of the birch rather than poplar?</p></li>
<li><p>Would the simulations generated by random translation be a good null model if the two patterns were heterogeneous?</p></li>
</ol>
</section>
</section>
<section id="marked-point-patterns" class="level2">
<h2 class="anchored" data-anchor-id="marked-point-patterns">Marked point patterns</h2>
<p>The <a href="data/fir.csv">fir.csv</a> dataset contains the <span class="math inline">\((x, y)\)</span> coordinates of 822 fir trees in a 1 hectare plot and their status (A = alive, D = dead) following a spruce budworm outbreak.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-21_facfc5f20aa18027ead60eade7d1f3e8">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>fir <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">"data/fir.csv"</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(fir)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      x     y status
1 31.50  1.00      A
2 85.25 30.75      D
3 83.50 38.50      A
4 84.00 37.75      A
5 83.00 33.25      A
6 33.25  0.25      A</code></pre>
</div>
</div>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-22_8ca66569ad633346ebe5c4d72856947e">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>fir <span class="ot">&lt;-</span> <span class="fu">ppp</span>(<span class="at">x =</span> fir<span class="sc">$</span>x, <span class="at">y =</span> fir<span class="sc">$</span>y, <span class="at">marks =</span> <span class="fu">as.factor</span>(fir<span class="sc">$</span>status),</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>           <span class="at">window =</span> <span class="fu">owin</span>(<span class="at">xrange =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">100</span>), <span class="at">yrange =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">100</span>)))</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(fir)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-22-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Suppose that we want to check whether fir mortality is independent or correlated between neighbouring trees. How does this question differ from the previous example, where we wanted to know if the position of the points of two species was independent?</p>
<p>In the previous example, the independence or interaction between the species referred to the formation of the pattern itself (whether or not seedlings of one species establish near those of the other species). Here, the characteristic of interest (survival) occurs after the establishment of the pattern, assuming that all those trees were alive at first and that some died as a result of the outbreak. So we take the position of the trees as fixed and we want to know whether the distribution of status (dead, alive) among those trees is random or shows a spatial pattern.</p>
<p>In Wiegand and Moloney’s textbook, the first situation (establishment of seedlings of two species) is called a bivariate pattern, so it is really two interacting patterns, while the second is a single pattern with a qualitative <em>mark</em>. The <em>spatstat</em> package in R does not differentiate between the two in terms of pattern definition (types of points are always represented by the <code>marks</code> argument), but the analysis methods applied to the two questions differ.</p>
<p>In the case of a pattern with a qualitative mark, we can define a <em>mark connection function</em> <span class="math inline">\(p_{ij}(r)\)</span>. For two points separated by a distance <span class="math inline">\(r\)</span>, this function gives the probability that the first point has the mark <span class="math inline">\(i\)</span> and the second the mark <span class="math inline">\(j\)</span>. Under the null hypothesis where the marks are independent, this probability is equal to the product of the proportions of each mark in the entire pattern, <span class="math inline">\(p_{ij}(r) = p_i p_j\)</span> independently of <span class="math inline">\(r\)</span>.</p>
<p>In <em>spatstat</em>, the mark connection function is computed with the <code>markconnect</code> function, where the marks <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> and the type of edge correction must be specified. In our example, we see that two closely spaced points are less likely to have a different status (A and D) than expected under the assumption of random and independent distribution of marks (red dotted line).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-23_ea3bee43b75cb2228264e2bba732134d">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">markconnect</span>(fir, <span class="at">i =</span> <span class="st">"A"</span>, <span class="at">j =</span> <span class="st">"D"</span>, <span class="at">correction =</span> <span class="st">"iso"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-23-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>In this graph, the fluctuations in the function are due to the estimation error of a continuous <span class="math inline">\(r\)</span> function from a limited number of discrete point pairs.</p>
<p>To simulate the null model in this case, we use the <code>rlabel</code> function, which randomly reassigns the marks among the points of the pattern, keeping the points’ positions fixed.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-24_b5961fa24a7b5816b3a04f809a6a674c">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">envelope</span>(fir, markconnect, <span class="at">i =</span> <span class="st">"A"</span>, <span class="at">j =</span> <span class="st">"D"</span>, <span class="at">correction =</span> <span class="st">"iso"</span>, </span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>              <span class="at">nsim =</span> <span class="dv">199</span>, <span class="at">nrank =</span> <span class="dv">5</span>, <span class="at">simulate =</span> rlabel))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Generating 199 simulations by evaluating function  ...
1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114.116.118.120
.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154.156.158.160
.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194.196.198 199.

Done.</code></pre>
</div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-24-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Note that since the <code>rlabel</code> function has only one required argument corresponding to the original point pattern, it was not necessary to specify: <code>simulate = function(x) rlabel(x)</code>.</p>
<p>Here are the results for tree pairs of the same status A or D:</p>
<div class="cell" data-fig.dim="[10,5]" data-hash="index_cache/html/unnamed-chunk-25_b52d50f419fba628767a4e51fec12988">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>))</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">envelope</span>(fir, markconnect, <span class="at">i =</span> <span class="st">"A"</span>, <span class="at">j =</span> <span class="st">"A"</span>, <span class="at">correction =</span> <span class="st">"iso"</span>, </span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>              <span class="at">nsim =</span> <span class="dv">199</span>, <span class="at">nrank =</span> <span class="dv">5</span>, <span class="at">simulate =</span> rlabel))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Generating 199 simulations by evaluating function  ...
1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114.116.118.120
.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154.156.158.160
.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194.196.198 199.

Done.</code></pre>
</div>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">envelope</span>(fir, markconnect, <span class="at">i =</span> <span class="st">"D"</span>, <span class="at">j =</span> <span class="st">"D"</span>, <span class="at">correction =</span> <span class="st">"iso"</span>, </span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>              <span class="at">nsim =</span> <span class="dv">199</span>, <span class="at">nrank =</span> <span class="dv">5</span>, <span class="at">simulate =</span> rlabel))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Generating 199 simulations by evaluating function  ...
1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114.116.118.120
.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154.156.158.160
.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194.196.198 199.

Done.</code></pre>
</div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-25-1.png" class="img-fluid" width="960"></p>
</div>
</div>
<p>It therefore appears that fir mortality due to this outbreak is spatially aggregated, since trees located in close proximity to each other have a greater probability of sharing the same status than predicted by the null hypothesis.</p>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<p>Fortin, M.-J. and Dale, M.R.T. (2005) <em>Spatial Analysis: A Guide for Ecologists</em>. Cambridge University Press: Cambridge, UK.</p>
<p>Wiegand, T. and Moloney, K.A. (2013) <em>Handbook of Spatial Point-Pattern Analysis in Ecology</em>, CRC Press.</p>
<p>The dataset in the last example is a subet of the Lake Duparquet Research and Teaching Forest (LDRTF) data, available on Dryad <a href="https://doi.org/10.5061/dryad.tqjq2bvwz">here</a>.</p>
</section>
</section>
<section id="solutions" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Solutions</h1>
<section id="exercise-1-1" class="level3">
<h3 class="anchored" data-anchor-id="exercise-1-1">Exercise 1</h3>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-26_b3fd18c8b6c242843edf3836d1967112">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">envelope</span>(semis_split[[<span class="dv">2</span>]], Kest, <span class="at">correction =</span> <span class="st">"iso"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Generating 99 simulations of CSR  ...
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,  99.

Done.</code></pre>
</div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-26-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Poplar seedlings seem to be significantly aggregated according to the <span class="math inline">\(K\)</span> function.</p>
</section>
<section id="exercise-2-1" class="level3">
<h3 class="anchored" data-anchor-id="exercise-2-1">Exercise 2</h3>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-27_acce28ca3e937720b0224ba60b6c233b">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>dens_p <span class="ot">&lt;-</span> <span class="fu">density</span>(semis_split[[<span class="dv">2</span>]], <span class="at">sigma =</span> <span class="dv">5</span>)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(dens_p)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(semis_split[[<span class="dv">2</span>]], <span class="at">add =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-27-1.png" class="img-fluid" width="672"></p>
</div>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>khet_p <span class="ot">&lt;-</span> <span class="fu">envelope</span>(semis_split[[<span class="dv">2</span>]], Kinhom, <span class="at">sigma =</span> <span class="dv">5</span>, <span class="at">correction =</span> <span class="st">"iso"</span>,</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>                   <span class="at">nsim =</span> <span class="dv">199</span>, <span class="at">nrank =</span> <span class="dv">5</span>, <span class="at">simulate =</span> <span class="cf">function</span>(x) <span class="fu">rpoispp</span>(dens_p))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Generating 199 simulations by evaluating function  ...
1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114.116.118.120
.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154.156.158.160
.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194.196.198 199.

Done.</code></pre>
</div>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(khet_p)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-27-2.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Here, as we estimate density variations at a larger scale, even after accounting for this variation, the poplar seedlings seem to be aggregated at a small scale.</p>
</section>
</section>
<section id="spatial-correlation" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Spatial correlation of a variable</h1>
<p>Correlation between measurements of a variable taken at nearby points often occurs in environmental data. This principle is sometimes referred to as the “first law of geography” and is expressed in the following quote from Waldo Tobler: “Everything is related to everything else, but near things are more related than distant things”.</p>
<p>In statistics, we often refer to <em>autocorrelation</em> as the correlation between measurements of the same variable taken at different times (temporal autocorrelation) or places (spatial autocorrelation).</p>
<section id="intrinsic-or-induced-dependence" class="level2">
<h2 class="anchored" data-anchor-id="intrinsic-or-induced-dependence">Intrinsic or induced dependence</h2>
<p>There are two basic types of spatial dependence on a measured variable <span class="math inline">\(y\)</span>: an <em>intrinsic</em> dependence on <span class="math inline">\(y\)</span>, or a dependence <em>induced</em> by external variables influencing <span class="math inline">\(y\)</span>, which are themselves spatially correlated.</p>
<p>For example, suppose that the abundance of a species is correlated between two sites located near each other:</p>
<ul>
<li><p>this spatial dependence can be induced if it is due to a spatial correlation of habitat factors that are favorable or unfavorable to the species;</p></li>
<li><p>or it can be intrinsic if it is due to the dispersion of individuals to nearby sites.</p></li>
</ul>
<p>In many cases, both types of dependence affect a given variable.</p>
<p>If the dependence is simply induced and the external variables that cause it are included in the model explaining <span class="math inline">\(y\)</span>, then the model residuals will be independent and we can use all the methods already seen that ignore spatial correlation.</p>
<p>However, if the dependence is intrinsic or due to unmeasured external factors, then the spatial correlation of the residuals in the model will have to be taken into account.</p>
</section>
<section id="different-ways-to-model-spatial-effects" class="level2">
<h2 class="anchored" data-anchor-id="different-ways-to-model-spatial-effects">Different ways to model spatial effects</h2>
<p>In this training, we will directly model the spatial correlations of our data. It is useful to compare this approach to other ways of including spatial aspects in a statistical model.</p>
<p>First, we could include predictors in the model that represent position (e.g., longitude, latitude). Such predictors may be useful for detecting a systematic large-scale trend or gradient, whether or not the trend is linear (e.g., with a generalized additive model).</p>
<p>In contrast to this approach, the models we will see now serve to model a spatial correlation in the random fluctuations of a variable (i.e., in the residuals after removing any systematic effect).</p>
<p>Mixed models use random effects to represent the non-independence of data on the basis of their grouping, i.e., after accounting for systematic fixed effects, data from the same group are more similar (their residual variation is correlated) than data from different groups. These groups were sometimes defined according to spatial criteria (observations grouped into sites).</p>
<p>However, in the context of a random group effect, all groups are as different from each other, e.g., two sites within 100 km of each other are no more or less similar than two sites 2 km apart.</p>
<p>The methods we will see here and in the next parts of the training therefore allow us to model non-independence on a continuous scale (closer = more correlated) rather than just discrete (hierarchy of groups).</p>
</section>
</section>
<section id="geostat-models" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Geostatistical models</h1>
<p>Geostatistics refers to a group of techniques that originated in the earth sciences. Geostatistics is concerned with variables that are continuously distributed in space and where a number of points are sampled to estimate this distribution. A classic example of these techniques comes from the mining field, where the aim was to create a map of the concentration of ore at a site from samples taken at different points on the site.</p>
<p>For these models, we will assume that <span class="math inline">\(z(x, y)\)</span> is a stationary spatial variable measured at points with coordinates <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>.</p>
<section id="variogram" class="level2">
<h2 class="anchored" data-anchor-id="variogram">Variogram</h2>
<p>A central aspect of geostatistics is the estimation of the variogram <span class="math inline">\(\gamma_z\)</span> . The variogram is equal to half the mean square difference between the values of <span class="math inline">\(z\)</span> for two points <span class="math inline">\((x_i, y_i)\)</span> and <span class="math inline">\((x_j, y_j)\)</span> separated by a distance <span class="math inline">\(h\)</span>.</p>
<p><span class="math display">\[\gamma_z(h) = \frac{1}{2} \text{E} \left[ \left( z(x_i, y_i) - z(x_j, y_j) \right)^2 \right]_{d_{ij} = h}\]</span></p>
<p>In this equation, the <span class="math inline">\(\text{E}\)</span> function with the index <span class="math inline">\(d_{ij}=h\)</span> designates the statistical expectation (i.e., the mean) of the squared deviation between the values of <span class="math inline">\(z\)</span> for points separated by a distance <span class="math inline">\(h\)</span>.</p>
<p>If we want instead to express the autocorrelation <span class="math inline">\(\rho_z(h)\)</span> between measures of <span class="math inline">\(z\)</span> separated by a distance <span class="math inline">\(h\)</span>, it is related to the variogram by the equation:</p>
<p><span class="math display">\[\gamma_z = \sigma_z^2(1 - \rho_z)\]</span> ,</p>
<p>where <span class="math inline">\(\sigma_z^2\)</span> is the global variance of <span class="math inline">\(z\)</span>.</p>
<p>Note that <span class="math inline">\(\gamma_z = \sigma_z^2\)</span> when we reach a distance where the measurements of <span class="math inline">\(z\)</span> are independent, so <span class="math inline">\(\rho_z = 0\)</span>. In this case, we can see that <span class="math inline">\(\gamma_z\)</span> is similar to a variance, although it is sometimes called “semivariogram” or “semivariance” because of the 1/2 factor in the above equation.</p>
</section>
<section id="theoretical-models-for-the-variogram" class="level2">
<h2 class="anchored" data-anchor-id="theoretical-models-for-the-variogram">Theoretical models for the variogram</h2>
<p>Several parametric models have been proposed to represent the spatial correlation as a function of the distance between sampling points. Let us first consider a correlation that decreases exponentially:</p>
<p><span class="math display">\[\rho_z(h) = e^{-h/r}\]</span></p>
<p>Here, <span class="math inline">\(\rho_z = 1\)</span> for <span class="math inline">\(h = 0\)</span> and the correlation is multiplied by <span class="math inline">\(1/e \approx 0.37\)</span> each time the distance increases by <span class="math inline">\(r\)</span>. In this context, <span class="math inline">\(r\)</span> is called the <em>range</em> of the correlation.</p>
<p>From the above equation, we can calculate the corresponding variogram.</p>
<p><span class="math display">\[\gamma_z(h) = \sigma_z^2 (1 - e^{-h/r})\]</span></p>
<p>Here is a graphical representation of this variogram.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-28_db8b05730133a816cb7d6c558cbd7757">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-28-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Because of the exponential function, the value of <span class="math inline">\(\gamma\)</span> at large distances approaches the global variance <span class="math inline">\(\sigma_z^2\)</span> without exactly reaching it. This asymptote is called a <em>sill</em> in the geostatistical context and is represented by the symbol <span class="math inline">\(s\)</span>.</p>
<p>Finally, it is sometimes unrealistic to assume a perfect correlation when the distance tends towards 0, because of a possible variation of <span class="math inline">\(z\)</span> at a very small scale. A <em>nugget</em> effect, denoted <span class="math inline">\(n\)</span>, can be added to the model so that <span class="math inline">\(\gamma\)</span> approaches <span class="math inline">\(n\)</span> (rather than 0) if <span class="math inline">\(h\)</span> tends towards 0. The term nugget comes from the mining origin of these techniques, where a nugget could be the source of a sudden small-scale variation in the concentration of a mineral.</p>
<p>By adding the nugget effect, the remainder of the variogram is “compressed” to keep the same sill, resulting in the following equation.</p>
<p><span class="math display">\[\gamma_z(h) = n + (s - n) (1 - e^{-h/r})\]</span></p>
<p>In the <em>gstat</em> package that we use below, the term <span class="math inline">\((s-n)\)</span> is called a <em>partial sill</em> or <code>psill</code> for the exponential portion of the variogram.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-29_76ce196068f7afb370f9fcd84ff0bf2d">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-29-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>In addition to the exponential model, two other common theoretical models for the variogram are the Gaussian model (where the correlation follows a half-normal curve), and the spherical model (where the variogram increases linearly at the start and then curves and reaches the plateau at a distance equal to its range <span class="math inline">\(r\)</span>). The spherical model thus allows the correlation to be exactly 0 at large distances, rather than gradually approaching zero in the case of the other models.</p>
<table class="table">
<colgroup>
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 40%">
</colgroup>
<thead>
<tr class="header">
<th>Model</th>
<th><span class="math inline">\(\rho(h)\)</span></th>
<th><span class="math inline">\(\gamma(h)\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Exponential</td>
<td><span class="math inline">\(\exp\left(-\frac{h}{r}\right)\)</span></td>
<td><span class="math inline">\(s \left(1 - \exp\left(-\frac{h}{r}\right)\right)\)</span></td>
</tr>
<tr class="even">
<td>Gaussian</td>
<td><span class="math inline">\(\exp\left(-\frac{h^2}{r^2}\right)\)</span></td>
<td><span class="math inline">\(s \left(1 - \exp\left(-\frac{h^2}{r^2}\right)\right)\)</span></td>
</tr>
<tr class="odd">
<td>Spherical <span class="math inline">\((h &lt; r)\)</span> *</td>
<td><span class="math inline">\(1 - \frac{3}{2}\frac{h}{r} + \frac{1}{2}\frac{h^3}{r^3}\)</span></td>
<td><span class="math inline">\(s \left(\frac{3}{2}\frac{h}{r} - \frac{1}{2}\frac{h^3}{r^3} \right)\)</span></td>
</tr>
</tbody>
</table>
<p>* For the spherical model, <span class="math inline">\(\rho = 0\)</span> and <span class="math inline">\(\gamma = s\)</span> if <span class="math inline">\(h \ge r\)</span>.</p>
<div class="cell" data-fig.dim="[9,4]" data-hash="index_cache/html/unnamed-chunk-30_36d08077ec0b54caf8dbcbb8751648be">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-30-1.png" class="img-fluid" width="864"></p>
</div>
</div>
</section>
<section id="empirical-variogram" class="level2">
<h2 class="anchored" data-anchor-id="empirical-variogram">Empirical variogram</h2>
<p>To estimate <span class="math inline">\(\gamma_z(h)\)</span> from empirical data, we need to define distance classes, thus grouping different distances within a margin of <span class="math inline">\(\pm \delta\)</span> around a distance <span class="math inline">\(h\)</span>, then calculating the mean square deviation for the pairs of points in that distance class.</p>
<p><span class="math display">\[\hat{\gamma_z}(h) = \frac{1}{2 N_{\text{paires}}} \sum \left[ \left( z(x_i, y_i) - z(x_j, y_j) \right)^2 \right]_{d_{ij} = h \pm \delta}\]</span></p>
<p>We will see in the next section how to estimate a variogram in R.</p>
</section>
<section id="regression-model-with-spatial-correlation" class="level2">
<h2 class="anchored" data-anchor-id="regression-model-with-spatial-correlation">Regression model with spatial correlation</h2>
<p>The following equation represents a multiple linear regression including residual spatial correlation:</p>
<p><span class="math display">\[v = \beta_0 + \sum_i \beta_i u_i + z + \epsilon\]</span></p>
<p>Here, <span class="math inline">\(v\)</span> designates the response variable and <span class="math inline">\(u\)</span> the predictors, to avoid confusion with the spatial coordinates <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>.</p>
<p>In addition to the residual <span class="math inline">\(\epsilon\)</span> that is independent between observations, the model includes a term <span class="math inline">\(z\)</span> that represents the spatially correlated portion of the residual variance.</p>
<p>Here are suggested steps to apply this type of model:</p>
<ol type="1">
<li><p>Fit the regression model without spatial correlation.</p></li>
<li><p>Verify the presence of spatial correlation from the empirical variogram of the residuals.</p></li>
<li><p>Fit one or more regression models with spatial correlation and select the one that shows the best fit to the data.</p></li>
</ol>
</section>
</section>
<section id="geostatistical-models-in-r" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> Geostatistical models in R</h1>
<p>The <em>gstat</em> package contains functions related to geostatistics. For this example, we will use the <code>oxford</code> dataset from this package, which contains measurements of physical and chemical properties for 126 soil samples from a site, along with their coordinates <code>XCOORD</code> and <code>YCOORD</code>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-31_d42a00ecb66d27e6d127659ed2dfd66c">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(gstat)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(oxford)</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(oxford)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>'data.frame':   126 obs. of  22 variables:
 $ PROFILE  : num  1 2 3 4 5 6 7 8 9 10 ...
 $ XCOORD   : num  100 100 100 100 100 100 100 100 100 100 ...
 $ YCOORD   : num  2100 2000 1900 1800 1700 1600 1500 1400 1300 1200 ...
 $ ELEV     : num  598 597 610 615 610 595 580 590 598 588 ...
 $ PROFCLASS: Factor w/ 3 levels "Cr","Ct","Ia": 2 2 2 3 3 2 3 2 3 3 ...
 $ MAPCLASS : Factor w/ 3 levels "Cr","Ct","Ia": 2 3 3 3 3 2 2 3 3 3 ...
 $ VAL1     : num  3 3 4 4 3 3 4 4 4 3 ...
 $ CHR1     : num  3 3 3 3 3 2 2 3 3 3 ...
 $ LIME1    : num  4 4 4 4 4 0 2 1 0 4 ...
 $ VAL2     : num  4 4 5 8 8 4 8 4 8 8 ...
 $ CHR2     : num  4 4 4 2 2 4 2 4 2 2 ...
 $ LIME2    : num  4 4 4 5 5 4 5 4 5 5 ...
 $ DEPTHCM  : num  61 91 46 20 20 91 30 61 38 25 ...
 $ DEP2LIME : num  20 20 20 20 20 20 20 20 40 20 ...
 $ PCLAY1   : num  15 25 20 20 18 25 25 35 35 12 ...
 $ PCLAY2   : num  10 10 20 10 10 20 10 20 10 10 ...
 $ MG1      : num  63 58 55 60 88 168 99 59 233 87 ...
 $ OM1      : num  5.7 5.6 5.8 6.2 8.4 6.4 7.1 3.8 5 9.2 ...
 $ CEC1     : num  20 22 17 23 27 27 21 14 27 20 ...
 $ PH1      : num  7.7 7.7 7.5 7.6 7.6 7 7.5 7.6 6.6 7.5 ...
 $ PHOS1    : num  13 9.2 10.5 8.8 13 9.3 10 9 15 12.6 ...
 $ POT1     : num  196 157 115 172 238 164 312 184 123 282 ...</code></pre>
</div>
</div>
<p>Suppose that we want to model the magnesium concentration (<code>MG1</code>), represented as a function of the spatial position in the following graph.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-32_cf223f9501bba263c237e06328f21358">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(oxford, <span class="fu">aes</span>(<span class="at">x =</span> YCOORD, <span class="at">y =</span> XCOORD, <span class="at">size =</span> MG1)) <span class="sc">+</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">coord_fixed</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-32-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Note that the <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> axes have been inverted to save space. The <code>coord_fixed()</code> function of <em>ggplot2</em> ensures that the scale is the same on both axes, which is useful for representing spatial data.</p>
<p>We can immediately see that these measurements were taken on a 100 m grid. It seems that the magnesium concentration is spatially correlated, although it may be a correlation induced by another variable. In particular, we know that the concentration of magnesium is negatively related to the soil pH (<code>PH1</code>).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-33_a9ec8bcf320a9e52d1252e4725f81bf7">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(oxford, <span class="fu">aes</span>(<span class="at">x =</span> PH1, <span class="at">y =</span> MG1)) <span class="sc">+</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-33-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The <code>variogram</code> function of <em>gstat</em> is used to estimate a variogram from empirical data. Here is the result obtained for the variable <code>MG1</code>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-34_c3f828164d93cc2b3d38500281fe87b9">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>var_mg <span class="ot">&lt;-</span> <span class="fu">variogram</span>(MG1 <span class="sc">~</span> <span class="dv">1</span>, <span class="at">locations =</span> <span class="sc">~</span> XCOORD <span class="sc">+</span> YCOORD, <span class="at">data =</span> oxford)</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>var_mg</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    np     dist    gamma dir.hor dir.ver   id
1  225 100.0000 1601.404       0       0 var1
2  200 141.4214 1950.805       0       0 var1
3  548 215.0773 2171.231       0       0 var1
4  623 303.6283 2422.245       0       0 var1
5  258 360.5551 2704.366       0       0 var1
6  144 400.0000 2948.774       0       0 var1
7  570 427.5569 2994.621       0       0 var1
8  291 500.0000 3402.058       0       0 var1
9  366 522.8801 3844.165       0       0 var1
10 200 577.1759 3603.060       0       0 var1
11 458 619.8400 3816.595       0       0 var1
12  90 670.8204 3345.739       0       0 var1</code></pre>
</div>
</div>
<p>The formula <code>MG1 ~ 1</code> indicates that no linear predictor is included in this model, while the argument <code>locations</code> indicates which variables in the data frame correspond to the spatial coordinates.</p>
<p>In the resulting table, <code>gamma</code> is the value of the variogram for the distance class centered on <code>dist</code>, while <code>np</code> is the number of pairs of points in that class. Here, since the points are located on a grid, we obtain regular distance classes (e.g.: 100 m for neighboring points on the grid, 141 m for diagonal neighbors, etc.).</p>
<p>Here, we limit ourselves to the estimation of isotropic variograms, i.e.&nbsp;the variogram depends only on the distance between the two points and not on the direction. Although we do not have time to see it today, it is possible with <em>gstat</em> to estimate the variogram separately in different directions.</p>
<p>We can illustrate the variogram with <code>plot</code>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-35_dced0e607669b721d5ef7df8faa51cb2">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(var_mg, <span class="at">col =</span> <span class="st">"black"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-35-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>If we want to estimate the residual spatial correlation of <code>MG1</code> after including the effect of <code>PH1</code>, we can add that predictor to the formula.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-36_41f230bd5a30f1cb7752e89e361c338a">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>var_mg <span class="ot">&lt;-</span> <span class="fu">variogram</span>(MG1 <span class="sc">~</span> PH1, <span class="at">locations =</span> <span class="sc">~</span> XCOORD <span class="sc">+</span> YCOORD, <span class="at">data =</span> oxford)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(var_mg, <span class="at">col =</span> <span class="st">"black"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-36-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Including the effect of pH, the range of the spatial correlation seems to decrease, while the plateau is reached around 300 m. It even seems that the variogram decreases beyond 400 m. In general, we assume that the variance between two points does not decrease with distance, unless there is a periodic spatial pattern.</p>
<p>The function <code>fit.variogram</code> accepts as arguments a variogram estimated from the data, as well as a theoretical model described in a <code>vgm</code> function, and then estimates the parameters of that model according to the data. The fitting is done by the method of least squares.</p>
<p>For example, <code>vgm("Exp")</code> means we want to fit an exponential model.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-37_b852e100bd05bd7def030586576b386c">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>vfit <span class="ot">&lt;-</span> <span class="fu">fit.variogram</span>(var_mg, <span class="fu">vgm</span>(<span class="st">"Exp"</span>))</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>vfit</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  model    psill    range
1   Nug    0.000  0.00000
2   Exp 1951.496 95.11235</code></pre>
</div>
</div>
<p>There is no nugget effect, because <code>psill = 0</code> for the <code>Nug</code> (nugget) part of the model. The exponential part has a sill at 1951 and a range of 95 m.</p>
<p>To compare different models, a vector of model names can be given to <code>vgm</code>. In the following example, we include the exponential, gaussian (“Gau”) and spherical (“Sph”) models.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-38_5af5359b8627d50d97bf2175f4728362">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>vfit <span class="ot">&lt;-</span> <span class="fu">fit.variogram</span>(var_mg, <span class="fu">vgm</span>(<span class="fu">c</span>(<span class="st">"Exp"</span>, <span class="st">"Gau"</span>, <span class="st">"Sph"</span>)))</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>vfit</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  model    psill    range
1   Nug    0.000  0.00000
2   Exp 1951.496 95.11235</code></pre>
</div>
</div>
<p>The function gives us the result of the model with the best fit (lowest sum of squared deviations), which here is the same exponential model.</p>
<p>Finally, we can superimpose the theoretical model and the empirical variogram on the same graph.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-39_acab997244a63895e5eaedd7b9e62465">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(var_mg, vfit, <span class="at">col =</span> <span class="st">"black"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-39-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<section id="regression-with-spatial-correlation" class="level2">
<h2 class="anchored" data-anchor-id="regression-with-spatial-correlation">Regression with spatial correlation</h2>
<p>We have seen above that the <em>gstat</em> package allows us to estimate the variogram of the residuals of a linear model. In our example, the magnesium concentration was modeled as a function of pH, with spatially correlated residuals.</p>
<p>Another tool to fit this same type of model is the <code>gls</code> function of the <em>nlme</em> package, which is included with the installation of R.</p>
<p>This function applies the <em>generalized least squares</em> method to fit linear regression models when the residuals are not independent or when the residual variance is not the same for all observations. Since the estimates of the coefficients depend on the estimated correlations between the residuals and the residuals themselves depend on the coefficients, the model is fitted by an iterative algorithm:</p>
<ol type="1">
<li><p>A classical linear regression model (without correlation) is fitted to obtain residuals.</p></li>
<li><p>The spatial correlation model (variogram) is fitted with those residuals.</p></li>
<li><p>The regression coefficients are re-estimated, now taking into account the correlations.</p></li>
</ol>
<p>Steps 2 and 3 are repeated until the estimates are stable at a desired precision.</p>
<p>Here is the application of this method to the same model for the magnesium concentration in the <code>oxford</code> dataset. In the <code>correlation</code> argument of <code>gls</code>, we specify an exponential correlation model as a function of our spatial coordinates and we include a possible nugget effect.</p>
<p>In addition to the exponential correlation <code>corExp</code>, the <code>gls</code> function can also estimate a Gaussian (<code>corGaus</code>) or spherical (<code>corSpher</code>) model.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-40_0b3199847595fbf9b39d87618cbffc8f">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(nlme)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>gls_mg <span class="ot">&lt;-</span> <span class="fu">gls</span>(MG1 <span class="sc">~</span> PH1, oxford, </span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>              <span class="at">correlation =</span> <span class="fu">corExp</span>(<span class="at">form =</span> <span class="sc">~</span> XCOORD <span class="sc">+</span> YCOORD, <span class="at">nugget =</span> <span class="cn">TRUE</span>))</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(gls_mg)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Generalized least squares fit by REML
  Model: MG1 ~ PH1 
  Data: oxford 
      AIC      BIC   logLik
  1278.65 1292.751 -634.325

Correlation Structure: Exponential spatial correlation
 Formula: ~XCOORD + YCOORD 
 Parameter estimate(s):
      range      nugget 
478.0322964   0.2944753 

Coefficients:
               Value Std.Error   t-value p-value
(Intercept) 391.1387  50.42343  7.757084       0
PH1         -41.0836   6.15662 -6.673079       0

 Correlation: 
    (Intr)
PH1 -0.891

Standardized residuals:
       Min         Q1        Med         Q3        Max 
-2.1846957 -0.6684520 -0.3687813  0.4627580  3.1918604 

Residual standard error: 53.8233 
Degrees of freedom: 126 total; 124 residual</code></pre>
</div>
</div>
<p>To compare this result with the adjusted variogram above, the parameters given by <code>gls</code> must be transformed. The range has the same meaning in both cases and corresponds to 478 m for the result of <code>gls</code>. The global variance of the residuals is the square of <code>Residual standard error</code>. The nugget effect here (0.294) is expressed as a fraction of that variance. Finally, to obtain the partial sill of the exponential part, the nugget effect must be subtracted from the total variance.</p>
<p>After performing these calculations, we can give these parameters to the <code>vgm</code> function of <em>gstat</em> to superimpose this variogram estimated by <code>gls</code> on our variogram of the residuals of the classical linear model.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-41_bdace2c5570a84ab706e3cc520568742">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>gls_range <span class="ot">&lt;-</span> <span class="dv">478</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>gls_var <span class="ot">&lt;-</span> <span class="fl">53.823</span><span class="sc">^</span><span class="dv">2</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>gls_nugget <span class="ot">&lt;-</span> <span class="fl">0.294</span> <span class="sc">*</span> gls_var</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>gls_psill <span class="ot">&lt;-</span> gls_var <span class="sc">-</span> gls_nugget</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>gls_vgm <span class="ot">&lt;-</span> <span class="fu">vgm</span>(<span class="st">"Exp"</span>, <span class="at">psill =</span> gls_psill, <span class="at">range =</span> gls_range, <span class="at">nugget =</span> gls_nugget)</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(var_mg, gls_vgm, <span class="at">col =</span> <span class="st">"black"</span>, <span class="at">ylim =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">4000</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-41-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Does the model fit the data less well here? In fact, this empirical variogram represented by the points was obtained from the residuals of the linear model ignoring the spatial correlation, so it is a biased estimate of the actual spatial correlations. The method is still adequate to quickly check if spatial correlations are present. However, to simultaneously fit the regression coefficients and the spatial correlation parameters, the generalized least squares (GLS) approach is preferable and will produce more accurate estimates.</p>
<p>Finally, note that the result of the <code>gls</code> model also gives the AIC, which we can use to compare the fit of different models (with different predictors or different forms of spatial correlation).</p>
</section>
<section id="exercise" class="level2">
<h2 class="anchored" data-anchor-id="exercise">Exercise</h2>
<p>The <a href="data/bryo_belg.csv">bryo_belg.csv</a> dataset is adapted from the data of this study:</p>
<blockquote class="blockquote">
<p>Neyens, T., Diggle, P.J., Faes, C., Beenaerts, N., Artois, T. et Giorgi, E. (2019) Mapping species richness using opportunistic samples: a case study on ground-floor bryophyte species richness in the Belgian province of Limburg. <em>Scientific Reports</em> 9, 19122. https://doi.org/10.1038/s41598-019-55593-x</p>
</blockquote>
<p>This data frame shows the specific richness of ground bryophytes (<em>richness</em>) for different sampling points in the Belgian province of Limburg, with their position <em>(x, y)</em> in km, in addition to information on the proportion of forest (<em>forest</em>) and wetlands (<em>wetland</em>) in a 1 km^2$ cell containing the sampling point.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-42_c25ae6f03a62752dff743e2d40b205a0">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>bryo_belg <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">"data/bryo_belg.csv"</span>)</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(bryo_belg)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  richness    forest   wetland        x        y
1        9 0.2556721 0.5036614 228.9516 220.8869
2        6 0.6449114 0.1172068 227.6714 219.8613
3        5 0.5039905 0.6327003 228.8252 220.1073
4        3 0.5987329 0.2432942 229.2775 218.9035
5        2 0.7600775 0.1163538 209.2435 215.2414
6       10 0.6865434 0.0000000 210.4142 216.5579</code></pre>
</div>
</div>
<p>For this exercise, we will use the square root of the specific richness as the response variable. The square root transformation often allows to homogenize the variance of the count data in order to apply a linear regression.</p>
<ol type="a">
<li><p>Fit a linear model of the transformed species richness to the proportion of forest and wetlands, without taking into account spatial correlations. What is the effect of the two predictors in this model?</p></li>
<li><p>Calculate the empirical variogram of the model residuals in (a). Does there appear to be a spatial correlation between the points?</p></li>
</ol>
<p><em>Note</em>: The <code>cutoff</code> argument to the <code>variogram</code> function specifies the maximum distance at which the variogram is calculated. You can manually adjust this value to get a good view of the sill.</p>
<ol start="3" type="a">
<li><p>Re-fit the linear model in (a) with the <code>gls</code> function in the <em>nlme</em> package, trying different types of spatial correlations (exponential, Gaussian, spherical). Compare the models (including the one without spatial correlation) with the AIC.</p></li>
<li><p>What is the effect of the proportion of forests and wetlands according to the model in (c)? Explain the differences between the conclusions of this model and the model in (a).</p></li>
</ol>
</section>
</section>
<section id="kriging" class="level1" data-number="8">
<h1 data-number="8"><span class="header-section-number">8</span> Kriging</h1>
<p>As mentioned before, a common application of geostatistical models is to predict the value of the response variable at unsampled locations, a form of spatial interpolation called kriging (pronounced with a hard “g”).</p>
<p>There are three basic types of kriging based on the assumptions made about the response variable:</p>
<ul>
<li><p>Ordinary kriging: Stationary variable with an unknown mean.</p></li>
<li><p>Simple kriging: Stationary variable with a known mean.</p></li>
<li><p>Universal kriging: Variable with a trend given by a linear or non-linear model.</p></li>
</ul>
<p>For all kriging methods, the predictions at a new point are a weighted mean of the values at known points. These weights are chosen so that kriging provides the best linear unbiased prediction of the response variable, if the model assumptions (in particular the variogram) are correct. That is, among all possible unbiased predictions, the weights are chosen to give the minimum mean square error. Kriging also provides an estimate of the uncertainty of each prediction.</p>
<p>While we will not present the detailed kriging equations here, the weights depend on both the correlations (estimated by the variogram) between the sampled points and the new point, as well of the correlations between the sampled points themselves. In other words, sampled points near the new point are given more weight, but isolated sampled points are also given more weight, because sample points close to each other provide redundant information.</p>
<p>Kriging is an interpolation method, so the prediction at a sampled point will always be equal to the measured value (the measurement is supposed to have no error, just spatial variation). However, in the presence of a nugget effect, any small displacement from the sampled location will show variability according to the nugget.</p>
<p>In the example below, we generate a new dataset composed of randomly-generated (x, y) coordinates within the study area as well as randomly-generated pH values based on the <code>oxford</code> data. We then apply the function <code>krige</code> to predict the magnesium values at these new points. Note that we specify the variogram derived from the GLS results in the <code>model</code> argument to <code>krige</code>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-43_f81acecbca5eefa202e114614faebc54">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">14</span>)</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>new_points <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">XCOORD =</span> <span class="fu">runif</span>(<span class="dv">100</span>, <span class="fu">min</span>(oxford<span class="sc">$</span>XCOORD), <span class="fu">max</span>(oxford<span class="sc">$</span>XCOORD)),</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">YCOORD =</span> <span class="fu">runif</span>(<span class="dv">100</span>, <span class="fu">min</span>(oxford<span class="sc">$</span>YCOORD), <span class="fu">max</span>(oxford<span class="sc">$</span>YCOORD)),</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">PH1 =</span> <span class="fu">rnorm</span>(<span class="dv">100</span>, <span class="fu">mean</span>(oxford<span class="sc">$</span>PH1), <span class="fu">sd</span>(oxford<span class="sc">$</span>PH1))</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>pred <span class="ot">&lt;-</span> <span class="fu">krige</span>(MG1 <span class="sc">~</span> PH1, <span class="at">locations =</span> <span class="sc">~</span> XCOORD <span class="sc">+</span> YCOORD, <span class="at">data =</span> oxford,</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>              <span class="at">newdata =</span> new_points, <span class="at">model =</span> gls_vgm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[using universal kriging]</code></pre>
</div>
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(pred)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    XCOORD    YCOORD var1.pred var1.var
1 227.0169  162.1185  47.13065 1269.002
2 418.9136  465.9013  79.68437 1427.269
3 578.5943 2032.7477  60.30539 1264.471
4 376.2734 1530.7193 127.22366 1412.875
5 591.5336  421.6290 105.88124 1375.485
6 355.7369  404.3378 127.73055 1250.114</code></pre>
</div>
</div>
<p>The result of <code>krige</code> includes the new point coordinates, the prediction of the variable <code>var1.pred</code> along with its estimated variance <code>var1.var</code>. In the graph below, we show the mean MG1 predictions from kriging (triangles) along with the measurements (circles).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-44_8a46f7bb0f5137f5dae6fef418b6b61e">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>pred<span class="sc">$</span>MG1 <span class="ot">&lt;-</span> pred<span class="sc">$</span>var1.pred</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(oxford, <span class="fu">aes</span>(<span class="at">x =</span> YCOORD, <span class="at">y =</span> XCOORD, <span class="at">color =</span> MG1)) <span class="sc">+</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>(<span class="at">data =</span> pred, <span class="at">shape =</span> <span class="dv">17</span>, <span class="at">size =</span> <span class="dv">2</span>) <span class="sc">+</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">coord_fixed</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-44-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The estimated mean and variance from kriging can be used to simulate possible values of the variable at each new point, conditional on the sampled values. In the example below, we performed 4 conditional simulations by adding the argument <code>nsim = 4</code> to the same <code>krige</code> instruction.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-45_15e6975ae8f74fb12acd4b9d15610303">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>sim_mg <span class="ot">&lt;-</span> <span class="fu">krige</span>(MG1 <span class="sc">~</span> PH1, <span class="at">locations =</span> <span class="sc">~</span> XCOORD <span class="sc">+</span> YCOORD, <span class="at">data =</span> oxford,</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>                <span class="at">newdata =</span> new_points, <span class="at">model =</span> gls_vgm, <span class="at">nsim =</span> <span class="dv">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>drawing 4 GLS realisations of beta...
[using conditional Gaussian simulation]</code></pre>
</div>
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(sim_mg)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    XCOORD    YCOORD       sim1      sim2      sim3      sim4
1 227.0169  162.1185   9.638739  34.53159  46.08685  77.86376
2 418.9136  465.9013  60.029144  20.17179  76.46333  59.57924
3 578.5943 2032.7477 100.791412  77.47887  73.50058  59.40279
4 376.2734 1530.7193 112.615730 150.96664  78.76125 146.83928
5 591.5336  421.6290  70.925240  72.85522 153.90610 126.63758
6 355.7369  404.3378 161.608032 118.93640 134.45695 142.20074</code></pre>
</div>
</div>
<div class="cell" data-fig.dim="[10,5]" data-hash="index_cache/html/unnamed-chunk-46_dc67747871861d460645cc2d898c2797">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyr)</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>sim_mg <span class="ot">&lt;-</span> <span class="fu">pivot_longer</span>(sim_mg, <span class="at">cols =</span> <span class="fu">c</span>(sim1, sim2, sim3, sim4), </span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>                       <span class="at">names_to =</span> <span class="st">"sim"</span>, <span class="at">values_to =</span> <span class="st">"MG1"</span>)</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(sim_mg, <span class="fu">aes</span>(<span class="at">x =</span> YCOORD, <span class="at">y =</span> XCOORD, <span class="at">color =</span> MG1)) <span class="sc">+</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">coord_fixed</span>() <span class="sc">+</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">facet_wrap</span>(<span class="sc">~</span> sim)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-46-1.png" class="img-fluid" width="960"></p>
</div>
</div>
</section>
<section id="solutions-1" class="level1" data-number="9">
<h1 data-number="9"><span class="header-section-number">9</span> Solutions</h1>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-47_46625f4b0eb7a89df12358298784d779">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>bryo_lm <span class="ot">&lt;-</span> <span class="fu">lm</span>(<span class="fu">sqrt</span>(richness) <span class="sc">~</span> forest <span class="sc">+</span> wetland, <span class="at">data =</span> bryo_belg)</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(bryo_lm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = sqrt(richness) ~ forest + wetland, data = bryo_belg)

Residuals:
    Min      1Q  Median      3Q     Max 
-1.8847 -0.4622  0.0545  0.4974  2.3116 

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)  2.34159    0.08369  27.981  &lt; 2e-16 ***
forest       1.11883    0.13925   8.034 9.74e-15 ***
wetland     -0.59264    0.17216  -3.442 0.000635 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 0.7095 on 417 degrees of freedom
Multiple R-squared:  0.2231,    Adjusted R-squared:  0.2193 
F-statistic: 59.86 on 2 and 417 DF,  p-value: &lt; 2.2e-16</code></pre>
</div>
</div>
<p>The proportion of forest has a significant positive effect and the proportion of wetlands has a significant negative effect on bryophyte richness.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-48_9f1b47ee10d87121e3853375afbb8273">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">variogram</span>(<span class="fu">sqrt</span>(richness) <span class="sc">~</span> forest <span class="sc">+</span> wetland, <span class="at">locations =</span> <span class="sc">~</span> x <span class="sc">+</span> y,</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>               <span class="at">data =</span> bryo_belg, <span class="at">cutoff =</span> <span class="dv">50</span>), <span class="at">col =</span> <span class="st">"black"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-48-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The variogram is increasing from 0 to at least 40 km, so there appears to be spatial correlations in the model residuals.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-49_2a94f7a8b64ea0bb9127648e255fcbd3">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>bryo_exp <span class="ot">&lt;-</span> <span class="fu">gls</span>(<span class="fu">sqrt</span>(richness) <span class="sc">~</span> forest <span class="sc">+</span> wetland, <span class="at">data =</span> bryo_belg,</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>                <span class="at">correlation =</span> <span class="fu">corExp</span>(<span class="at">form =</span> <span class="sc">~</span> x <span class="sc">+</span> y, <span class="at">nugget =</span> <span class="cn">TRUE</span>))</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>bryo_gaus <span class="ot">&lt;-</span> <span class="fu">gls</span>(<span class="fu">sqrt</span>(richness) <span class="sc">~</span> forest <span class="sc">+</span> wetland, <span class="at">data =</span> bryo_belg,</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>                <span class="at">correlation =</span> <span class="fu">corGaus</span>(<span class="at">form =</span> <span class="sc">~</span> x <span class="sc">+</span> y, <span class="at">nugget =</span> <span class="cn">TRUE</span>))</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>bryo_spher <span class="ot">&lt;-</span> <span class="fu">gls</span>(<span class="fu">sqrt</span>(richness) <span class="sc">~</span> forest <span class="sc">+</span> wetland, <span class="at">data =</span> bryo_belg,</span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>                  <span class="at">correlation =</span> <span class="fu">corSpher</span>(<span class="at">form =</span> <span class="sc">~</span> x <span class="sc">+</span> y, <span class="at">nugget =</span> <span class="cn">TRUE</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-50_9d306abf18fdbd164c34d87f9f9832d8">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="fu">AIC</span>(bryo_lm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 908.6358</code></pre>
</div>
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="fu">AIC</span>(bryo_exp)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 867.822</code></pre>
</div>
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="fu">AIC</span>(bryo_gaus)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 870.9592</code></pre>
</div>
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="fu">AIC</span>(bryo_spher)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 866.9117</code></pre>
</div>
</div>
<p>The spherical model has the smallest AIC.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-51_5c26da31bc0b2db751ce60929eb7b8be">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(bryo_spher)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Generalized least squares fit by REML
  Model: sqrt(richness) ~ forest + wetland 
  Data: bryo_belg 
       AIC      BIC    logLik
  866.9117 891.1102 -427.4558

Correlation Structure: Spherical spatial correlation
 Formula: ~x + y 
 Parameter estimate(s):
     range     nugget 
43.1727664  0.6063187 

Coefficients:
                 Value Std.Error   t-value p-value
(Intercept)  2.0368769 0.2481636  8.207800   0.000
forest       0.6989844 0.1481690  4.717481   0.000
wetland     -0.2441130 0.1809118 -1.349348   0.178

 Correlation: 
        (Intr) forest
forest  -0.251       
wetland -0.235  0.241

Standardized residuals:
        Min          Q1         Med          Q3         Max 
-1.75204183 -0.06568688  0.61415597  1.15240370  3.23322743 

Residual standard error: 0.7998264 
Degrees of freedom: 420 total; 417 residual</code></pre>
</div>
</div>
<p>Both effects are less important in magnitude and the effect of wetlands is not significant anymore. As is the case for other types of non-independent residuals, the “effective sample size” here is less than the number of points, since points close to each other provide redundant information. Therefore, the relationship between predictors and response is less clear than given by the model assuming all these points were independent.</p>
<p>Note that the results for all three <code>gls</code> models are quite similar, so the choice to include spatial correlations was more important than the exact shape assumed for the variogram.</p>
</section>
<section id="areal-data" class="level1" data-number="10">
<h1 data-number="10"><span class="header-section-number">10</span> Areal data</h1>
<p>Areal data are variables measured for regions of space, defined by polygons. This type of data is more common in the social sciences, human geography and epidemiology, where data is often available at the scale of administrative divisions.</p>
<p>This type of data also appears frequently in natural resource management. For example, the following map shows the forest management units of the Ministère de la Forêt, de la Faune et des Parcs du Québec.</p>
<p><img src="images/cartes_unites.png" class="img-fluid"></p>
<p>Suppose that a variable is available at the level of these management units. How can we model the spatial correlation between units that are spatially close together?</p>
<p>One option would be to apply the geostatistical methods seen before, for example by calculating the distance between the centers of the polygons.</p>
<p>Another option, which is more adapted for areal data, is to define a network where each region is connected to neighbouring regions by a link. It is then assumed that the variables are directly correlated between neighbouring regions only. (Note, however, that direct correlations between immediate neighbours also generate indirect correlations for a chain of neighbours).</p>
<p>In this type of model, the correlation is not necessarily the same from one link to another. In this case, each link in the network can be associated with a <em>weight</em> representing its importance for the spatial correlation. We represent these weights by a matrix <span class="math inline">\(W\)</span> where <span class="math inline">\(w_{ij}\)</span> is the weight of the link between regions <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>. A region has no link with itself, so <span class="math inline">\(w_{ii} = 0\)</span>.</p>
<p>A simple choice for <span class="math inline">\(W\)</span> is to assign a weight equal to 1 if the regions are neighbours, otherwise 0 (binary weight).</p>
<p>In addition to land divisions represented by polygons, another example of areal data consists of a grid where the variable is calculated for each cell of the grid. In this case, a cell generally has 4 or 8 neighbouring cells, depending on whether diagonals are included or not.</p>
</section>
<section id="moran-i" class="level1" data-number="11">
<h1 data-number="11"><span class="header-section-number">11</span> Moran’s I</h1>
<p>Before discussing spatial autocorrelation models, we present Moran’s <span class="math inline">\(I\)</span> statistic, which allows us to test whether a significant correlation is present between neighbouring regions.</p>
<p>Moran’s <span class="math inline">\(I\)</span> is a spatial autocorrelation coefficient of <span class="math inline">\(z\)</span>, weighted by the <span class="math inline">\(w_{ij}\)</span>. It therefore takes values between -1 and 1.</p>
<p><span class="math display">\[I = \frac{N}{\sum_i \sum_j w_{ij}} \frac{\sum_i \sum_j w_{ij} (z_i - \bar{z}) (z_j - \bar{z})}{\sum_i (z_i - \bar{z})^2}\]</span></p>
<p>In this equation, we recognize the expression of a correlation, which is the product of the deviations from the mean for two variables <span class="math inline">\(z_i\)</span> and <span class="math inline">\(z_j\)</span>, divided by the product of their standard deviations (it is the same variable here, so we get the variance). The contribution of each pair <span class="math inline">\((i, j)\)</span> is multiplied by its weight <span class="math inline">\(w_{ij}\)</span> and the term on the left (the number of regions <span class="math inline">\(N\)</span> divided by the sum of the weights) ensures that the result is bounded between -1 and 1.</p>
<p>Since the distribution of <span class="math inline">\(I\)</span> is known in the absence of spatial autocorrelation, this statistic serves to test the null hypothesis that there is no spatial correlation between neighbouring regions.</p>
<p>Although we will not see an example in this course, Moran’s <span class="math inline">\(I\)</span> can also be applied to point data. In this case, we divide the pairs of points into distance classes and calculate <span class="math inline">\(I\)</span> for each distance class; the weight <span class="math inline">\(w_{ij} = 1\)</span> if the distance between <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> is in the desired distance class, otherwise 0.</p>
</section>
<section id="spatial-autoreg" class="level1" data-number="12">
<h1 data-number="12"><span class="header-section-number">12</span> Spatial autoregression models</h1>
<p>Let us recall the formula for a linear regression with spatial dependence:</p>
<p><span class="math display">\[v = \beta_0 + \sum_i \beta_i u_i + z + \epsilon\]</span></p>
<p>where <span class="math inline">\(z\)</span> is the portion of the residual variance that is spatially correlated.</p>
<p>There are two main types of autoregressive models to represent the spatial dependence of <span class="math inline">\(z\)</span>: conditional autoregression (CAR) and simultaneous autoregressive (SAR).</p>
<section id="conditional-autoregressive-car-model" class="level2">
<h2 class="anchored" data-anchor-id="conditional-autoregressive-car-model">Conditional autoregressive (CAR) model</h2>
<p>In the conditional autoregressive model, the value of <span class="math inline">\(z_i\)</span> for the region <span class="math inline">\(i\)</span> follows a normal distribution: its mean depends on the value <span class="math inline">\(z_j\)</span> of neighbouring regions, multiplied by the weight <span class="math inline">\(w_{ij}\)</span> and a correlation coefficient <span class="math inline">\(\rho\)</span>; its standard deviation <span class="math inline">\(\sigma_{z_i}\)</span> may vary from one region to another.</p>
<p><span class="math display">\[z_i \sim \text{N}\left(\sum_j \rho w_{ij} z_j,\sigma_{z_i} \right)\]</span></p>
<p>In this model, if <span class="math inline">\(w_{ij}\)</span> is a binary matrix (0 for non-neighbours, 1 for neighbours), then <span class="math inline">\(\rho\)</span> is the coefficient of partial correlation between neighbouring regions. This is similar to a first-order autoregressive model in the context of time series, where the autoregression coefficient indicates the partial correlation.</p>
</section>
<section id="simultaneous-autoregressive-sar-model" class="level2">
<h2 class="anchored" data-anchor-id="simultaneous-autoregressive-sar-model">Simultaneous autoregressive (SAR) model</h2>
<p>In the simultaneous autoregressive model, the value of <span class="math inline">\(z_i\)</span> is given directly by the sum of contributions from neighbouring values <span class="math inline">\(z_j\)</span>, multiplied by <span class="math inline">\(\rho w_{ij}\)</span>, with an independent residual <span class="math inline">\(\nu_i\)</span> of standard deviation <span class="math inline">\(\sigma_z\)</span>.</p>
<p><span class="math display">\[z_i = \sum_j \rho w_{ij} z_j + \nu_i\]</span></p>
<p>At first glance, this looks like a temporal autoregressive model. However, there is an important conceptual difference. For temporal models, the causal influence is directed in only one direction: <span class="math inline">\(v(t-2)\)</span> affects <span class="math inline">\(v(t-1)\)</span> which then affects <span class="math inline">\(v(t)\)</span>. For a spatial model, each <span class="math inline">\(z_j\)</span> that affects <span class="math inline">\(z_i\)</span> depends in turn on <span class="math inline">\(z_i\)</span>. Thus, to determine the joint distribution of <span class="math inline">\(z\)</span>, a system of equations must be solved simultaneously (hence the name of the model).</p>
<p>For this reason, although this model resembles the formula of CAR model, the solutions of the two models differ and in the case of SAR, the coefficient <span class="math inline">\(\rho\)</span> is not directly equal to the partial correlation due to each neighbouring region.</p>
<p>For more details on the mathematical aspects of these models, see the article by Ver Hoef et al.&nbsp;(2018) suggested in reference.</p>
<p>For the moment, we will consider SAR and CAR as two types of possible models to represent a spatial correlation on a network. We can always fit several models and compare them with the AIC to choose the best form of correlation or the best weight matrix.</p>
<p>The CAR and SAR models share an advantage over geostatistical models in terms of efficiency. In a geostatistical model, spatial correlations are defined between each pair of points, although they become negligible as distance increases. For a CAR or SAR model, only neighbouring regions contribute and most weights are equal to 0, making these models faster to fit than a geostatistical model when the data are massive.</p>
</section>
</section>
<section id="analysis-areal" class="level1" data-number="13">
<h1 data-number="13"><span class="header-section-number">13</span> Analysis of areal data in R</h1>
<p>To illustrate the analysis of areal data in R, we load the packages <em>sf</em> (to read geospatial data), <em>spdep</em> (to define spatial networks and calculate Moran’s <span class="math inline">\(I\)</span>) and <em>spatialreg</em> (for SAR and CAR models).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-52_bbb39418b6f206ecf18ea280d1186280">
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(sf)</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(spdep)</span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(spatialreg)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As an example, we will use a dataset that presents some of the results of the 2018 provincial election in Quebec, with population characteristics of each riding. This data is included in a <em>shapefile</em> (.shp) file type, which we can read with the <code>read_sf</code> function of the <em>sf</em> package.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-53_57544cb924c4156b05da2ae4a2ea020a">
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>elect2018 <span class="ot">&lt;-</span> <span class="fu">read_sf</span>(<span class="st">"data/elect2018.shp"</span>)</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(elect2018)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Simple feature collection with 6 features and 9 fields
Geometry type: MULTIPOLYGON
Dimension:     XY
Bounding box:  xmin: 97879.03 ymin: 174515.3 xmax: 694261.1 ymax: 599757.1
Projected CRS: LambertAQ
# A tibble: 6 × 10
  circ             age_moy pct_frn pct_prp rev_med propCAQ propPQ propPLQ propQS
  &lt;chr&gt;              &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;int&gt;   &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;
1 Abitibi-Est         40.8   0.963   0.644   34518    42.7   19.5    18.8   15.7
2 Abitibi-Ouest       42.2   0.987   0.735   33234    34.1   33.3    11.3   16.6
3 Acadie              40.3   0.573   0.403   25391    16.5    9      53.8   13.8
4 Anjou-Louis-Riel    43.5   0.821   0.416   31275    28.9   14.7    39.1   14.5
5 Argenteuil          43.3   0.858   0.766   31097    38.9   21.1    17.4   12.2
6 Arthabaska          43.4   0.989   0.679   30082    61.8    9.4    11.4   12.6
# … with 1 more variable: geometry &lt;MULTIPOLYGON [m]&gt;</code></pre>
</div>
</div>
<p><em>Note</em>: The dataset is actually composed of 4 files with the extensions .dbf, .prj, .shp and .shx, but it is sufficient to write the name of the .shp file in <code>read_sf</code>.</p>
<p>The columns of the dataset are, in order:</p>
<ul>
<li>the name of the electoral riding (<code>circ</code>);</li>
<li>four characteristics of the population (<code>age_moy</code> = mean age, <code>pct_frn</code> = fraction of the population that speaks mainly French at home, <code>pct_prp</code> = fraction of households that own their home, <code>rev_med</code> = median income);</li>
<li>four columns showing the fraction of votes obtained by the main parties (CAQ, PQ, PLQ, QS);</li>
<li>a <code>geometry</code> column that contains the geometric object (multipolygon) corresponding to the riding.</li>
</ul>
<p>To illustrate one of the variables on a map, we call the <code>plot</code> function with the name of the column in square brackets and quotation marks.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-54_b911c1230b37d88999c315735187b9c4">
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(elect2018[<span class="st">"rev_med"</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-54-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>In this example, we want to model the fraction of votes obtained by the CAQ based on the characteristics of the population in each riding and taking into account the spatial correlations between neighbouring ridings.</p>
<section id="definition-of-the-neighbourhood-network" class="level2">
<h2 class="anchored" data-anchor-id="definition-of-the-neighbourhood-network">Definition of the neighbourhood network</h2>
<p>The <code>poly2nb</code> function of the <em>spdep</em> package defines a neighbourhood network from polygons. The result <code>vois</code> is a list of 125 elements where each element contains the indices of the neighbouring (bordering) polygons of a given polygon.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-55_98b699432f680855147ba1bd583f3497">
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>vois <span class="ot">&lt;-</span> <span class="fu">poly2nb</span>(elect2018)</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>vois[[<span class="dv">1</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1]   2  37  63  88 101 117</code></pre>
</div>
</div>
<p>Thus, the first riding (Abitibi-Est) has 6 neighbouring ridings, for which the names can be found as follows:</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-56_1fa15a9556e3ec5f51ffe127e1e42830">
<div class="sourceCode cell-code" id="cb84"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>elect2018<span class="sc">$</span>circ[vois[[<span class="dv">1</span>]]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Abitibi-Ouest"               "Gatineau"                   
[3] "Laviolette-Saint-Maurice"    "Pontiac"                    
[5] "Rouyn-Noranda-Témiscamingue" "Ungava"                     </code></pre>
</div>
</div>
<p>We can illustrate this network by extracting the coordinates of the center of each district, creating a blank map with <code>plot(elect2018["geometry"])</code>, then adding the network as an additional layer with <code>plot(vois, add = TRUE, coords = coords)</code>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-57_f0d7bd96b26b0a6cd39daec9f4aad58b">
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>coords <span class="ot">&lt;-</span> <span class="fu">st_centroid</span>(elect2018) <span class="sc">%&gt;%</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">st_coordinates</span>()</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(elect2018[<span class="st">"geometry"</span>])</span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(vois, <span class="at">add =</span> <span class="cn">TRUE</span>, <span class="at">col =</span> <span class="st">"red"</span>, <span class="at">coords =</span> coords)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-57-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>We can “zoom” on southern Québec by choosing the limits <code>xlim</code> and <code>ylim</code>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-58_1fa7ea9cbb36326317c26af33b739d1c">
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(elect2018[<span class="st">"geometry"</span>], </span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlim =</span> <span class="fu">c</span>(<span class="dv">400000</span>, <span class="dv">800000</span>), <span class="at">ylim =</span> <span class="fu">c</span>(<span class="dv">100000</span>, <span class="dv">500000</span>))</span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(vois, <span class="at">add =</span> <span class="cn">TRUE</span>, <span class="at">col =</span> <span class="st">"red"</span>, <span class="at">coords =</span> coords)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-58-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>We still have to add weights to each network link with the <code>nb2listw</code> function. The style of weights “B” corresponds to binary weights, i.e.&nbsp;1 for the presence of link and 0 for the absence of link between two ridings.</p>
<p>Once these weights are defined, we can verify with Moran’s test whether there is a significant autocorrelation of votes obtained by the CAQ between neighbouring ridings.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-59_94da4f87bfc6fa6486cce26e9c1ed239">
<div class="sourceCode cell-code" id="cb88"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>poids <span class="ot">&lt;-</span> <span class="fu">nb2listw</span>(vois, <span class="at">style =</span> <span class="st">"B"</span>)</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a><span class="fu">moran.test</span>(elect2018<span class="sc">$</span>propCAQ, poids)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Moran I test under randomisation

data:  elect2018$propCAQ  
weights: poids    

Moran I statistic standard deviate = 13.148, p-value &lt; 2.2e-16
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
      0.680607768      -0.008064516       0.002743472 </code></pre>
</div>
</div>
<p>The value <span class="math inline">\(I = 0.68\)</span> is very significant judging by the <span class="math inline">\(p\)</span>-value of the test.</p>
<p>Let’s verify if the spatial correlation persists after taking into account the four characteristics of the population, therefore by inspecting the residuals of a linear model including these four predictors.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-60_48eb067e5cfdccfc3e81ace94767cddc">
<div class="sourceCode cell-code" id="cb90"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>elect_lm <span class="ot">&lt;-</span> <span class="fu">lm</span>(propCAQ <span class="sc">~</span> age_moy <span class="sc">+</span> pct_frn <span class="sc">+</span> pct_prp <span class="sc">+</span> rev_med, <span class="at">data =</span> elect2018)</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(elect_lm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = propCAQ ~ age_moy + pct_frn + pct_prp + rev_med, 
    data = elect2018)

Residuals:
     Min       1Q   Median       3Q      Max 
-30.9890  -4.4878   0.0562   6.2653  25.8146 

Coefficients:
              Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)  1.354e+01  1.836e+01   0.737    0.463    
age_moy     -9.170e-01  3.855e-01  -2.378    0.019 *  
pct_frn      4.588e+01  5.202e+00   8.820 1.09e-14 ***
pct_prp      3.582e+01  6.527e+00   5.488 2.31e-07 ***
rev_med     -2.624e-05  2.465e-04  -0.106    0.915    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 9.409 on 120 degrees of freedom
Multiple R-squared:  0.6096,    Adjusted R-squared:  0.5965 
F-statistic: 46.84 on 4 and 120 DF,  p-value: &lt; 2.2e-16</code></pre>
</div>
<div class="sourceCode cell-code" id="cb92"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="fu">moran.test</span>(<span class="fu">residuals</span>(elect_lm), poids)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Moran I test under randomisation

data:  residuals(elect_lm)  
weights: poids    

Moran I statistic standard deviate = 6.7047, p-value = 1.009e-11
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
      0.340083290      -0.008064516       0.002696300 </code></pre>
</div>
</div>
<p>Moran’s <span class="math inline">\(I\)</span> has decreased but remains significant, so some of the previous correlation was induced by these predictors, but there remains a spatial correlation due to other factors.</p>
</section>
<section id="spatial-autoregression-models" class="level2">
<h2 class="anchored" data-anchor-id="spatial-autoregression-models">Spatial autoregression models</h2>
<p>Finally, we fit SAR and CAR models to these data with the <code>spautolm</code> (<em>spatial autoregressive linear model</em>) function of <em>spatialreg</em>. Here is the code for a SAR model including the effect of the same four predictors.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-61_13bb8dc5c63cce02c362b41c905f9de5">
<div class="sourceCode cell-code" id="cb94"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>elect_sar <span class="ot">&lt;-</span> <span class="fu">spautolm</span>(propCAQ <span class="sc">~</span> age_moy <span class="sc">+</span> pct_frn <span class="sc">+</span> pct_prp <span class="sc">+</span> rev_med, </span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>                      <span class="at">data =</span> elect2018, <span class="at">listw =</span> poids)</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(elect_sar)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call: spautolm(formula = propCAQ ~ age_moy + pct_frn + pct_prp + rev_med, 
    data = elect2018, listw = poids)

Residuals:
      Min        1Q    Median        3Q       Max 
-23.08342  -4.10573   0.24274   4.29941  23.08245 

Coefficients: 
               Estimate  Std. Error z value  Pr(&gt;|z|)
(Intercept) 15.09421119 16.52357745  0.9135   0.36098
age_moy     -0.70481703  0.32204139 -2.1886   0.02863
pct_frn     39.09375061  5.43653962  7.1909 6.435e-13
pct_prp     14.32329345  6.96492611  2.0565   0.03974
rev_med      0.00016730  0.00023209  0.7208   0.47101

Lambda: 0.12887 LR test value: 42.274 p-value: 7.9339e-11 
Numerical Hessian standard error of lambda: 0.012069 

Log likelihood: -433.8862 
ML residual variance (sigma squared): 53.028, (sigma: 7.282)
Number of observations: 125 
Number of parameters estimated: 7 
AIC: 881.77</code></pre>
</div>
</div>
<p>The value given by <code>Lambda</code> in the summary corresponds to the coefficient <span class="math inline">\(\rho\)</span> in our description of the model. The likelihood-ratio test (<code>LR test</code>) confirms that this residual spatial correlation (after controlling for the effect of predictors) is significant.</p>
<p>The estimated effects for the predictors are similar to those of the linear model without spatial correlation. The effects of mean age, fraction of francophones and fraction of homeowners remain significant, although their magnitude has decreased somewhat.</p>
<p>To fit a CAR rather than SAR model, we must specify <code>family = "CAR"</code>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-62_29349c4a3573934d0da78be8a806d927">
<div class="sourceCode cell-code" id="cb96"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>elect_car <span class="ot">&lt;-</span> <span class="fu">spautolm</span>(propCAQ <span class="sc">~</span> age_moy <span class="sc">+</span> pct_frn <span class="sc">+</span> pct_prp <span class="sc">+</span> rev_med, </span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>                      <span class="at">data =</span> elect2018, <span class="at">listw =</span> poids, <span class="at">family =</span> <span class="st">"CAR"</span>)</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(elect_car)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call: spautolm(formula = propCAQ ~ age_moy + pct_frn + pct_prp + rev_med, 
    data = elect2018, listw = poids, family = "CAR")

Residuals:
      Min        1Q    Median        3Q       Max 
-21.73315  -4.24623  -0.24369   3.44228  23.43749 

Coefficients: 
               Estimate  Std. Error z value  Pr(&gt;|z|)
(Intercept) 16.57164696 16.84155327  0.9840  0.325128
age_moy     -0.79072151  0.32972225 -2.3981  0.016478
pct_frn     38.99116707  5.43667482  7.1719 7.399e-13
pct_prp     17.98557474  6.80333470  2.6436  0.008202
rev_med      0.00012639  0.00023106  0.5470  0.584364

Lambda: 0.15517 LR test value: 40.532 p-value: 1.9344e-10 
Numerical Hessian standard error of lambda: 0.0026868 

Log likelihood: -434.7573 
ML residual variance (sigma squared): 53.9, (sigma: 7.3416)
Number of observations: 125 
Number of parameters estimated: 7 
AIC: 883.51</code></pre>
</div>
</div>
<p>For a CAR model with binary weights, the value of <code>Lambda</code> (which we called <span class="math inline">\(\rho\)</span>) directly gives the partial correlation coefficient between neighbouring districts. Note that the AIC here is slightly higher than the SAR model, so the latter gave a better fit.</p>
</section>
<section id="exercise-3" class="level2">
<h2 class="anchored" data-anchor-id="exercise-3">Exercise</h2>
<p>The <code>rls_covid</code> dataset, in <em>shapefile</em> format, contains data on detected COVID-19 cases (<code>cas</code>), number of cases per 1000 people (<code>taux_1k</code>) and the population density (<code>dens_pop</code>) in each of Quebec’s local health service networks (RLS) (Source: Data downloaded from the Institut national de santé publique du Québec as of January 17, 2021).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-63_93fde0bc2a6d31114d1cad8dee5f0aa1">
<div class="sourceCode cell-code" id="cb98"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>rls_covid <span class="ot">&lt;-</span> <span class="fu">read_sf</span>(<span class="st">"data/rls_covid.shp"</span>)</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(rls_covid)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Simple feature collection with 6 features and 5 fields
Geometry type: MULTIPOLYGON
Dimension:     XY
Bounding box:  xmin: 785111.2 ymin: 341057.8 xmax: 979941.5 ymax: 541112.7
Projected CRS: Conique_conforme_de_Lambert_du_MTQ_utilis_e_pour_Adresse_Qu_be
# A tibble: 6 × 6
  RLS_code RLS_nom                 cas taux_1k dens_…¹                  geometry
  &lt;chr&gt;    &lt;chr&gt;                 &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;        &lt;MULTIPOLYGON [m]&gt;
1 0111     RLS de Kamouraska       152    7.34    6.76 (((827028.3 412772.4, 82…
2 0112     RLS de Rivière-du-Lo…   256    7.34   19.6  (((855905 452116.9, 8557…
3 0113     RLS de Témiscouata       81    4.26    4.69 (((911829.4 441311.2, 91…
4 0114     RLS des Basques          28    3.3     5.35 (((879249.6 471975.6, 87…
5 0115     RLS de Rimouski         576    9.96   15.5  (((917748.1 503148.7, 91…
6 0116     RLS de La Mitis          76    4.24    5.53 (((951316 523499.3, 9525…
# … with abbreviated variable name ¹​dens_pop</code></pre>
</div>
</div>
<p>Fit a linear model of the number of cases per 1000 as a function of population density (it is suggested to apply a logarithmic transform to the latter). Check whether the model residuals are correlated between bordering RLS with a Moran’s test and then model the same data with a conditional autoregressive model.</p>
</section>
<section id="reference" class="level2">
<h2 class="anchored" data-anchor-id="reference">Reference</h2>
<p>Ver Hoef, J.M., Peterson, E.E., Hooten, M.B., Hanks, E.M. and Fortin, M.-J. (2018) Spatial autoregressive models for statistical inference from ecological data. <em>Ecological Monographs</em> 88: 36-59.</p>
</section>
</section>
<section id="glmm-spatial-gaussian" class="level1" data-number="14">
<h1 data-number="14"><span class="header-section-number">14</span> GLMM with spatial Gaussian process</h1>
<section id="data" class="level2">
<h2 class="anchored" data-anchor-id="data">Data</h2>
<p>The <code>gambia</code> dataset found in the <em>geoR</em> package presents the results of a study of malaria prevalence among children of 65 villages in The Gambia. We will use a slightly transformed version of the data found in the file <a href="data/gambia.csv">gambia.csv</a>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-64_c90dcebc741300cf593af262129c15ab">
<div class="sourceCode cell-code" id="cb100"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(geoR)</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a>gambia <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">"data/gambia.csv"</span>)</span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(gambia)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  id_village        x        y pos  age netuse treated green phc
1          1 349.6313 1458.055   1 1783      0       0 40.85   1
2          1 349.6313 1458.055   0  404      1       0 40.85   1
3          1 349.6313 1458.055   0  452      1       0 40.85   1
4          1 349.6313 1458.055   1  566      1       0 40.85   1
5          1 349.6313 1458.055   0  598      1       0 40.85   1
6          1 349.6313 1458.055   1  590      1       0 40.85   1</code></pre>
</div>
</div>
<p>Here are the fields in that dataset:</p>
<ul>
<li><em>id_village</em>: Identifier of the village.</li>
<li><em>x</em> and <em>y</em>: Spatial coordinates of the village (in kilometers, based on UTM coordinates).</li>
<li><em>pos</em>: Binary response, whether the child tested positive for malaria.</li>
<li><em>age</em>: Age of the child in days.</li>
<li><em>netuse</em>: Whether or not the child sleeps under a bed net.</li>
<li><em>treated</em>: Whether or not the bed net is treated.</li>
<li><em>green</em>: Remote sensing based measure of greenness of vegetation (measured at the village level).</li>
<li><em>phc</em>: Presence or absence of a public health centre for the village.</li>
</ul>
<p>We can count the number of positive cases and total children tested by village to map the fraction of positive cases (or prevalence, <em>prev</em>).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-65_8c814c1bf1c630ff765172316c6e438a">
<div class="sourceCode cell-code" id="cb102"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create village-level dataset</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>gambia_agg <span class="ot">&lt;-</span> <span class="fu">group_by</span>(gambia, id_village, x, y, green, phc) <span class="sc">%&gt;%</span></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">summarize</span>(<span class="at">pos =</span> <span class="fu">sum</span>(pos), <span class="at">total =</span> <span class="fu">n</span>()) <span class="sc">%&gt;%</span></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mutate</span>(<span class="at">prev =</span> pos <span class="sc">/</span> total) <span class="sc">%&gt;%</span></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ungroup</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>`summarise()` has grouped output by 'id_village', 'x', 'y', 'green'. You can
override using the `.groups` argument.</code></pre>
</div>
<div class="sourceCode cell-code" id="cb104"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(gambia_agg)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 6 × 8
  id_village     x     y green   phc   pos total  prev
       &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;
1          1  350. 1458.  40.8     1    17    33 0.515
2          2  359. 1460.  40.8     1    19    63 0.302
3          3  360. 1460.  40.1     0     7    17 0.412
4          4  364. 1497.  40.8     0     8    24 0.333
5          5  366. 1460.  40.8     0    10    26 0.385
6          6  367. 1463.  40.8     0     7    18 0.389</code></pre>
</div>
</div>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-66_ae2eb69bc71b443b86ab8b607284711a">
<div class="sourceCode cell-code" id="cb106"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(gambia_agg, <span class="fu">aes</span>(<span class="at">x =</span> x, <span class="at">y =</span> y)) <span class="sc">+</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">color =</span> prev)) <span class="sc">+</span></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_path</span>(<span class="at">data =</span> gambia.borders, <span class="fu">aes</span>(<span class="at">x =</span> x <span class="sc">/</span> <span class="dv">1000</span>, <span class="at">y =</span> y <span class="sc">/</span> <span class="dv">1000</span>)) <span class="sc">+</span></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">coord_fixed</span>() <span class="sc">+</span></span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">scale_color_viridis_c</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-66-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>We use the <code>gambia.borders</code> dataset from the <em>geoR</em> package to trace the country boundaries with <code>geom_path</code>. Since those boundaries are in meters, we divide by 1000 to get the same scale as our points. We also use <code>coord_fixed</code> to ensure a 1:1 aspect ratio between the axes and use the <code>viridis</code> color scale, which makes it easier to visualize a continuous variable compared with the default gradient scale in <em>ggplot2</em>.</p>
<p>Based on this map, there seems to be spatial correlation in malaria prevalence, with the eastern cluster of villages showing more high prevalence values (yellow-green) and the middle cluster showing more low prevalence values (purple).</p>
</section>
<section id="non-spatial-glmm" class="level2">
<h2 class="anchored" data-anchor-id="non-spatial-glmm">Non-spatial GLMM</h2>
<p>For this first example, we will ignore the spatial aspect of the data and model the presence of malaria (<em>pos</em>) as a function of the use of a bed net (<em>netuse</em>) and the presence of a public health centre (<em>phc</em>). Since we have a binary response, we need to use a logistic regression model (a GLM). Since we have predictors at both the individual and village level, and we expect that children of the same village have more similar probabilities of having malaria even after accounting for those predictors, we need to add a random effect of the village. The result is a GLMM that we fit using the <code>glmer</code> function in the <em>lme4</em> package.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-67_5c5fd662cb4ced05e844aabdfdb7a676">
<div class="sourceCode cell-code" id="cb107"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(lme4)</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>mod_glmm <span class="ot">&lt;-</span> <span class="fu">glmer</span>(pos <span class="sc">~</span> netuse <span class="sc">+</span> phc <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> id_village), </span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a>                  <span class="at">data =</span> gambia, <span class="at">family =</span> binomial)</span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(mod_glmm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Generalized linear mixed model fit by maximum likelihood (Laplace
  Approximation) [glmerMod]
 Family: binomial  ( logit )
Formula: pos ~ netuse + phc + (1 | id_village)
   Data: gambia

     AIC      BIC   logLik deviance df.resid 
  2428.0   2450.5  -1210.0   2420.0     2031 

Scaled residuals: 
    Min      1Q  Median      3Q     Max 
-2.1286 -0.7120 -0.4142  0.8474  3.3434 

Random effects:
 Groups     Name        Variance Std.Dev.
 id_village (Intercept) 0.8149   0.9027  
Number of obs: 2035, groups:  id_village, 65

Fixed effects:
            Estimate Std. Error z value Pr(&gt;|z|)    
(Intercept)   0.1491     0.2297   0.649   0.5164    
netuse       -0.6044     0.1442  -4.190 2.79e-05 ***
phc          -0.4985     0.2604  -1.914   0.0556 .  
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Correlation of Fixed Effects:
       (Intr) netuse
netuse -0.422       
phc    -0.715 -0.025</code></pre>
</div>
</div>
<p>According to these results, both <em>netuse</em> and <em>phc</em> result in a decrease of malaria prevalence, although the effect of <em>phc</em> is not significant at a threshold <span class="math inline">\(\alpha = 0.05\)</span>. The intercept (0.149) is the logit of the probability of malaria presence for a child with no bednet and no public health centre, but it is the mean intercept across all villages, and there is a lot of variation between villages, based on the random effect standard deviation of 0.90. We can get the estimated intercept for each village with the function <code>coef</code>:</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-68_3720c229ebd5b2262ea78c97fa323bc0">
<div class="sourceCode cell-code" id="cb109"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(<span class="fu">coef</span>(mod_glmm)<span class="sc">$</span>id_village)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  (Intercept)     netuse        phc
1  0.93727515 -0.6043602 -0.4984835
2  0.09204843 -0.6043602 -0.4984835
3  0.22500620 -0.6043602 -0.4984835
4 -0.46271089 -0.6043602 -0.4984835
5  0.13680037 -0.6043602 -0.4984835
6 -0.03723346 -0.6043602 -0.4984835</code></pre>
</div>
</div>
<p>So for example, the intercept for village 1 is around 0.94, equivalent to a probability of 72%:</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-69_5db6d43ef9ff435eae9aedd3aebe48f9">
<div class="sourceCode cell-code" id="cb111"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plogis</span>(<span class="fl">0.937</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.7184933</code></pre>
</div>
</div>
<p>while the intercept in village 2 is equivalent to a probability of 52%:</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-70_8c98817d65db7e2319175c4f3cba494c">
<div class="sourceCode cell-code" id="cb113"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plogis</span>(<span class="fl">0.092</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.5229838</code></pre>
</div>
</div>
<p>The <a href="https://cran.r-project.org/web/packages/DHARMa/vignettes/DHARMa.html">DHARMa package</a> provides a general method for checking whether the residuals of a GLMM are distributed according to the specified model and whether there is any residual trend. The package works by simulating replicates of each observation according to the fitted model and then determining a “standardized residual”, which is the relative position of the observed value with respect to the simulated values, e.g.&nbsp;0 if the observation is smaller than all the simulations, 0.5 if it is in the middle, etc. If the model represents the data well, each value of the standardized residual between 0 and 1 should be equally likely, so the standardized residuals should produce a uniform distribution between 0 and 1.</p>
<p>The <code>simulateResiduals</code> function performs the calculation of the standardized residuals, then the <code>plot</code> function plots the diagnostic graphs with the results of certain tests.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-71_7045ff49e2f9776387a59c78b53a1341">
<div class="sourceCode cell-code" id="cb115"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(DHARMa)</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>res_glmm <span class="ot">&lt;-</span> <span class="fu">simulateResiduals</span>(mod_glmm)</span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(res_glmm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-71-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The graph on the left is a quantile-quantile plot of standardized residuals. The results of three statistical tests also also shown: a Kolmogorov-Smirnov (<em>KS</em>) test which checks whether there is a deviation from the theoretical distribution, a dispersion test that checks whether there is underdispersion or overdispersion, and an outlier test based on the number of residuals that are more extreme than all the simulations. Here, we get a significant result for the outliers, though the message indicates that this result might have an inflated type I error rate in this case.</p>
<p>On the right, we generally get a graph of standardized residuals (in <em>y</em>) as a function of the rank of the predicted values, in order to check for any leftover trend in the residual. Here, the predictions are binned by quartile, so it might be better to instead aggregate the predictions and residuals by village, which we can do with the <code>recalculateResiduals</code> function.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-72_65a9d2bb93c9d14f4d7fcc7b40b03c87">
<div class="sourceCode cell-code" id="cb116"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">recalculateResiduals</span>(res_glmm, <span class="at">group =</span> gambia<span class="sc">$</span>id_village))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>DHARMa:testOutliers with type = binomial may have inflated Type I error rates for integer-valued distributions. To get a more exact result, it is recommended to re-run testOutliers with type = 'bootstrap'. See ?testOutliers for details</code></pre>
</div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-72-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The plot to the right now shows individual points, along with a quantile regression for the 1st quartile, the median and the 3rd quartile. In theory, these three curves should be horizontal straight lines (no leftover trend in the residuals vs.&nbsp;predictions). The curve for the 3rd quartile (in red) is significantly different from a horizontal line, which could indicate some systematic effect that is missing from the model.</p>
</section>
<section id="spatial-glmm-with-spamm" class="level2">
<h2 class="anchored" data-anchor-id="spatial-glmm-with-spamm">Spatial GLMM with spaMM</h2>
<p>The <em>spaMM</em> (spatial mixed models) package is a relatively new R package that can perform approximate maximum likelihood estimation of parameters for GLMM with spatial dependence, modelled either as a Gaussian process or with a CAR (we will see the latter in the last section). The package implements different algorithms, but there is a single <code>fitme</code> function that chooses the appropriate algorithm for each model type. For example, here is the same (non-spatial) model as above fit with <em>spaMM</em>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-73_4095dfb1a2890efd12578324ce9cfb41">
<div class="sourceCode cell-code" id="cb118"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(spaMM)</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>mod_spamm_glmm <span class="ot">&lt;-</span> <span class="fu">fitme</span>(pos <span class="sc">~</span> netuse <span class="sc">+</span> phc <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> id_village),</span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>                        <span class="at">data =</span> gambia, <span class="at">family =</span> binomial)</span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(mod_spamm_glmm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>formula: pos ~ netuse + phc + (1 | id_village)
Estimation of lambda by ML (p_v approximation of logL).
Estimation of fixed effects by ML (p_v approximation of logL).
family: binomial( link = logit ) 
 ------------ Fixed effects (beta) ------------
            Estimate Cond. SE t-value
(Intercept)   0.1491   0.2287  0.6519
netuse       -0.6045   0.1420 -4.2567
phc          -0.4986   0.2593 -1.9231
 --------------- Random effects ---------------
Family: gaussian( link = identity ) 
           --- Variance parameters ('lambda'):
lambda = var(u) for u ~ Gaussian; 
   id_village  :  0.8151  
             --- Coefficients for log(lambda):
      Group        Term Estimate Cond.SE
 id_village (Intercept)  -0.2045  0.2008
# of obs: 2035; # of groups: id_village, 65 
 ------------- Likelihood values  -------------
                        logLik
logL       (p_v(h)): -1210.016</code></pre>
</div>
</div>
<p>Note that the estimates of the fixed effects as well as the variance of random effects are nearly identical to those obtained by <code>glmer</code> above.</p>
<p>We can now use <em>spaMM</em> to fit the same model with the addition of spatial correlations between villages. In the formula of the model, this is represented as a random effect <code>Matern(1 | x + y)</code>, which means that the intercepts are spatially correlated between villages following a Matérn correlation function of coordinates (<em>x, y</em>). The Matérn function is a flexible function for spatial correlation that includes a shape parameter <span class="math inline">\(\nu\)</span> (<code>nu</code>), so that when <span class="math inline">\(\nu = 0.5\)</span> it is equivalent to the exponential correlation but as <span class="math inline">\(\nu\)</span> grows to large values, it approaches a Gaussian correlation. We could let the function estimate <span class="math inline">\(\nu\)</span>, but here we will fix it to 0.5 with the <code>fixed</code> argument of <code>fitme</code>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-74_d3aef70cffd85f41f037e30922c132c2">
<div class="sourceCode cell-code" id="cb120"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a>mod_spamm <span class="ot">&lt;-</span> <span class="fu">fitme</span>(pos <span class="sc">~</span> netuse <span class="sc">+</span> phc <span class="sc">+</span> <span class="fu">Matern</span>(<span class="dv">1</span> <span class="sc">|</span> x <span class="sc">+</span> y) <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> id_village),</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>                   <span class="at">data =</span> gambia, <span class="at">family =</span> binomial, <span class="at">fixed =</span> <span class="fu">list</span>(<span class="at">nu =</span> <span class="fl">0.5</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Increase spaMM.options(separation_max=&lt;.&gt;) to at least 21 if you want to check separation (see 'help(separation)').</code></pre>
</div>
<div class="sourceCode cell-code" id="cb122"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(mod_spamm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>formula: pos ~ netuse + phc + Matern(1 | x + y) + (1 | id_village)
Estimation of corrPars and lambda by ML (p_v approximation of logL).
Estimation of fixed effects by ML (p_v approximation of logL).
Estimation of lambda by 'outer' ML, maximizing logL.
family: binomial( link = logit ) 
 ------------ Fixed effects (beta) ------------
            Estimate Cond. SE t-value
(Intercept)  0.06861   0.3352  0.2047
netuse      -0.51719   0.1407 -3.6757
phc         -0.44416   0.2052 -2.1648
 --------------- Random effects ---------------
Family: gaussian( link = identity ) 
                   --- Correlation parameters:
      1.nu      1.rho 
0.50000000 0.05128692 
           --- Variance parameters ('lambda'):
lambda = var(u) for u ~ Gaussian; 
   x + y  :  0.6421 
   id_village  :  0.1978  
# of obs: 2035; # of groups: x + y, 65; id_village, 65 
 ------------- Likelihood values  -------------
                        logLik
logL       (p_v(h)): -1197.968</code></pre>
</div>
</div>
<p>Let’s first check the random effects of the model. The spatial correlation function has a parameter <code>rho</code> equal to 0.0513. This parameter in <em>spaMM</em> is the inverse of the range, so here the range of exponential correlation is 1/0.0513 or around 19.5 km. There are now two variance prameters, the one identified as <code>x + y</code> is the long-range variance (i.e.&nbsp;sill) for the exponential correlation model whereas the one identified as <code>id_village</code> shows the non-spatially correlated portion of the variation between villages.</p>
<p>In fact, while we left the random effects <code>(1 | id_village)</code> in the formula to represent the non-spatial portion of variation between villages, we could also represent this with a nugget effect in the geostatistical model. In both cases, it would represent the idea that even two villages very close to each other would have different baseline prevalences in the model.</p>
<p>By default, the <code>Matern</code> function has no nugget effect, but we can add one by specifying a non-zero <code>Nugget</code> in the initial parameter list <code>init</code>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-75_dbd5d25ae78a3c934126be892144af99">
<div class="sourceCode cell-code" id="cb124"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a>mod_spamm2 <span class="ot">&lt;-</span> <span class="fu">fitme</span>(pos <span class="sc">~</span> netuse <span class="sc">+</span> phc <span class="sc">+</span> <span class="fu">Matern</span>(<span class="dv">1</span> <span class="sc">|</span> x <span class="sc">+</span> y),</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>                    <span class="at">data =</span> gambia, <span class="at">family =</span> binomial, <span class="at">fixed =</span> <span class="fu">list</span>(<span class="at">nu =</span> <span class="fl">0.5</span>),</span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a>                    <span class="at">init =</span> <span class="fu">list</span>(<span class="at">Nugget =</span> <span class="fl">0.1</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Increase spaMM.options(separation_max=&lt;.&gt;) to at least 21 if you want to check separation (see 'help(separation)').</code></pre>
</div>
<div class="sourceCode cell-code" id="cb126"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(mod_spamm2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>formula: pos ~ netuse + phc + Matern(1 | x + y)
Estimation of corrPars and lambda by ML (p_v approximation of logL).
Estimation of fixed effects by ML (p_v approximation of logL).
Estimation of lambda by 'outer' ML, maximizing logL.
family: binomial( link = logit ) 
 ------------ Fixed effects (beta) ------------
            Estimate Cond. SE t-value
(Intercept)  0.06861   0.3352  0.2047
netuse      -0.51719   0.1407 -3.6757
phc         -0.44416   0.2052 -2.1648
 --------------- Random effects ---------------
Family: gaussian( link = identity ) 
                   --- Correlation parameters:
      1.nu   1.Nugget      1.rho 
0.50000000 0.23551027 0.05128692 
           --- Variance parameters ('lambda'):
lambda = var(u) for u ~ Gaussian; 
   x + y  :  0.8399  
# of obs: 2035; # of groups: x + y, 65 
 ------------- Likelihood values  -------------
                        logLik
logL       (p_v(h)): -1197.968</code></pre>
</div>
</div>
<p>As you can see, all estimates are the same, except that the variance of the spatial portion (sill) is now 0.84 and the nugget is equal to a fraction 0.235 of that sill, so a variance of 0.197, which is the same as the <code>id_village</code> random effect in the version above. Thus the two formulations are equivalent.</p>
<p>Now, recall the coefficients we obtained for the non-spatial GLMM:</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-76_2ff7323dca01a1d9207ef38489d6b664">
<div class="sourceCode cell-code" id="cb128"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(mod_glmm)<span class="sc">$</span>coefficients</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>              Estimate Std. Error    z value     Pr(&gt;|z|)
(Intercept)  0.1490596  0.2296971  0.6489399 5.163772e-01
netuse      -0.6043602  0.1442448 -4.1898243 2.791706e-05
phc         -0.4984835  0.2604083 -1.9142382 5.558973e-02</code></pre>
</div>
</div>
<p>In the spatial version, both fixed effects have moved slightly towards zero, but the standard error of the effect of <code>phc</code> has decreased. It is interesting that the inclusion of spatial dependence has allowed us to estimate more precisely the effect of having a public health centre in the village. This would not always be the case: for a predictor that is also strongly correlated in space, spatial correlation in the response makes it harder to estimate the effect of this predictor, since it is confounded with the spatial effect. However, for a predictor that is not correlated in space, including the spatial effect reduces the residual (non-spatial) variance and may thus increase the precision of the predictor’s effect.</p>
<p>The <em>spaMM</em> package is also compatible with <em>DHARMa</em> for residual diagnostics. (You can in fact ignore the warning that it is not in the class of supported models, this is due to using the <code>fitme</code> function rather than a specific algorithm function in <em>spaMM</em>.)</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-77_435151fa87f7c6c10fa17fe4778779f0">
<div class="sourceCode cell-code" id="cb130"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a>res_spamm <span class="ot">&lt;-</span> <span class="fu">simulateResiduals</span>(mod_spamm2)</span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(res_spamm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>DHARMa:testOutliers with type = binomial may have inflated Type I error rates for integer-valued distributions. To get a more exact result, it is recommended to re-run testOutliers with type = 'bootstrap'. See ?testOutliers for details</code></pre>
</div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-77-1.png" class="img-fluid" width="672"></p>
</div>
<div class="sourceCode cell-code" id="cb132"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">recalculateResiduals</span>(res_spamm, <span class="at">group =</span> gambia<span class="sc">$</span>id_village))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>DHARMa:testOutliers with type = binomial may have inflated Type I error rates for integer-valued distributions. To get a more exact result, it is recommended to re-run testOutliers with type = 'bootstrap'. See ?testOutliers for details</code></pre>
</div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-77-2.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Finally, while we will show how to make and visualize spatial predictions below, we can produce a quick map of the estimated spatial effects in a <em>spaMM</em> model with the <code>filled.mapMM</code> function.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-78_9aa73f93f8884bdd0fab5e2e18929e73">
<div class="sourceCode cell-code" id="cb134"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="fu">filled.mapMM</span>(mod_spamm2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-78-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
<section id="gaussian-process-models-vs.-smoothing-splines" class="level2">
<h2 class="anchored" data-anchor-id="gaussian-process-models-vs.-smoothing-splines">Gaussian process models vs.&nbsp;smoothing splines</h2>
<p>If you are familiar with generalized additive models (GAM), you might think that the spatial variation in malaria prevalence (as shown in the map above) could be represented by a 2D smoothing spline (as a function of <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>) within a GAM.</p>
<p>The code below fits the GAM equivalent of our Gaussian process GLMM above with the <code>gam</code> function in the <em>mgcv</em> package. The spatial effect is represented by the 2D spline <code>s(x, y)</code> whereas the non-spatial random effect of village is represented by <code>s(id_village, bs = "re")</code>, which is the same as <code>(1 | id_village)</code> in the previous models. Note that for the <code>gam</code> function, categorical variables must be explicitly converted to factors.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-79_ae40737239f2e38abf88e2861e3870b5">
<div class="sourceCode cell-code" id="cb135"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mgcv)</span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a>gambia<span class="sc">$</span>id_village <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(gambia<span class="sc">$</span>id_village)</span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a>mod_gam <span class="ot">&lt;-</span> <span class="fu">gam</span>(pos <span class="sc">~</span> netuse <span class="sc">+</span> phc <span class="sc">+</span> <span class="fu">s</span>(id_village, <span class="at">bs =</span> <span class="st">"re"</span>) <span class="sc">+</span> <span class="fu">s</span>(x, y), </span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a>               <span class="at">data =</span> gambia, <span class="at">family =</span> binomial)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>To visualize the 2D spline, we will use the <a href="https://fromthebottomoftheheap.net/2018/10/23/introducing-gratia/"><em>gratia</em> package</a>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-80_d5c74c6f14896719f6bab59691ffa563">
<div class="sourceCode cell-code" id="cb136"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(gratia)</span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a><span class="fu">draw</span>(mod_gam)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-80-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Note that the plot of the spline <code>s(x, y)</code> (top right) does not extend too far from the locations of the data (other areas are blank). In this graph, we can also see that the village random effects follow the expected Gaussian distribution (top left).</p>
<p>Next, we will use both the spatial GLMM from the previous section and this GAMM to predict the mean prevalence on a spatial grid of points contained in the file <a href="data/gambia_pred.csv">gambia_pred.csv</a>. The graph below adds those prediction points (in black) on the previous map of the data points.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-81_29ad1d87f053e7c4195d592da7d54ff1">
<div class="sourceCode cell-code" id="cb137"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a>gambia_pred <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">"data/gambia_pred.csv"</span>)</span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(gambia_agg, <span class="fu">aes</span>(<span class="at">x =</span> x, <span class="at">y =</span> y)) <span class="sc">+</span></span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>(<span class="at">data =</span> gambia_pred) <span class="sc">+</span></span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">color =</span> prev)) <span class="sc">+</span></span>
<span id="cb137-6"><a href="#cb137-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_path</span>(<span class="at">data =</span> gambia.borders, <span class="fu">aes</span>(<span class="at">x =</span> x <span class="sc">/</span> <span class="dv">1000</span>, <span class="at">y =</span> y <span class="sc">/</span> <span class="dv">1000</span>)) <span class="sc">+</span></span>
<span id="cb137-7"><a href="#cb137-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">coord_fixed</span>() <span class="sc">+</span></span>
<span id="cb137-8"><a href="#cb137-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb137-9"><a href="#cb137-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">scale_color_viridis_c</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-81-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>To make predictions from the GAMM model at those points, the code below goes through the following steps:</p>
<ul>
<li><p>All predictors in the model must be in the prediction data frame, so we add constant values of <em>netuse</em> and <em>phc</em> (both equal to 1) for all points. Thus, we will make predictions of malaria prevalence in the case where a net is used and a public health centre is present. We also add a constant <em>id_village</em>, although it will not be used in predictions (see below).</p></li>
<li><p>We call the <code>predict</code> function on the output of <code>gam</code> to produce predictions at the new data points (argument <code>newdata</code>), including standard errors (<code>se.fit = TRUE</code>) and excluding the village random effects, so the prediction is made for an “average village”. The resulting object <code>gam_pred</code> will have columns <code>fit</code> (mean prediction) and <code>se.fit</code> (standard error). Those predictions and standard errors are on the link (logit) scale.</p></li>
<li><p>We add the original prediction data frame to <code>gam_pred</code> with <code>cbind</code>.</p></li>
<li><p>We add columns for the mean prediction and 50% confidence interval boundaries (mean <span class="math inline">\(\pm\)</span> 0.674 standard error), converted from the logit scale to the probability scale with <code>plogis</code>. We choose a 50% interval since a 95% interval may be too wide here to contrast the different predictions on the map at the end of this section.</p></li>
</ul>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-82_a655e5eb759da0f74f34c89ed61d58a2">
<div class="sourceCode cell-code" id="cb138"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a>gambia_pred <span class="ot">&lt;-</span> <span class="fu">mutate</span>(gambia_pred, <span class="at">netuse =</span> <span class="dv">1</span>, <span class="at">phc =</span> <span class="dv">1</span>, <span class="at">id_village =</span> <span class="dv">1</span>)</span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a>gam_pred <span class="ot">&lt;-</span> <span class="fu">predict</span>(mod_gam, <span class="at">newdata =</span> gambia_pred, <span class="at">se.fit =</span> <span class="cn">TRUE</span>, </span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true" tabindex="-1"></a>                    <span class="at">exclude =</span> <span class="st">"s(id_village)"</span>)</span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true" tabindex="-1"></a>gam_pred <span class="ot">&lt;-</span> <span class="fu">cbind</span>(gambia_pred, <span class="fu">as.data.frame</span>(gam_pred))</span>
<span id="cb138-6"><a href="#cb138-6" aria-hidden="true" tabindex="-1"></a>gam_pred <span class="ot">&lt;-</span> <span class="fu">mutate</span>(gam_pred, <span class="at">pred =</span> <span class="fu">plogis</span>(fit), </span>
<span id="cb138-7"><a href="#cb138-7" aria-hidden="true" tabindex="-1"></a>                   <span class="at">lo =</span> <span class="fu">plogis</span>(fit <span class="sc">-</span> <span class="fl">0.674</span> <span class="sc">*</span> se.fit), <span class="co"># 50% CI</span></span>
<span id="cb138-8"><a href="#cb138-8" aria-hidden="true" tabindex="-1"></a>                   <span class="at">hi =</span> <span class="fu">plogis</span>(fit <span class="sc">+</span> <span class="fl">0.674</span> <span class="sc">*</span> se.fit))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><em>Note</em>: The reason we do not make predictions directly on the probability (response) scale is that the normal formula for confidence intervals applies more accurately on the logit scale. Adding a certain number of standard errors around the mean on the probability scale would lead to less accurate intervals and maybe even confidence intervals outside the possible range (0, 1) for a probability.</p>
<p>We apply the same strategy to make predictions from the <em>spaMM</em> spatial GLMM model. There are a few differences in the <code>predict</code> method compared with the GAMM case.</p>
<ul>
<li><p>The argument <code>binding = "fit"</code> means that mean predictions (<code>fit</code> column) will be attached to the prediction dataset and returned as <code>spamm_pred</code>.</p></li>
<li><p>The <code>variances = list(linPred = TRUE)</code> tells <code>predict</code> to calculate the variance of the linear predictor (so the square of the standard error). However, it appears as an attribute <code>predVar</code> in the output data frame rather than a <code>se.fit</code> column, so we move it to a column on the next line.</p></li>
</ul>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-83_8466cc239c165bb619c3ec38ce8db16a">
<div class="sourceCode cell-code" id="cb139"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a>spamm_pred <span class="ot">&lt;-</span> <span class="fu">predict</span>(mod_spamm, <span class="at">newdata =</span> gambia_pred, <span class="at">type =</span> <span class="st">"link"</span>,</span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a>                      <span class="at">binding =</span> <span class="st">"fit"</span>, <span class="at">variances =</span> <span class="fu">list</span>(<span class="at">linPred =</span> <span class="cn">TRUE</span>))</span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a>spamm_pred<span class="sc">$</span>se.fit <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(<span class="fu">attr</span>(spamm_pred, <span class="st">"predVar"</span>))</span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true" tabindex="-1"></a>spamm_pred <span class="ot">&lt;-</span> <span class="fu">mutate</span>(spamm_pred, <span class="at">pred =</span> <span class="fu">plogis</span>(fit), </span>
<span id="cb139-5"><a href="#cb139-5" aria-hidden="true" tabindex="-1"></a>                     <span class="at">lo =</span> <span class="fu">plogis</span>(fit <span class="sc">-</span> <span class="fl">0.674</span> <span class="sc">*</span> se.fit),</span>
<span id="cb139-6"><a href="#cb139-6" aria-hidden="true" tabindex="-1"></a>                     <span class="at">hi =</span> <span class="fu">plogis</span>(fit <span class="sc">+</span> <span class="fl">0.674</span> <span class="sc">*</span> se.fit))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Finally, we combine both sets of predictions as different rows of a <code>pred_all</code> dataset with <code>bind_rows</code>. The name of the dataset each prediction originates from (<code>gam</code> or <code>spamm</code>) will appear in the “model” column (argument <code>.id</code>). To simplify production of the next plot, we then use <code>pivot_longer</code> in the <em>tidyr</em> package to change the three columns “pred”, “lo” and “hi” to two columns, “stat” and “value” (<code>pred_tall</code> has thus three rows for every row in <code>pred_all</code>).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-84_7a8a967d3486a1ba90686ccd4eede914">
<div class="sourceCode cell-code" id="cb140"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a>pred_all <span class="ot">&lt;-</span> <span class="fu">bind_rows</span>(<span class="at">gam =</span> gam_pred, <span class="at">spamm =</span> spamm_pred, <span class="at">.id =</span> <span class="st">"model"</span>)</span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyr)</span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a>pred_tall <span class="ot">&lt;-</span> <span class="fu">pivot_longer</span>(pred_all, <span class="fu">c</span>(pred, lo, hi), <span class="at">names_to =</span> <span class="st">"stat"</span>,</span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true" tabindex="-1"></a>                          <span class="at">values_to =</span> <span class="st">"value"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Having done these steps, we can finally look at the prediction maps (mean, lower and upper bounds of the 50% confidence interval) with <code>ggplot</code>. The original data points are shown in red.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-85_31003401bd646a7f13b4009bc478ce83">
<div class="sourceCode cell-code" id="cb141"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(pred_tall, <span class="fu">aes</span>(<span class="at">x =</span> x, <span class="at">y =</span> y)) <span class="sc">+</span></span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">color =</span> value)) <span class="sc">+</span></span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>(<span class="at">data =</span> gambia_agg, <span class="at">color =</span> <span class="st">"red"</span>, <span class="at">size =</span> <span class="dv">0</span>) <span class="sc">+</span></span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">coord_fixed</span>() <span class="sc">+</span></span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">facet_grid</span>(stat<span class="sc">~</span>model) <span class="sc">+</span></span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">scale_color_viridis_c</span>() <span class="sc">+</span></span>
<span id="cb141-7"><a href="#cb141-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_minimal</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-85-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>While both models agree that there is a higher prevalence near the eastern cluster of villages, the GAMM also estimates a higher prevalence at a few points (western edge and around the center) where there is no data. This is an artifact of the shape of the spline fit around the data points, since a spline is meant to fit a global, although nonlinear, trend. In contrast, the geostatistical model represents the spatial effect as local correlations and reverts to the overall mean prevalence when far from any data points, which is a safer assumption. This is one reason to choose a geostatistical / Gaussian process model in this case.</p>
</section>
<section id="bayesian-methods-for-glmms-with-gaussian-processes" class="level2">
<h2 class="anchored" data-anchor-id="bayesian-methods-for-glmms-with-gaussian-processes">Bayesian methods for GLMMs with Gaussian processes</h2>
<p>Bayesian models provide a flexible framework to express models with complex dependence structure among the data, including spatial dependence. However, fitting a Gaussian process model with a fully Bayesian approach can be slow, due the need to compute a spatial covariance matrix between all point pairs at each iteration.</p>
<p>The INLA (integrated nested Laplace approximation) method performs an approximate calculation of the Bayesian posterior distribution, which makes it suitable for spatial regression problems. We do not cover it in this course, but I recommend the textbook by Paula Moraga (in the references section below) that provides worked examples of using INLA for various geostatistical and areal data models, in the context of epidemiology, including models with both space and time dependence. The book presents the same Gambia malaria data as an example of a geostatistical dataset, which inspired its use in this course.</p>
</section>
</section>
<section id="glmm-spatial-autoreg" class="level1" data-number="15">
<h1 data-number="15"><span class="header-section-number">15</span> GLMM with spatial autoregression</h1>
<p>We return to the last example of the previous part, where we modelled the rate of COVID-19 cases (cases / 1000) for administrative health network divisions (RLS) in Quebec as a function of their population density. The rate is given by the “taux_1k” column in the <code>rls_covid</code> shapefile.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-86_dee7e0520a18d70a7e5f70f91e7f0d0a">
<div class="sourceCode cell-code" id="cb142"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(sf)</span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>rls_covid <span class="ot">&lt;-</span> <span class="fu">read_sf</span>(<span class="st">"data/rls_covid.shp"</span>)</span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a>rls_covid <span class="ot">&lt;-</span> rls_covid[<span class="sc">!</span><span class="fu">is.na</span>(rls_covid<span class="sc">$</span>dens_pop), ]</span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(rls_covid[<span class="st">"taux_1k"</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-86-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Previously, we modelled the logarithm of this rate as a linear function of the logarithm of population density, with the residual variance correlated among neighbouring units via a CAR (conditional autoregression) structure, as shown in the code below.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-87_51a48c9cba07b64df6887bc1c93140b3">
<div class="sourceCode cell-code" id="cb143"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(spdep)</span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(spatialreg)</span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-4"><a href="#cb143-4" aria-hidden="true" tabindex="-1"></a>rls_nb <span class="ot">&lt;-</span> <span class="fu">poly2nb</span>(rls_covid)</span>
<span id="cb143-5"><a href="#cb143-5" aria-hidden="true" tabindex="-1"></a>rls_w <span class="ot">&lt;-</span> <span class="fu">nb2listw</span>(rls_nb, <span class="at">style =</span> <span class="st">"B"</span>)</span>
<span id="cb143-6"><a href="#cb143-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-7"><a href="#cb143-7" aria-hidden="true" tabindex="-1"></a>car_lm <span class="ot">&lt;-</span> <span class="fu">spautolm</span>(<span class="fu">log</span>(taux_1k) <span class="sc">~</span> <span class="fu">log</span>(dens_pop), <span class="at">data =</span> rls_covid,</span>
<span id="cb143-8"><a href="#cb143-8" aria-hidden="true" tabindex="-1"></a>                   <span class="at">listw =</span> rls_w, <span class="at">family =</span> <span class="st">"CAR"</span>)</span>
<span id="cb143-9"><a href="#cb143-9" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(car_lm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call: spautolm(formula = log(taux_1k) ~ log(dens_pop), data = rls_covid, 
    listw = rls_w, family = "CAR")

Residuals:
      Min        1Q    Median        3Q       Max 
-1.201858 -0.254084 -0.053348  0.281482  1.427053 

Coefficients: 
              Estimate Std. Error z value  Pr(&gt;|z|)
(Intercept)   1.702068   0.168463 10.1035 &lt; 2.2e-16
log(dens_pop) 0.206623   0.032848  6.2903 3.169e-10

Lambda: 0.15762 LR test value: 23.991 p-value: 9.6771e-07 
Numerical Hessian standard error of lambda: 0.0050486 

Log likelihood: -80.68953 
ML residual variance (sigma squared): 0.2814, (sigma: 0.53048)
Number of observations: 95 
Number of parameters estimated: 4 
AIC: 169.38</code></pre>
</div>
</div>
<p>As a reminder, the <code>poly2nb</code> function in the <em>spdep</em> package creates a list of neighbours based on bordering polygons in a shapefile, then the <code>nb2listw</code> converts it to a list of weights, here binary weights (<code>style = "B"</code>) so that each bordering region receives the same weight of 1 in the autoregressive model.</p>
<p>Instead of using the rates, it would be possible to model the cases directly (column “cas” in the dataset) with a Poisson regression, which is appropriate for count data. To account for the fact that if the risk per person were equal, cases would be proportional to population, we can add the unit’s population <code>pop</code> as an <em>offset</em> in the Poisson regression. Therefore, the model would look like: <code>cas ~ log(dens_pop) + offset(log(pop))</code>. Note that since the Poisson regression uses a logarithmic link, that model with <code>log(pop)</code> as an offset assumes that <code>log(cas / pop)</code> (so the log rate) is proportional to <code>log(dens_pop)</code>, just like the linear model above, but it has the advantage of modelling the stochasticity of the raw data (the number of cases) directly with a Poisson distribution.</p>
<p>We do not have the population in this data, but we can estimate it from the cases and the rate (cases / 1000) as follows:</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-88_dd571339361d6d0f00653ec574a812b8">
<div class="sourceCode cell-code" id="cb145"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a>rls_covid<span class="sc">$</span>pop <span class="ot">&lt;-</span> rls_covid<span class="sc">$</span>cas <span class="sc">/</span> rls_covid<span class="sc">$</span>taux_1k <span class="sc">*</span> <span class="dv">1000</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>To define a CAR model in <em>spaMM</em>, we need a weights matrix rather than a list of weights as in the <em>spatialreg</em> package. Fortunately, the <em>spdep</em> package also includes a function <code>nb2mat</code> to convert the neighbours list to a matrix of weights, here again using binary weights. To avoid a warning, we specify the row and column names of that matrix to be equal to the IDs associated with each unit (<code>RLS_code</code>). Then, we add a term <code>adjacency(1 | RLS_code)</code> to the model to specify that the residual variation between different groups defined by <code>RLS_code</code> is spatially correlated with a CAR structure (here, each group has only one observation since we have one data point by RLS unit).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-89_96e9784ebad8d38cbd211f444a330b0c">
<div class="sourceCode cell-code" id="cb146"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(spaMM)</span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a>rls_mat <span class="ot">&lt;-</span> <span class="fu">nb2mat</span>(rls_nb, <span class="at">style =</span> <span class="st">"B"</span>)</span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(rls_mat) <span class="ot">&lt;-</span> rls_covid<span class="sc">$</span>RLS_code</span>
<span id="cb146-5"><a href="#cb146-5" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(rls_mat) <span class="ot">&lt;-</span> rls_covid<span class="sc">$</span>RLS_code</span>
<span id="cb146-6"><a href="#cb146-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb146-7"><a href="#cb146-7" aria-hidden="true" tabindex="-1"></a>rls_spamm <span class="ot">&lt;-</span> <span class="fu">fitme</span>(cas <span class="sc">~</span> <span class="fu">log</span>(dens_pop) <span class="sc">+</span> <span class="fu">offset</span>(<span class="fu">log</span>(pop)) <span class="sc">+</span> <span class="fu">adjacency</span>(<span class="dv">1</span> <span class="sc">|</span> RLS_code),</span>
<span id="cb146-8"><a href="#cb146-8" aria-hidden="true" tabindex="-1"></a>                   <span class="at">data =</span> rls_covid, <span class="at">adjMatrix =</span> rls_mat, <span class="at">family =</span> poisson)</span>
<span id="cb146-9"><a href="#cb146-9" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(rls_spamm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>formula: cas ~ log(dens_pop) + offset(log(pop)) + adjacency(1 | RLS_code)
Estimation of corrPars and lambda by ML (p_v approximation of logL).
Estimation of fixed effects by ML (p_v approximation of logL).
Estimation of lambda by 'outer' ML, maximizing logL.
family: poisson( link = log ) 
 ------------ Fixed effects (beta) ------------
              Estimate Cond. SE t-value
(Intercept)    -5.1618  0.16855 -30.625
log(dens_pop)   0.1999  0.03267   6.119
 --------------- Random effects ---------------
Family: gaussian( link = identity ) 
                   --- Correlation parameters:
    1.rho 
0.1576605 
           --- Variance parameters ('lambda'):
lambda = var(u) for u ~ Gaussian; 
   RLS_code  :  0.266  
# of obs: 95; # of groups: RLS_code, 95 
 ------------- Likelihood values  -------------
                        logLik
logL       (p_v(h)): -709.3234</code></pre>
</div>
</div>
<p>Note that the spatial correlation coefficient <code>rho</code> (0.158) is similar to the equivalent quantity in the <code>spautolm</code> model above, where it was called <code>Lambda</code>. The effect of <code>log(dens_pop)</code> is also approximately 0.2 in both models.</p>
<section id="reference-1" class="level2">
<h2 class="anchored" data-anchor-id="reference-1">Reference</h2>
<p>Moraga, Paula (2019) Geospatial Health Data: Modeling and Visualization with R-INLA and Shiny. Chapman &amp; Hall/CRC Biostatistics Series. Available online at <a href="https://www.paulamoraga.com/book-geospatial/" class="uri">https://www.paulamoraga.com/book-geospatial/</a>.</p>
<hr>
</section>
</section>
<section id="statistiques-spatiales-en-écologie" class="level1" data-number="16">
<h1 data-number="16"><span class="header-section-number">16</span> Statistiques spatiales en écologie</h1>
<p>BIOS² a organisé une session de formation en ligne sur l’analyse statistique des données spatiales en écologie, animée par le Pr. Philippe Marchand (UQAT). Cette formation de 12 heures s’est déroulée en 4 sessions : 12, 14, 19 &amp; 21 janvier (2021) de 13h00 à 16h00 HNE.</p>
<p>Le contenu comprenait trois types d’analyses statistiques spatiales et leurs applications en écologie : (1) l’analyse des patrons de points qui permet d’étudier la distribution d’individus ou d’événements dans l’espace; (2) les modèles géostatistiques qui représentent la corrélation spatiale de variables échantillonnées à des points géoréférencés; et (3) les modèles de données aréales, qui s’appliquent aux mesures prises sur des régions de l’espace et qui représentent les liens spatiaux par le biais de réseaux de voisinage. La formation comprenait également des exercices pratiques utilisant l’environnement de programmation statistique R.</p>
<p><a href="https://github.com/pmarchand1">Philippe Marchand</a> est professeur d’écologie et de biostatistique à l’Institut de recherche sur les forêts, Université du Québec en Abitibi-Témiscamingue (UQAT) et membre académique de BIOS². Ses travaux de recherche portent sur la modélisation de processus qui influencent la distribution spatiale des populations, incluant: la dispersion des graines et l’établissement des semis, le mouvement des animaux, et la propagation des épidémies forestières.</p>
<p><strong>Si vous souhaitez consulter le matériel pédagogique et suivre les exercices à votre propre rythme, vous pouvez y accéder par <a href="https://bios2.github.io/Marchand.html#category:FR">ce lien</a>. Une connaissance de base des modèles de régression linéaire et une expérience de l’ajustement de ces modèles dans R sont recommandées. Le repositoire original se trouve <a href="https://github.com/pmarchand1/BIOS2-spatial-stats">ici</a>.</strong></p>
<section id="plan-du-cours" class="level2">
<h2 class="anchored" data-anchor-id="plan-du-cours">Plan du cours</h2>
<table class="table">
<thead>
<tr class="header">
<th>Jour</th>
<th style="text-align: left;">Sujets</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td style="text-align: left;">• <a href="#introduction-fr">Introduction aux statistiques spatiales</a> <br> • <a href="#point-pattern-fr">Analyse des patrons de points</a> <br></td>
</tr>
<tr class="even">
<td>2</td>
<td style="text-align: left;">• <a href="#spatial-correlation-fr">Corrélation spatiale d’une variable</a> <br> • <a href="#geostat-models-fr">Modèles géostatistiques</a></td>
</tr>
<tr class="odd">
<td>3</td>
<td style="text-align: left;">• <a href="#areal-data-fr">Données aréales</a> <br> • <a href="#moran-i-fr">Indice de Moran</a> <br> • <a href="#spatial-autoreg-fr">Modèles d’autorégression spatiale</a> <br> • <a href="#analysis-areal-fr">Analyse des données aréales dans R</a></td>
</tr>
<tr class="even">
<td>4</td>
<td style="text-align: left;">• <a href="#glmm-spatial-gaussian-fr">GLMM avec processus spatial gaussien</a> <br> • <a href="#glmm-spatial-autoreg-fr">GLMM avec autorégression spatiale</a></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="introduction-fr" class="level1" data-number="17">
<h1 data-number="17"><span class="header-section-number">17</span> Introduction aux statistiques spatiales</h1>
<section id="types-danalyses-spatiales" class="level2">
<h2 class="anchored" data-anchor-id="types-danalyses-spatiales">Types d’analyses spatiales</h2>
<p>Dans le cadre de cette formation, nous discuterons de trois types d’analyses spatiales: l’analyse des patrons de points, les modèles géostatistiques et les modèles de données aréales.</p>
<p>Dans l’<strong>analyse des patrons de points</strong>, nous avons des données ponctuelles représentant la position d’individus ou d’événements dans une région d’étude et nous supposons que tous les individus ou événements ont été recensés dans cette région. Cette analyse s’intéresse à la distribution des positions des points eux-mêmes. Voici quelques questions typiques de l’analyse des patrons de points:</p>
<ul>
<li><p>Les points sont-ils disposés aléatoirement ou agglomérés?</p></li>
<li><p>Deux types de points sont-ils disposés indépendamment?</p></li>
</ul>
<p>Les <strong>modèles géostatistiques</strong> visent à représenter la distribution spatiale de variables continues qui sont mesurés à certains points d’échantillonnage. Ils supposent que les mesures de ces variables à différents points sont corrélées en fonction de la distance entre ces points. Parmi les applications des modèles géostatistiques, notons le lissage des données spatiales (ex.: produire une carte d’une variable sur l’ensemble d’une région en fonction des mesures ponctuelles) et la prédiction de ces variables pour des points non-échantillonnés.</p>
<p>Les <strong>données aréales</strong> sont des mesures prises non pas à des points, mais pour des régions de l’espace représentées par des polygones (ex.: divisions du territoire, cellules d’une grille). Les modèles représentant ces types de données définissent un réseau de voisinage reliant les régions et incluent une corrélation spatiale entre régions voisines.</p>
</section>
<section id="stationnarité-et-isotropie" class="level2">
<h2 class="anchored" data-anchor-id="stationnarité-et-isotropie">Stationnarité et isotropie</h2>
<p>Plusieurs analyses spatiales supposent que les variables sont <strong>stationnaires</strong> dans l’espace. Comme pour la stationnarité dans le domaine temporel, cette propriété signifie que les statistiques sommaires (moyenne, variance et corrélations entre mesures d’une variable) ne varient pas avec une translation dans l’espace. Par exemple, la corrélation spatiale entre deux points peut dépendre de la distance les séparant, mais pas de leur position absolue.</p>
<p>En particulier, il ne peut pas y avoir de tendance à grande échelle (souvent appelée <em>gradient</em> dans un contexte spatial), ou bien cette tendance doit être prise en compte afin de modéliser la corrélation spatiale des résidus.</p>
<p>Dans le cas de l’analyse des patrons de points, la stationnarité (aussi appelée homogénéité dans ce contexte) signifie que la densité des points ne suit pas de tendance à grande échelle.</p>
<p>Dans un modèle statistique <strong>isotropique</strong>, les corrélations spatiales entre les mesures à deux points dépendent seulement de la distance entre ces points, pas de la direction. Dans ce cas, les statistiques sommaires ne varient pas si on effectue une rotation dans l’espace.</p>
</section>
<section id="données-géoréférencées" class="level2">
<h2 class="anchored" data-anchor-id="données-géoréférencées">Données géoréférencées</h2>
<p>Les études environnementales utilisent de plus en plus de données provenant de sources de données géospatiales, c’est-à-dire des variables mesurées sur une grande partie du globe (ex.: climat, télédétection). Le traitement de ces données requiert des concepts liés aux systèmes d’information géographique (SIG), qui ne sont pas couverts dans cet atelier, alors que nous nous concentrons sur les aspects statistiques de données variant dans l’espace.</p>
<p>L’utilisation de données géospatiales ne signifie pas nécessairement qu’il faut avoir recours à des statistiques spatiales. Par exemple, il est courant d’extraire les valeurs de ces variables géographiques à des points d’étude pour expliquer une réponse biologique observée sur le terrain. Dans ce cas, l’utilisation de statistiques spatiales est seulement nécessaire en présence d’une corrélation spatiale dans les résidus, après avoir tenu compte de l’effet des prédicteurs.</p>
</section>
</section>
<section id="point-pattern-fr" class="level1" data-number="18">
<h1 data-number="18"><span class="header-section-number">18</span> Analyse des patrons de points</h1>
<section id="patron-de-points-et-processus-ponctuel" class="level2">
<h2 class="anchored" data-anchor-id="patron-de-points-et-processus-ponctuel">Patron de points et processus ponctuel</h2>
<p>Un patron de points (<em>point pattern</em>) décrit la position spatiale (le plus souvent en 2D) d’individus ou d’événements, représentés par des points, dans une aire d’étude donnée, souvent appelée la <em>fenêtre</em> d’observation.</p>
<p>On suppose que chaque point a une étendue spatiale négligeable par rapport aux distances entre les points. Des méthodes plus complexes existent pour traiter des patrons spatiaux d’objets qui ont une largeur non-néligeable, mais ce sujet dépasse la portée de cet atelier.</p>
<p>Un processus ponctuel (<em>point process</em>) est un modèle statistique qui peut être utilisé pour simuler des patrons de points ou expliquer un patron de points observé.</p>
</section>
<section id="structure-spatiale-totalement-aléatoire" class="level2">
<h2 class="anchored" data-anchor-id="structure-spatiale-totalement-aléatoire">Structure spatiale totalement aléatoire</h2>
<p>Une structure spatiale totalement aléatoire (<em>complete spatial randomness</em>) est un des patrons les plus simples, qui sert de modèle nul pour évaluer les caractéristiques de patrons de points réels. Dans ce patron, la présence d’un point à une position donnée est indépendante de la présence de points dans un voisinage.</p>
<p>Le processus créant ce patron est un processus de Poisson homogène. Selon ce modèle, le nombre de points dans toute région de superficie <span class="math inline">\(A\)</span> suit une distribution de Poisson: <span class="math inline">\(N(A) \sim \text{Pois}(\lambda A)\)</span>, où <span class="math inline">\(\lambda\)</span> est l’<em>intensité</em> du processus (i.e.&nbsp;la densité de points). <span class="math inline">\(N\)</span> est indépendant entre deux régions disjointes, peu importe comment ces régions sont définies.</p>
<p>Dans le graphique ci-dessous, seul le patron à droite est totalement aléatoire. Le patron à gauche montre une agrégation des points (probabilité plus grande d’observer un point si on est à proximité d’un autre point), tandis que le patron du centre montre une répulsion (faible probabilité d’observer un point très près d’un autre).</p>
<div class="cell" data-fig.dim="[9,3]" data-hash="index_cache/html/unnamed-chunk-91_adc67cb15e035b62bde9aae5a2aa1217">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-91-1.png" class="img-fluid" width="864"></p>
</div>
</div>
</section>
<section id="analyse-exploratoire-ou-inférentielle-pour-un-patron-de-points" class="level2">
<h2 class="anchored" data-anchor-id="analyse-exploratoire-ou-inférentielle-pour-un-patron-de-points">Analyse exploratoire ou inférentielle pour un patron de points</h2>
<p>Plusieurs statistiques sommaires sont utilisées pour décrire les caractéristiques un patron de points. La plus simple est l’<strong>intensité</strong> <span class="math inline">\(\lambda\)</span>, qui comme mentionné plus haut représente la densité de points par unité de surface. Si le patron de points est hétérogène, l’intensité n’est pas constante, mais dépend de la position: <span class="math inline">\(\lambda(x, y)\)</span>.</p>
<p>Par rapport à l’intensité qui est une statistique dite de premier ordre, les statistiques de second ordre décrivent comment la probabilité de présence d’un point dans une région dépend de la présence d’autres points. L’indice <span class="math inline">\(K\)</span> de Ripley présenté dans la prochaine section est un exemple de statistique sommaire de second ordre.</p>
<p>Les inférences statistiques réalisées sur des patrons de points consistent habituellement à tester l’hypothèse que le patron de points correspond à un modèle nul donné, par exemple une structure spatiale totalement aléatoire, ou un modèle nul plus complexe. Même pour les modèles nuls les plus simples, nous connaissons rarement la distribution théorique pour une statistique sommaire du patron de points sous le modèle nul. Les tests d’hypothèses sur les patrons de points sont donc réalisés par simulation: on simule un grand nombre de patrons de points à partir du modèle nul et on compare la distribution des statistiques sommaires qui nous intéressent pour ces simulations à la valeur des statistiques pour le patron de points observé.</p>
</section>
<section id="indice-k-de-ripley" class="level2">
<h2 class="anchored" data-anchor-id="indice-k-de-ripley">Indice <span class="math inline">\(K\)</span> de Ripley</h2>
<p>L’indice de Ripley <span class="math inline">\(K(r)\)</span> est défini comme le nombre moyen de points se trouvant dans un cercle de rayon <span class="math inline">\(r\)</span> donné autour d’un point du patron, normalisé par l’intensité <span class="math inline">\(\lambda\)</span>.</p>
<p>Pour un patron totalement aléatoire, le nombre moyen de points dans un cercle de rayon <span class="math inline">\(r\)</span> est <span class="math inline">\(\lambda \pi r^2\)</span>, donc en théorie <span class="math inline">\(K(r) = \pi r^2\)</span> pour ce modèle nul. Une valeur de <span class="math inline">\(K(r)\)</span> supérieure signifie qu’il y a agrégation des points à l’échelle <span class="math inline">\(r\)</span>, tandis qu’une valeur inférieure signifie qu’il y a une répulsion.</p>
<p>En pratique, <span class="math inline">\(K(r)\)</span> est estimé pour un patron de points donné par l’équation:</p>
<p><span class="math display">\[ K(r) = \frac{A}{n(n-1)} \sum_i \sum_{j &gt; i} I \left( d_{ij} \le r \right) w_{ij}\]</span></p>
<p>où <span class="math inline">\(A\)</span> est l’aire de la fenêtre d’observation et <span class="math inline">\(n\)</span> est le nombre de points du patron, donc <span class="math inline">\(n(n-1)\)</span> est le nombre de paires de points distinctes. On fait la somme pour toutes les paires de points de la fonction indicatrice <span class="math inline">\(I\)</span>, qui prend une valeur de 1 si la distance entre les points <span class="math inline">\(i\)</span> et <span class="math inline">\(j\)</span> est inférieure ou égale à <span class="math inline">\(r\)</span>. Finalement, le terme <span class="math inline">\(w_{ij}\)</span> permet de donner un poids supplémentaire à certaines paires de points pour tenir compte des effets de bordure, tel que discuté dans la section suivante.</p>
<p>Par exemple, les graphiques ci-dessous présentent la fonction estimée <span class="math inline">\(K(r)\)</span> pour les patrons illustrés ci-dessus, pour des valeurs de <span class="math inline">\(r\)</span> allant jusqu’à 1/4 de la largeur de la fenêtre. La courbe pointillée rouge indique la valeur théorique pour une structure spatiale totalement aléatoire et la zone grise est une “enveloppe” produite par 99 simulations de ce modèle nul. Le patron agrégé montre un excès de voisins jusqu’à <span class="math inline">\(r = 0.25\)</span> et le patron avec répulsion montre un déficit significatif de voisins pour les petites valeurs de <span class="math inline">\(r\)</span>.</p>
<div class="cell" data-fig.dim="[9,3]" data-hash="index_cache/html/unnamed-chunk-93_6abeb25aeaeb61368f985f60bb26c046">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-93-1.png" class="img-fluid" width="864"></p>
</div>
</div>
<p>Outre le <span class="math inline">\(K\)</span>, il existe d’autres statistiques pour décrire les propriétés de second ordre du patron, par exemple la distance moyenne entre un point et ses <span class="math inline">\(N\)</span> plus proches voisins. Vous pouvez consulter le manuel de Wiegand et Moloney (2013) suggéré en référence pour en apprendre plus sur différentes statistiques sommaires des patrons de points.</p>
</section>
<section id="effets-de-bordure" class="level2">
<h2 class="anchored" data-anchor-id="effets-de-bordure">Effets de bordure</h2>
<p>Dans le contexte de l’analyse de patrons de points, l’effet de bordure (“edge effect”) est dû au fait que nous avons une connaissance incomplète du voisinage des points près du bord de la fenêtre d’observation, ce qui peut induire un biais dans le calcul des statistiques comme le <span class="math inline">\(K\)</span> de Ripley.</p>
<p>Différentes méthodes ont été développées pour corriger le biais dû aux effets de bordure. Selon la méthode de Ripley, la contribution d’un voisin <span class="math inline">\(j\)</span> situé à une distance <span class="math inline">\(r\)</span> d’un point <span class="math inline">\(i\)</span> reçoit un poids <span class="math inline">\(w_{ij} = 1/\phi_i(r)\)</span>, où <span class="math inline">\(\phi_i(r)\)</span> est la fraction du cercle de rayon <span class="math inline">\(r\)</span> autour de <span class="math inline">\(i\)</span> contenu dans la fenêtre d’observation. Par exemple, si 2/3 du cercle se trouve dans la fenêtre, ce voisin compte pour 3/2 voisins dans le calcul d’une statistique comme <span class="math inline">\(K\)</span>.</p>
<p><img src="images/ripley_edge.png" class="img-fluid"></p>
<p>La méthode de Ripley est une des plus simples pour corriger les effets de bordure, mais n’est pas nécessairement la plus efficace; notamment, les poids plus grands donnés à certaines paires de points tend à accroître la variance du calcul de la statistique. D’autres méthodes de correction sont présentées dans les manuels spécialisés, comme celui de Wiegand et Moloney (2013) en référence.</p>
</section>
<section id="exemple" class="level2">
<h2 class="anchored" data-anchor-id="exemple">Exemple</h2>
<p>Pour cet exemple, nous utilisons le jeu de données <a href="data/semis_xy.csv">semis_xy.csv</a>, qui représente les coordonnées <span class="math inline">\((x, y)\)</span> de semis de deux espèces (<em>sp</em>, B = bouleau et P = peuplier) dans une placette de 15 x 15 m.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-94_327e5e9e3c1899c6fc6b1fb294f06e68">
<div class="sourceCode cell-code" id="cb148"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a>semis <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">"data/semis_xy.csv"</span>)</span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(semis)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      x    y sp
1 14.73 0.05  P
2 14.72 1.71  P
3 14.31 2.06  P
4 14.16 2.64  P
5 14.12 4.15  B
6  9.88 4.08  B</code></pre>
</div>
</div>
<p>Le package <em>spatstat</em> permet d’effectuer des analyses de patrons de point dans R. La première étape consiste à transformer notre tableau de données en objet <code>ppp</code> (patron de points) avec la fonction du même nom. Dans cette fonction, nous spécifions quelles colonnes contiennent les coordonnées <em>x</em> et <em>y</em> ainsi que les marques (<code>marks</code>), qui seront ici les codes d’espèce. Il faut aussi spécifier une fenêtre d’observation (<code>window</code>) à l’aide de la fonction <code>owin</code>, à laquelle nous indiquons les limites de la placette en <em>x</em> et <em>y</em>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-95_e246a905ab0e728b8bebd2e4c7effcef">
<div class="sourceCode cell-code" id="cb150"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(spatstat)</span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true" tabindex="-1"></a>semis <span class="ot">&lt;-</span> <span class="fu">ppp</span>(<span class="at">x =</span> semis<span class="sc">$</span>x, <span class="at">y =</span> semis<span class="sc">$</span>y, <span class="at">marks =</span> <span class="fu">as.factor</span>(semis<span class="sc">$</span>sp),</span>
<span id="cb150-4"><a href="#cb150-4" aria-hidden="true" tabindex="-1"></a>             <span class="at">window =</span> <span class="fu">owin</span>(<span class="at">xrange =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">15</span>), <span class="at">yrange =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">15</span>)))</span>
<span id="cb150-5"><a href="#cb150-5" aria-hidden="true" tabindex="-1"></a>semis</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Marked planar point pattern: 281 points
Multitype, with levels = B, P 
window: rectangle = [0, 15] x [0, 15] units</code></pre>
</div>
</div>
<p>Les marques peuvent être numériques ou catégorielles. Notez que pour des marques catégorielles comme c’est le cas ici, il faut convertir explicitement la variable en facteur.</p>
<p>La fonction <code>plot</code> appliquée à un patron de points montre un diagramme du patron.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-96_96d77aa12e04c69ed21ee84e297dba59">
<div class="sourceCode cell-code" id="cb152"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(semis)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-96-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>La fonction <code>intensity</code> calcule la densité des points de chaque espèce par unité de surface, ici en <span class="math inline">\(m^2\)</span>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-97_beac65d0093c1448eec5b7873eb79e0b">
<div class="sourceCode cell-code" id="cb153"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="fu">intensity</span>(semis)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        B         P 
0.6666667 0.5822222 </code></pre>
</div>
</div>
<p>Pour analyser d’abord séparément la distribution de chaque espèce, nous séparons le patron avec <code>split</code>. Puisque le patron contient des marques catégorielles, la séparation se fait automatiquement en fonction de la valeur des marques. Le résultat est une liste de deux patrons de points.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-98_b03959fb9ef2a14b73c3512a12d3e227">
<div class="sourceCode cell-code" id="cb155"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a>semis_split <span class="ot">&lt;-</span> <span class="fu">split</span>(semis)</span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(semis_split)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-98-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>La fonction <code>Kest</code> calcule le <span class="math inline">\(K\)</span> de Ripley pour une série de distances allant (par défaut) jusqu’à 1/4 de la largeur de la fenêtre. Ici, nous l’appliquons au premier patron (bouleau) en choisissant <code>semis_split[[1]]</code>. Notez que les doubles crochets sont nécessaires pour choisir un élément d’une liste dans R.</p>
<p>L’argument <code>correction = "iso"</code> indique d’appliquer la méthode de Ripley pour corriger les effets de bordure.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-99_181444d1e19a264175dc77ad57d2d3d0">
<div class="sourceCode cell-code" id="cb156"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a>k <span class="ot">&lt;-</span> <span class="fu">Kest</span>(semis_split[[<span class="dv">1</span>]], <span class="at">correction =</span> <span class="st">"iso"</span>)</span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(k)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-99-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Selon ce graphique, il semble y avoir une excès de voisins à partir d’un rayon de 1 m. Pour vérifier s’il s’agit d’un écart significatif, nous produisons une enveloppe de simulation avec la fonction <code>envelope</code>. Le permier argument d’<code>envelope</code> est un patron de point auquel les simulations seront comparées, le deuxième une fonction à calculer (ici, <code>Kest</code>) pour chaque patron simulé, puis on y ajoute les arguments de la fonction <code>Kest</code> (ici, seulement <code>correction</code>).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-100_c8ef12d95e636626e72d894b8455cc8e">
<div class="sourceCode cell-code" id="cb157"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">envelope</span>(semis_split[[<span class="dv">1</span>]], Kest, <span class="at">correction =</span> <span class="st">"iso"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Generating 99 simulations of CSR  ...
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,  99.

Done.</code></pre>
</div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-100-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Tel qu’indiqué par le message, cette fonction effectue par défaut 99 simulations de l’hypothèse nulle correspondant à une structure spatiale totalement aléatoire (CSR, pour <em>complete spatial randomness</em>).</p>
<p>La courbe observée sort de l’enveloppe des 99 simulations près de <span class="math inline">\(r = 2\)</span>. Il faut être prudent de ne pas interpréter trop rapidement un résultat sortant de l’enveloppe. Même s’il y a environ une probabilité de 1% d’obtenir un résultat plus extrême selon l’hypothèse nulle à une distance donnée, l’enveloppe est calculée pour un grand nombre de valeurs de la distance et nous n’effectuons pas de correction pour les comparaisons multiples. Ainsi, un écart significatif pour une très petite plage de valeurs de <span class="math inline">\(r\)</span> peut être simplement dû au hasard.</p>
<section id="exercice-1" class="level3">
<h3 class="anchored" data-anchor-id="exercice-1">Exercice 1</h3>
<p>En regardant le graphique du deuxième patron de points (semis de peuplier), pouvez-vous prédire où se situera le <span class="math inline">\(K\)</span> de Ripley par rapport à l’hypothèse nulle d’une structure spatiale totalement aléatoire? Vérifiez votre prédiction en calculant le <span class="math inline">\(K\)</span> de Ripley pour ce patron de points dans R.</p>
</section>
</section>
<section id="effet-de-lhétérogénéité" class="level2">
<h2 class="anchored" data-anchor-id="effet-de-lhétérogénéité">Effet de l’hétérogénéité</h2>
<p>Le graphique ci-dessous illustre un patron de points <em>hétérogène</em>, c’est-à-dire qu’il présente un gradient d’intensité (plus de points à gauche qu’à droite).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-102_4f8ece21b321a6bc37f12ea916525a4e">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-102-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Un gradient de densité peut être confondu avec une agrégation des points, comme on peut voir sur le graphique du <span class="math inline">\(K\)</span> de Ripley correspondant. En théorie, il s’agit de deux processus différents:</p>
<ul>
<li><p>Hétérogénéité: La densité de points varie dans la région d’étude, par exemple dû au fait que certaines conditions locales sont plus propices à la présence de l’espèce étudiée.</p></li>
<li><p>Agrégation: La densité moyenne des points est homogène, mais la présence d’un point augmente la présence d’autre points dans son voisinage, par exemple en raison d’interactions positives entre les individus.</p></li>
</ul>
<p>Cependant, il peut être difficile de différencier les deux en pratique, surtout que certains patrons peuvent être à la fois hétérogènes et agrégés.</p>
<p>Prenons l’exemple des semis de peuplier de l’exercice précédent. La fonction <code>density</code> appliquée à un patron de points effectue une estimation par noyau (<em>kernel density estimation</em>) de la densité des semis à travers la placette. Par défaut, cette fonction utilise un noyau gaussien avec un écart-type <code>sigma</code> spécifié dans la fonction, qui détermine l’échelle à laquelle les fluctuations de densité sont “lissées”. Ici, nous utilisons une valeur de 2 m pour <code>sigma</code> et nous représentons d’abord la densité estimée avec <code>plot</code>, avant d’y superposer les points (<code>add = TRUE</code> signifie que les points sont ajoutés au graphique existant plutôt que de créer un nouveau graphique).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-103_293155d4d47f9be8ba5f92c275edfe33">
<div class="sourceCode cell-code" id="cb159"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a>dens_p <span class="ot">&lt;-</span> <span class="fu">density</span>(semis_split[[<span class="dv">2</span>]], <span class="at">sigma =</span> <span class="dv">2</span>)</span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(dens_p)</span>
<span id="cb159-3"><a href="#cb159-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(semis_split[[<span class="dv">2</span>]], <span class="at">add =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-103-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Pour mesurer l’agrégation ou la répulsion des points d’un patron hétérogène, nous devons utilisé la version non-homogène de la statistique <span class="math inline">\(K\)</span> (<code>Kinhom</code> dans <em>spatstat</em>). Cette statistique est toujours égale au nombre moyen de voisins dans un rayon <span class="math inline">\(r\)</span> d’un point du patron, mais plutôt que de normaliser ce nombre par l’intensité globale du patron, il est normalisé par l’estimation locale de la densité de points. Comme ci-dessus, nous spécifions <code>sigma = 2</code> pour contrôler le niveau de lissage de l’estimation de la densité variable.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-104_2e7d6e77388db4c6cf95e3825468e730">
<div class="sourceCode cell-code" id="cb160"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">Kinhom</span>(semis_split[[<span class="dv">2</span>]], <span class="at">sigma =</span> <span class="dv">2</span>, <span class="at">correction =</span> <span class="st">"iso"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-104-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>En tenant compte de l’hétérogénéité du patron à une échelle <code>sigma</code> de 2 m, il semble donc y avoir un déficit de voisins à partir d’environ 1.5 m des points du patron. Il reste à voir si cette déviation est significative.</p>
<p>Comme précédemment, nous utilisons <code>envelope</code> pour simuler la statistique <code>Kinhom</code> sous le modèle nul. Cependant, ici le modèle nul n’est pas un processus de Poisson homogène (structure spatiale totalement aléatoire). Il s’agit plutôt d’un processus de Poisson hétérogène simulé par la fonction <code>rpoispp(dens_p)</code>, c’est-à-dire que les points sont indépendants les uns des autres, mais leur densité est hétérogène et donnée par <code>dens_p</code>. L’argument <code>simulate</code> de la fonction <code>envelope</code> permet de spécifier une fonction utilisée pour les simulations sous le modèle nul; cette fonction doit avoir un argument, ici <code>x</code>, même s’il n’est pas utilisé.</p>
<p>Finalement, en plus des arguments nécessaires pour <code>Kinhom</code>, soit <code>sigma</code> et <code>correction</code>, nous spécifions aussi <code>nsim = 199</code> pour réaliser 199 simulations et <code>nrank = 5</code> pour éliminer les 5 résultats les plus extrêmes de chaque côté de l’enveloppe, donc les 10 plus extrêmes sur 199, pour réaliser un intervalle contenant environ 95% de la probabilité sous l’hypothèse nulle.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-105_372339d2d2e016521c3700d91cc77898">
<div class="sourceCode cell-code" id="cb161"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a>khet_p <span class="ot">&lt;-</span> <span class="fu">envelope</span>(semis_split[[<span class="dv">2</span>]], Kinhom, <span class="at">sigma =</span> <span class="dv">2</span>, <span class="at">correction =</span> <span class="st">"iso"</span>,</span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a>                   <span class="at">nsim =</span> <span class="dv">199</span>, <span class="at">nrank =</span> <span class="dv">5</span>, <span class="at">simulate =</span> <span class="cf">function</span>(x) <span class="fu">rpoispp</span>(dens_p))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Generating 199 simulations by evaluating function  ...
1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114.116.118.120
.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154.156.158.160
.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194.196.198 199.

Done.</code></pre>
</div>
<div class="sourceCode cell-code" id="cb163"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(khet_p)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-105-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p><em>Note</em>: Pour un test d’hypothèse basé sur des simulations d’une hypothèse nulle, la valeur <span class="math inline">\(p\)</span> est estimée par <span class="math inline">\((m + 1)/(n + 1)\)</span>, où <span class="math inline">\(n\)</span> est le nombre de simulations et <span class="math inline">\(m\)</span> est le nombre de simulations où la valeur de la statistique est plus extrême que celle des données observées. C’est pour cette raison qu’on choisit un nombre de simulations comme 99, 199, etc.</p>
<section id="exercice-2" class="level3">
<h3 class="anchored" data-anchor-id="exercice-2">Exercice 2</h3>
<p>Répétez l’estimation de la densité hétérogène et le calcul de <code>Kinhom</code> avec un écart-type <code>sigma</code> de 5 plutôt que 2. Comment le niveau de lissage pour la densité influence-t-il les conclusions?</p>
<p>Pour différencier une variation de densité des points et d’une interaction (agrégation ou répulsion) entre ces points avec ce type d’analyse, il faut généralement supposer que les deux processus opèrent à différentes échelles. Typiquement, nous pouvons tester si les points sont agrégés à petite échelle après avoir tenu compte d’une variation de la densité à une échelle plus grande.</p>
</section>
</section>
<section id="relation-entre-deux-patrons-de-points" class="level2">
<h2 class="anchored" data-anchor-id="relation-entre-deux-patrons-de-points">Relation entre deux patrons de points</h2>
<p>Considérons un cas où nous avons deux patrons de points, par exemple la position des arbres de deux espèces dans une parcelle (points oranges et verts dans le graphique ci-dessous). Chacun des deux patrons peut présenter ou non des agrégations de points.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-106_a7d54ff1bdd2b3ad9381ec359732b6e9">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-106-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Sans égard à cette agrégation au niveau de l’espèce, nous voulons déterminer si les deux espèces sont disposées indépendamment. Autrement dit, la probabilité d’observer un arbre d’une espèce dépend-elle de la présence d’un arbre de l’autre espèce à une distance donnée?</p>
<p>La version bivariée du <span class="math inline">\(K\)</span> de Ripley permet de répondre à cette question. Pour deux patrons désignés 1 et 2, l’indice <span class="math inline">\(K_{12}(r)\)</span> calcule le nombre moyen de points du patron 2 dans un rayon <span class="math inline">\(r\)</span> autour d’un point du patron 1, normalisé par la densité du patron 2.</p>
<p>En théorie, cet indice est symétrique, donc <span class="math inline">\(K_{12}(r) = K_{21}(r)\)</span> et le résultat serait le même si on choisit les points du patron 1 ou 2 comme points “focaux” pour l’analyse. Cependant, l’estimation des deux quantités pour un patron observé peut différer, notamment en raison des effets de bord. La variabilité peut aussi être différente pour <span class="math inline">\(K_{12}\)</span> et <span class="math inline">\(K_{21}\)</span> entre les simulations d’un modèle nul, donc le test de l’hypothèse nulle peut avoir une puissance différente selon le choix de l’espèce focale.</p>
<p>Le choix d’un modèle nul approprié est important ici. Afin de déterminer s’il existe une attraction ou une répulsion significative entre les deux patrons, il faut déplacer aléatoirement la position d’un des patrons relative à celle de l’autre patron, tout en conservant la structure spatiale de chaque patron pris isolément.</p>
<p>Une des façons d’effectuer cette randomisation consiste à décaler l’un des deux patrons horizontalement et/ou verticalement d’une distance aléatoire. La partie du patron qui “sort” d’un côté de la fenêtre est rattachée de l’autre côté. Cette méthode s’appelle une translation toroïdale (<em>toroidal shift</em>), car en connectant le haut et le bas ainsi que la gauche et la droite d’une surface rectangulaire, on obtient la forme d’un tore (un “beigne” en trois dimensions).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-107_1757cb541cf05d572ea82ab56ed6f90e">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-107-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Le graphique ci-dessus illustre une translation du patron vert vers la droite, tandis que le patron orange reste au même endroit. Les points verts dans la zone ombragée sont ramenés de l’autre côté. Notez que si cette méthode préserve de façon générale la structure de chaque patron tout en randomisant leur position relative, elle peut comporter certains inconvénients, comme de diviser des amas de points qui se trouvent près du point de coupure.</p>
<p>Vérifions maintenant s’il y a une dépendance entre la position des deux espèces (bouleau et peuplier) dans notre placette. La fonction <code>Kcross</code> calcule l’indice bivarié <span class="math inline">\(K_{ij}\)</span>, il faut spécifier quel type de point est considéré comme l’espèce focale <span class="math inline">\(i\)</span> et l’espèce voisine <span class="math inline">\(j\)</span>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-108_e1fb67c992e6fbc5436f40af7db13109">
<div class="sourceCode cell-code" id="cb164"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">Kcross</span>(semis, <span class="at">i =</span> <span class="st">"P"</span>, <span class="at">j =</span> <span class="st">"B"</span>, <span class="at">correction =</span> <span class="st">"iso"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-108-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Ici, le <span class="math inline">\(K\)</span> observé est inférieur à la valeur théorique, indiquant une répulsion possible des deux patrons.</p>
<p>Pour déterminer l’enveloppe du <span class="math inline">\(K\)</span> selon l’hypothèse nulle d’indépendance des deux patrons, nous devons spécifier que les simulations doivent être basées sur une translation des patrons. Nous indiquons que les simulations doivent utiliser la fonction <code>rshift</code> (translation aléatoire) avec l’argument <code>simulate = function(x) rshift(x, which = "B")</code>; ici, l’argument <code>x</code> de <code>simulate</code> correspond au patron de points original et l’argument <code>which</code> indique quel type de points subit la translation. Comme pour le cas précédent, il faut répéter dans la fonction <code>envelope</code> les arguments nécessaires pour <code>Kcross</code>, soit <code>i</code>, <code>j</code> et <code>correction</code>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-109_727b1efb5e977942d084f00027cda511">
<div class="sourceCode cell-code" id="cb165"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">envelope</span>(semis, Kcross, <span class="at">i =</span> <span class="st">"P"</span>, <span class="at">j =</span> <span class="st">"B"</span>, <span class="at">correction =</span> <span class="st">"iso"</span>, </span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a>              <span class="at">nsim =</span> <span class="dv">199</span>, <span class="at">nrank =</span> <span class="dv">5</span>, <span class="at">simulate =</span> <span class="cf">function</span>(x) <span class="fu">rshift</span>(x, <span class="at">which =</span> <span class="st">"B"</span>)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Generating 199 simulations by evaluating function  ...
1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114.116.118.120
.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154.156.158.160
.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194.196.198 199.

Done.</code></pre>
</div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-109-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Ici, la courbe observée se situe totalement dans l’enveloppe, donc nous ne rejetons pas l’hypothèse nulle d’indépendance des deux patrons.</p>
<section id="questions-1" class="level3">
<h3 class="anchored" data-anchor-id="questions-1">Questions</h3>
<ol type="1">
<li><p>Quelle raison pourrait justifier ici notre choix d’effectuer la translation des points du bouleau plutôt que du peuplier?</p></li>
<li><p>Est-ce que les simulations générées par translation aléatoire constitueraient un bon modèle nul si les deux patrons étaient hétérogènes?</p></li>
</ol>
</section>
</section>
<section id="patrons-de-points-marqués" class="level2">
<h2 class="anchored" data-anchor-id="patrons-de-points-marqués">Patrons de points marqués</h2>
<p>Le jeu de données <a href="data/fir.csv">fir.csv</a> contient les coordonnées <span class="math inline">\((x, y)\)</span> de 822 sapins dans une placette d’un hectare et leur statut (A = vivant, D = mort) suivant une épidémie de tordeuse des bourgeons de l’épinette.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-110_b43d75059cee9e8f87a67abfa290388c">
<div class="sourceCode cell-code" id="cb167"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a>fir <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">"data/fir.csv"</span>)</span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(fir)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      x     y status
1 31.50  1.00      A
2 85.25 30.75      D
3 83.50 38.50      A
4 84.00 37.75      A
5 83.00 33.25      A
6 33.25  0.25      A</code></pre>
</div>
</div>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-111_2327e6a3855266c0ba92a5eed5b7ce1a">
<div class="sourceCode cell-code" id="cb169"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a>fir <span class="ot">&lt;-</span> <span class="fu">ppp</span>(<span class="at">x =</span> fir<span class="sc">$</span>x, <span class="at">y =</span> fir<span class="sc">$</span>y, <span class="at">marks =</span> <span class="fu">as.factor</span>(fir<span class="sc">$</span>status),</span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a>           <span class="at">window =</span> <span class="fu">owin</span>(<span class="at">xrange =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">100</span>), <span class="at">yrange =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">100</span>)))</span>
<span id="cb169-3"><a href="#cb169-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(fir)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-111-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Supposons que nous voulons vérifier si la mortalité des sapins est indépendante ou corrélée entre arbres rapprochés. En quoi cette question diffère-t-elle de l’exemple précédent où nous voulions savoir si la position des points de deux espèces était indépendante?</p>
<p>Dans l’exemple précédent, l’indépendance ou l’interaction entre les espèces référait à la formation du patron lui-même (que des semis d’une espèce s’établissent ou non à proximité de ceux de l’autre espèce). Ici, la caractéristique qui nous intéresse (survie des sapins) est postérieure à l’établissement du patron, en supposant que tous ces arbres étaient vivants d’abord et que certains sont morts suite à l’épidémie. Donc nous prenons la position des arbres comme fixe et nous voulons savoir si la distribution des statuts (mort, vivant) entre ces arbres est aléatoire ou présente un patron spatial.</p>
<p>Dans le manuel de Wiegand et Moloney, la première situation (établissement de semis de deux espèces) est appelé patron bivarié, donc il s’agit vraiment de deux patrons qui interagissent, tandis que la deuxième est un seul patron avec une <em>marque</em> qualitative. Le package <em>spatstat</em> dans R ne fait pas de différences entre les deux au niveau de la définition du patron (les types de points sont toujours représentés par l’argument <code>marks</code>), mais les méthodes d’analyse appliquées aux deux questions diffèrent.</p>
<p>Dans le cas d’un patron avec une marque qualitative, nous pouvons définir une fonction de connexion de marques (<em>mark connection function</em>) <span class="math inline">\(p_{ij}(r)\)</span>. Pour deux points séparés par une distance <span class="math inline">\(r\)</span>, cette fonction donne la probabilité que le premier point porte la marque <span class="math inline">\(i\)</span> et le deuxième la marque <span class="math inline">\(j\)</span>. Selon l’hypothèse nulle où les marques sont indépendantes, cette probabilité est égale au produit des proportions de chaque marque dans le patron entier, <span class="math inline">\(p_{ij}(r) = p_i p_j\)</span> indépendamment de <span class="math inline">\(r\)</span>.</p>
<p>Dans <em>spatstat</em>, la fonction de connexion de marques est calculée avec la fonction <code>markconnect</code>, où il faut spécifier les marques <span class="math inline">\(i\)</span> et <span class="math inline">\(j\)</span> ainsi que le type de correction des effets de bord. Dans notre exemple, nous voyons que deux points rapprochés ont moins de chance d’avoir une statut différent (A et D) que prévu selon l’hypothèse de distribution aléatoire et indépendante des marques (ligne rouge pointillée).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-112_e925b891841588727659504a7a0c6e6d">
<div class="sourceCode cell-code" id="cb170"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">markconnect</span>(fir, <span class="at">i =</span> <span class="st">"A"</span>, <span class="at">j =</span> <span class="st">"D"</span>, <span class="at">correction =</span> <span class="st">"iso"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-112-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Dans ce graphique, les ondulations dans la fonction sont dues à l’erreur d’estimation d’une fonction continue de <span class="math inline">\(r\)</span> à partir d’un nombre limité de paires de points discrètes.</p>
<p>Pour simuler le modèle nul dans ce cas-ci, nous utilisons la fonction <code>rlabel</code> qui réassigne aléatoirement les marques parmi les points du patron, en maintenant la position des points.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-113_41cb4b77111500454c477fbd4c96dd08">
<div class="sourceCode cell-code" id="cb171"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">envelope</span>(fir, markconnect, <span class="at">i =</span> <span class="st">"A"</span>, <span class="at">j =</span> <span class="st">"D"</span>, <span class="at">correction =</span> <span class="st">"iso"</span>, </span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a>              <span class="at">nsim =</span> <span class="dv">199</span>, <span class="at">nrank =</span> <span class="dv">5</span>, <span class="at">simulate =</span> rlabel))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Generating 199 simulations by evaluating function  ...
1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114.116.118.120
.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154.156.158.160
.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194.196.198 199.

Done.</code></pre>
</div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-113-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Notez que puisque la fonction <code>rlabel</code> a un seul argument obligatoire correspondant au patron de points original, il n’était pas nécessaire de spécifier au long: <code>simulate = function(x) rlabel(x)</code>.</p>
<p>Voici les résultats pour les paires d’arbres du même statut A ou D:</p>
<div class="cell" data-fig.dim="[10,5]" data-hash="index_cache/html/unnamed-chunk-114_2a3fc9a64a69a67d1266f0273c3bb85c">
<div class="sourceCode cell-code" id="cb173"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>))</span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">envelope</span>(fir, markconnect, <span class="at">i =</span> <span class="st">"A"</span>, <span class="at">j =</span> <span class="st">"A"</span>, <span class="at">correction =</span> <span class="st">"iso"</span>, </span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a>              <span class="at">nsim =</span> <span class="dv">199</span>, <span class="at">nrank =</span> <span class="dv">5</span>, <span class="at">simulate =</span> rlabel))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Generating 199 simulations by evaluating function  ...
1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114.116.118.120
.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154.156.158.160
.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194.196.198 199.

Done.</code></pre>
</div>
<div class="sourceCode cell-code" id="cb175"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">envelope</span>(fir, markconnect, <span class="at">i =</span> <span class="st">"D"</span>, <span class="at">j =</span> <span class="st">"D"</span>, <span class="at">correction =</span> <span class="st">"iso"</span>, </span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a>              <span class="at">nsim =</span> <span class="dv">199</span>, <span class="at">nrank =</span> <span class="dv">5</span>, <span class="at">simulate =</span> rlabel))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Generating 199 simulations by evaluating function  ...
1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114.116.118.120
.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154.156.158.160
.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194.196.198 199.

Done.</code></pre>
</div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-114-1.png" class="img-fluid" width="960"></p>
</div>
</div>
<p>Il semble donc que la mortalité des sapins due à cette épidémie est agrégée spatialement, puisque les arbres situés à proximité l’un de l’autre ont une plus grande probabilité de partager le même statut que prévu par l’hypothèse nulle.</p>
</section>
<section id="références" class="level2">
<h2 class="anchored" data-anchor-id="références">Références</h2>
<p>Fortin, M.-J. et Dale, M.R.T. (2005) <em>Spatial Analysis: A Guide for Ecologists</em>. Cambridge University Press: Cambridge, UK.</p>
<p>Wiegand, T. et Moloney, K.A. (2013) <em>Handbook of Spatial Point-Pattern Analysis in Ecology</em>, CRC Press.</p>
<p>Le jeu de données du dernier exemple est tiré des données de la Forêt d’enseignement et de recherche du Lac Duparquet (FERLD), disponibles sur Dryad en suivant <a href="https://doi.org/10.5061/dryad.tqjq2bvwz">ce lien</a>.</p>
</section>
</section>
<section id="solutions-2" class="level1" data-number="19">
<h1 data-number="19"><span class="header-section-number">19</span> Solutions</h1>
<section id="exercice-1-1" class="level3">
<h3 class="anchored" data-anchor-id="exercice-1-1">Exercice 1</h3>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-115_7bc8effd281fccbd2a1c1e21cd801493">
<div class="sourceCode cell-code" id="cb177"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">envelope</span>(semis_split[[<span class="dv">2</span>]], Kest, <span class="at">correction =</span> <span class="st">"iso"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Generating 99 simulations of CSR  ...
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,  99.

Done.</code></pre>
</div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-115-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Les semis de peuplier semblent significativement agrégés selon la valeur du <span class="math inline">\(K\)</span>.</p>
</section>
<section id="exercice-2-1" class="level3">
<h3 class="anchored" data-anchor-id="exercice-2-1">Exercice 2</h3>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-116_53115f6ed07f7e0e4e7d2c8989998e70">
<div class="sourceCode cell-code" id="cb179"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a>dens_p <span class="ot">&lt;-</span> <span class="fu">density</span>(semis_split[[<span class="dv">2</span>]], <span class="at">sigma =</span> <span class="dv">5</span>)</span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(dens_p)</span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(semis_split[[<span class="dv">2</span>]], <span class="at">add =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-116-1.png" class="img-fluid" width="672"></p>
</div>
<div class="sourceCode cell-code" id="cb180"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a>khet_p <span class="ot">&lt;-</span> <span class="fu">envelope</span>(semis_split[[<span class="dv">2</span>]], Kinhom, <span class="at">sigma =</span> <span class="dv">5</span>, <span class="at">correction =</span> <span class="st">"iso"</span>,</span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a>                   <span class="at">nsim =</span> <span class="dv">199</span>, <span class="at">nrank =</span> <span class="dv">5</span>, <span class="at">simulate =</span> <span class="cf">function</span>(x) <span class="fu">rpoispp</span>(dens_p))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Generating 199 simulations by evaluating function  ...
1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114.116.118.120
.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154.156.158.160
.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194.196.198 199.

Done.</code></pre>
</div>
<div class="sourceCode cell-code" id="cb182"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(khet_p)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-116-2.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Ici, puisque nous estimons la variation de densité à une plus grande échelle, même après avoir tenu compte de cette variation, les semis de peuplier semblent agrégés à petite échelle.</p>
</section>
</section>
<section id="spatial-correlation-fr" class="level1" data-number="20">
<h1 data-number="20"><span class="header-section-number">20</span> Corrélation spatiale d’une variable</h1>
<p>La corrélation entre les mesures d’une variable prises à des points rapprochés est une caractéristique dans de nombreux jeux de données. Ce principe est parfois appelé “première loi de la géographie” et exprimé par la citation de Waldo Tobler: “Everything is related to everything else, but near things are more related than distant things.” (Tout est relié, mais les choses rapprochées le sont davantage que celles éloignées).</p>
<p>En statistique, nous parlons souvent d’<em>autocorrélation</em> pour désigner la corrélation qui existe entre les mesures d’une même variable prises à différents moments (autocorrélation temporelle) ou différents lieux (autocorrélation spatiale).</p>
<section id="dépendance-intrinsèque-ou-induite" class="level2">
<h2 class="anchored" data-anchor-id="dépendance-intrinsèque-ou-induite">Dépendance intrinsèque ou induite</h2>
<p>Il existe deux types fondamentaux de dépendance spatiale sur une variable mesurée <span class="math inline">\(y\)</span>: une dépendance <em>intrinsèque</em> à <span class="math inline">\(y\)</span>, ou une dépendance <em>induite</em> par des variables externes influençant <span class="math inline">\(y\)</span>, qui sont elles-mêmes corrélées dans l’espace.</p>
<p>Par exemple, supposons que l’abondance d’une espèce soit corrélée entre deux sites rapprochés:</p>
<ul>
<li><p>cette dépendance spatiale peut être induite si elle est due à une corrélation spatiale des facteurs d’habitat qui favorisent ou défavorisent l’espèce;</p></li>
<li><p>ou elle peut être intrinsèque si elle est due à la dispersion d’individus entre sites rapprochés.</p></li>
</ul>
<p>Dans plusieurs cas, les deux types de dépendance affectent une variable donnée.</p>
<p>Si la dépendance est simplement induite et que les variables externes qui en sont la cause sont incluses dans le modèle expliquant <span class="math inline">\(y\)</span>, alors les résidus du modèle seront indépendants et nous pouvons utiliser toutes les méthodes déjà vues qui ignorent la dépendance spatiale.</p>
<p>Cependant, si la dépendance est intrinsèque ou due à des influences externes non-mesurées, alors il faudra tenir compte de la dépendance spatiale des résidus dans le modèle.</p>
</section>
<section id="différentes-façons-de-modéliser-les-effets-spatiaux" class="level2">
<h2 class="anchored" data-anchor-id="différentes-façons-de-modéliser-les-effets-spatiaux">Différentes façons de modéliser les effets spatiaux</h2>
<p>Dans cette formation, nous modéliserons directement les corrélations spatiales de nos données. Il est utile de comparer cette approche à d’autres façons d’inclure des aspects spatiaux dans un modèle statistique.</p>
<p>D’abord, nous pourrions inclure des prédicteurs dans le modèle qui représentent la position (ex.: longitude, latitude). De tels prédicteurs peuvent être utiles pour détecter une tendance ou un gradient systématique à grande échelle, que cette tendance soit linéaire ou non (par exemple, avec un modèle additif généralisé).</p>
<p>En contraste à cette approche, les modèles que nous verrons maintenant servent à modéliser une corrélation spatiale dans les fluctuations aléatoires d’une variable (i.e., dans les résidus après avoir enlevé tout effet systématique).</p>
<p>Les modèles mixtes utilisent des effets aléatoires pour représenter la non-indépendance de données sur la base de leur groupement, c’est-à-dire qu’après avoir tenu compte des effets fixes systématiques, les données d’un même groupe sont plus semblables (leur variation résiduelle est corrélée) par rapport aux données de groupes différents. Ces groupes étaient parfois définis selon des critères spatiaux (observations regroupées en sites).</p>
<p>Cependant, dans un contexte d’effet aléatoire de groupe, tous les groupes sont aussi différents les uns des autres, ex.: deux sites à 100 km l’un de l’autre ne sont pas plus ou moins semblables que deux sites distants de 2 km.</p>
<p>Les méthodes que nous verrons ici et dans les prochains parties de la formation nous permettent donc ce modéliser la non-indépendance sur une échelle continue (plus proche = plus corrélé) plutôt que seulement discrète (hiérarchie de groupements).</p>
</section>
</section>
<section id="geostat-models-fr" class="level1" data-number="21">
<h1 data-number="21"><span class="header-section-number">21</span> Modèles géostatistiques</h1>
<p>La géostatistique désigne un groupe de techniques tirant leur origine en sciences de la Terre. Elle s’intéresse à des variables distribuées de façon continue dans l’espace, dont on cherche à estimer la distribution en échantillonnant un nombre de points. Un exemple classique de ces techniques provient du domaine minier, où l’on cherchait à créer une carte de la concentration du minerai sur un site à partir d’échantillons pris à différents points du site.</p>
<p>Pour ces modèles, nous supposerons que <span class="math inline">\(z(x, y)\)</span> est une variable spatiale stationnaire mesurée selon les coordonnées <span class="math inline">\(x\)</span> et <span class="math inline">\(y\)</span>.</p>
<section id="variogramme" class="level2">
<h2 class="anchored" data-anchor-id="variogramme">Variogramme</h2>
<p>Un aspect central de la géostatistique est l’estimation du variogramme <span class="math inline">\(\gamma_z\)</span> de la variable <span class="math inline">\(z\)</span>. Le variogramme est égal à la moitié de l’écart carré moyen entre les valeurs de <span class="math inline">\(z\)</span> pour deux points <span class="math inline">\((x_i, y_i)\)</span> et <span class="math inline">\((x_j, y_j)\)</span> séparés par une distance <span class="math inline">\(h\)</span>.</p>
<p><span class="math display">\[\gamma_z(h) = \frac{1}{2} \text{E} \left[ \left( z(x_i, y_i) - z(x_j, y_j) \right)^2 \right]_{d_{ij} = h}\]</span></p>
<p>Dans cette équation, la fonction <span class="math inline">\(\text{E}\)</span> avec l’indice <span class="math inline">\(d_{ij}=h\)</span> désigne l’espérance statistique (autrement dit, la moyenne) de l’écart au carré entre les valeurs de <span class="math inline">\(z\)</span> pour les points séparés par une distance <span class="math inline">\(h\)</span>.</p>
<p>Si on préfère exprimer l’autocorrélation <span class="math inline">\(\rho_z(h)\)</span> entre mesures de <span class="math inline">\(z\)</span> séparées par une distance <span class="math inline">\(h\)</span>, celle-ci est reliée au variogramme par l’équation:</p>
<p><span class="math display">\[\gamma_z = \sigma_z^2(1 - \rho_z)\]</span> ,</p>
<p>où <span class="math inline">\(\sigma_z^2\)</span> est la variance globale de <span class="math inline">\(z\)</span>.</p>
<p>Notez que <span class="math inline">\(\gamma_z = \sigma_z^2\)</span> si nous sommes à une distance où les mesures de <span class="math inline">\(z\)</span> sont indépendantes, donc <span class="math inline">\(\rho_z = 0\)</span>. Dans ce cas, on voit bien que <span class="math inline">\(\gamma_z\)</span> s’apparente à une variance, même s’il est parfois appelé “semivariogramme” ou “semivariance” en raison du facteur 1/2 dans l’équation ci-dessus.</p>
</section>
<section id="modèles-théoriques-du-variogramme" class="level2">
<h2 class="anchored" data-anchor-id="modèles-théoriques-du-variogramme">Modèles théoriques du variogramme</h2>
<p>Plusieurs modèles paramétriques ont été proposés pour représenter la corrélation spatiale en fonction de la distance entre points d’échantillonnage. Considérons d’abord une corrélation qui diminue de façon exponentielle:</p>
<p><span class="math display">\[\rho_z(h) = e^{-h/r}\]</span></p>
<p>Ici, <span class="math inline">\(\rho_z = 1\)</span> pour <span class="math inline">\(h = 0\)</span> et la corréaltion est multipliée par <span class="math inline">\(1/e \approx 0.37\)</span> pour chaque augmentation de <span class="math inline">\(r\)</span> de la distance. Dans ce contexte, <span class="math inline">\(r\)</span> se nomme la portée (<em>range</em>) de la corrélation.</p>
<p>À partir de l’équation ci-dessus, nous pouvons calculer le variogramme correspondant.</p>
<p><span class="math display">\[\gamma_z(h) = \sigma_z^2 (1 - e^{-h/r})\]</span></p>
<p>Voici une représentation graphique de ce variogramme.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-117_94b4bef8ba36e1b515cfee5fff6c1ebb">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-117-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>En raison de la fonction exponentielle, la valeur de <span class="math inline">\(\gamma\)</span> à des grandes distances s’approche de la variance globale <span class="math inline">\(\sigma_z^2\)</span> sans exactement l’atteindre. Cette asymptote est appelée palier (<em>sill</em>) dans le contexte géostatistique et représentée par le symbole <span class="math inline">\(s\)</span>.</p>
<p>Finalement, il n’est parfois pas réaliste de supposer une corrélation parfaite lorsque la distance tend vers 0, en raison d’une variation possible de <span class="math inline">\(z\)</span> à très petite échelle. On peut ajouter au modèle un effet de pépite (<em>nugget</em>), noté <span class="math inline">\(n\)</span>, pour que <span class="math inline">\(\gamma\)</span> s’approche de <span class="math inline">\(n\)</span> (plutôt que 0) si <span class="math inline">\(h\)</span> tend vers 0. Le terme pépite provient de l’origine minière de ces techniques, où une pépite d’un minerai pourrait être la source d’une variation abrupte de la concentration à petite échelle.</p>
<p>En ajoutant l’effet de pépite, le reste du variogramme est “compressé” pour conserver le même palier, ce qui résulte en l’équation suivante.</p>
<p><span class="math display">\[\gamma_z(h) = n + (s - n) (1 - e^{-h/r})\]</span></p>
<p>Dans le package <em>gstat</em> que nous utiliserons ci-dessous, le terme <span class="math inline">\((s - n)\)</span> est le palier partiel (<em>partial sill</em>, ou <code>psill</code>) pour la partie exponentielle.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-118_616ef9e44728a1524a3df51fd61bde38">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-118-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>En plus du modèle exponentiel, deux autres modèles théoriques courants pour le variogramme sont le modèle gaussien (où la corrélation suit une courbe demi-normale), ainsi que le modèle sphérique (où le variogramme augmente de façon linéaire au départ pour ensuite courber et atteindre le palier à une distance égale à sa portée <span class="math inline">\(r\)</span>). Le modèle sphérique permet donc à la corrélation d’être exactement 0 à grande distance, plutôt que de s’approcher graduellement de zéro dans le cas des autres modèles.</p>
<table class="table">
<colgroup>
<col style="width: 22%">
<col style="width: 35%">
<col style="width: 41%">
</colgroup>
<thead>
<tr class="header">
<th>Modèle</th>
<th><span class="math inline">\(\rho(h)\)</span></th>
<th><span class="math inline">\(\gamma(h)\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Exponentiel</td>
<td><span class="math inline">\(\exp\left(-\frac{h}{r}\right)\)</span></td>
<td><span class="math inline">\(s \left(1 - \exp\left(-\frac{h}{r}\right)\right)\)</span></td>
</tr>
<tr class="even">
<td>Gaussien</td>
<td><span class="math inline">\(\exp\left(-\frac{h^2}{r^2}\right)\)</span></td>
<td><span class="math inline">\(s \left(1 - \exp\left(-\frac{h^2}{r^2}\right)\right)\)</span></td>
</tr>
<tr class="odd">
<td>Sphérique <span class="math inline">\((h &lt; r)\)</span> *</td>
<td><span class="math inline">\(1 - \frac{3}{2}\frac{h}{r} + \frac{1}{2}\frac{h^3}{r^3}\)</span></td>
<td><span class="math inline">\(s \left(\frac{3}{2}\frac{h}{r} - \frac{1}{2}\frac{h^3}{r^3} \right)\)</span></td>
</tr>
</tbody>
</table>
<p>* Pour le modèle sphérique, <span class="math inline">\(\rho = 0\)</span> et <span class="math inline">\(\gamma = s\)</span> si <span class="math inline">\(h \ge r\)</span>.</p>
<div class="cell" data-fig.dim="[9,4]" data-hash="index_cache/html/unnamed-chunk-119_df4e0a7376691267996d3cce69016995">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-119-1.png" class="img-fluid" width="864"></p>
</div>
</div>
</section>
<section id="variogramme-empirique" class="level2">
<h2 class="anchored" data-anchor-id="variogramme-empirique">Variogramme empirique</h2>
<p>Pour estimer <span class="math inline">\(\gamma_z(h)\)</span> à partir de données empiriques, nous devons définir des classes de distance, donc grouper différentes distances dans une marge <span class="math inline">\(\pm \delta\)</span> autour d’une distance <span class="math inline">\(h\)</span>, puis calculer l’écart-carré moyen pour les paires de points dans cette classe de distance.</p>
<p><span class="math display">\[\hat{\gamma_z}(h) = \frac{1}{2 N_{\text{paires}}} \sum \left[ \left( z(x_i, y_i) - z(x_j, y_j) \right)^2 \right]_{d_{ij} = h \pm \delta}\]</span></p>
<p>Nous verrons dans la partie suivante comment estimer un variogramme dans R.</p>
</section>
<section id="modèle-de-régression-avec-corrélation-spatiale" class="level2">
<h2 class="anchored" data-anchor-id="modèle-de-régression-avec-corrélation-spatiale">Modèle de régression avec corrélation spatiale</h2>
<p>L’équation suivante représente une régression linéaire multiple incluant une corrélation spatiale résiduelle:</p>
<p><span class="math display">\[v = \beta_0 + \sum_i \beta_i u_i + z + \epsilon\]</span></p>
<p>Ici, <span class="math inline">\(v\)</span> désigne la variable réponse et <span class="math inline">\(u\)</span> les prédicteurs, pour ne pas confondre avec les coordonnées spatiales <span class="math inline">\(x\)</span> et <span class="math inline">\(y\)</span>.</p>
<p>En plus du résidu <span class="math inline">\(\epsilon\)</span> qui est indépendant entre les observations, le modèle inclut un terme <span class="math inline">\(z\)</span> qui représente la portion spatialement corrélée de la variance résiduelle.</p>
<p>Voici une suggestions d’étapes à suivre pour appliquer ce type de modèle:</p>
<ol type="1">
<li><p>Ajuster le modèle de régression sans corrélation spatiale.</p></li>
<li><p>Vérifier la présence de corrélation spatiale à partir du variogramme empirique des résidus.</p></li>
<li><p>Ajuster un ou plusieurs modèles de régression avec corrélation spatiale et choisir celui qui montre le meilleur ajustement aux données.</p></li>
</ol>
</section>
</section>
<section id="modèles-géostatistiques-dans-r" class="level1" data-number="22">
<h1 data-number="22"><span class="header-section-number">22</span> Modèles géostatistiques dans R</h1>
<p>Le package <em>gstat</em> contient des fonctions liées à la géostatistique. Pour cet exemple, nous utiliserons le jeu de données <code>oxford</code> de ce package, qui contient des mesures de propriétés physiques et chimiques pour 126 échantillons du sol d’un site, ainsi que leurs coordonnées <code>XCOORD</code> et <code>YCOORD</code>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-120_bb070aeb602b5bb93fe5df883fdd6dbe">
<div class="sourceCode cell-code" id="cb183"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(gstat)</span>
<span id="cb183-2"><a href="#cb183-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-3"><a href="#cb183-3" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(oxford)</span>
<span id="cb183-4"><a href="#cb183-4" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(oxford)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>'data.frame':   126 obs. of  22 variables:
 $ PROFILE  : num  1 2 3 4 5 6 7 8 9 10 ...
 $ XCOORD   : num  100 100 100 100 100 100 100 100 100 100 ...
 $ YCOORD   : num  2100 2000 1900 1800 1700 1600 1500 1400 1300 1200 ...
 $ ELEV     : num  598 597 610 615 610 595 580 590 598 588 ...
 $ PROFCLASS: Factor w/ 3 levels "Cr","Ct","Ia": 2 2 2 3 3 2 3 2 3 3 ...
 $ MAPCLASS : Factor w/ 3 levels "Cr","Ct","Ia": 2 3 3 3 3 2 2 3 3 3 ...
 $ VAL1     : num  3 3 4 4 3 3 4 4 4 3 ...
 $ CHR1     : num  3 3 3 3 3 2 2 3 3 3 ...
 $ LIME1    : num  4 4 4 4 4 0 2 1 0 4 ...
 $ VAL2     : num  4 4 5 8 8 4 8 4 8 8 ...
 $ CHR2     : num  4 4 4 2 2 4 2 4 2 2 ...
 $ LIME2    : num  4 4 4 5 5 4 5 4 5 5 ...
 $ DEPTHCM  : num  61 91 46 20 20 91 30 61 38 25 ...
 $ DEP2LIME : num  20 20 20 20 20 20 20 20 40 20 ...
 $ PCLAY1   : num  15 25 20 20 18 25 25 35 35 12 ...
 $ PCLAY2   : num  10 10 20 10 10 20 10 20 10 10 ...
 $ MG1      : num  63 58 55 60 88 168 99 59 233 87 ...
 $ OM1      : num  5.7 5.6 5.8 6.2 8.4 6.4 7.1 3.8 5 9.2 ...
 $ CEC1     : num  20 22 17 23 27 27 21 14 27 20 ...
 $ PH1      : num  7.7 7.7 7.5 7.6 7.6 7 7.5 7.6 6.6 7.5 ...
 $ PHOS1    : num  13 9.2 10.5 8.8 13 9.3 10 9 15 12.6 ...
 $ POT1     : num  196 157 115 172 238 164 312 184 123 282 ...</code></pre>
</div>
</div>
<p>Supposons que nous souhaitons modéliser la concentration de magnésium (<code>MG1</code>), représentée en fonction de la position spatiale dans le graphique suivant.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-121_16158cd54c4487cc58ec9fd8dedf3de7">
<div class="sourceCode cell-code" id="cb185"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb185-2"><a href="#cb185-2" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(oxford, <span class="fu">aes</span>(<span class="at">x =</span> YCOORD, <span class="at">y =</span> XCOORD, <span class="at">size =</span> MG1)) <span class="sc">+</span></span>
<span id="cb185-3"><a href="#cb185-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb185-4"><a href="#cb185-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">coord_fixed</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-121-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Notez que les axes <span class="math inline">\(x\)</span> et <span class="math inline">\(y\)</span> ont été inversés par souci d’espace. La fonction <code>coord_fixed()</code> de <em>ggplot2</em> assure que l’échelle soit la même sur les deux axes, ce qui est utile pour représenter des données spatiales.</p>
<p>Nous voyons tout de suite que ces mesures ont été prises sur une grille de 100 m de côté. Il semble que la concentration de magnésium soit spatialement corrélée, bien qu’il puisse s’agir d’une corrélation induite par une autre variable. Nous savons notamment que la concentration de magnésium est reliée négativement au pH du sol (<code>PH1</code>).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-122_d467da9d444c7554518f3d138f017425">
<div class="sourceCode cell-code" id="cb186"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(oxford, <span class="fu">aes</span>(<span class="at">x =</span> PH1, <span class="at">y =</span> MG1)) <span class="sc">+</span></span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-122-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>La fonction <code>variogram</code> de <em>gstat</em> sert à estimer un variogramme à partir de données empiriques. Voici le résultat obtenu pour la variable <code>MG1</code>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-123_d148763eb057ac91a7c45c4a49d51a00">
<div class="sourceCode cell-code" id="cb187"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a>var_mg <span class="ot">&lt;-</span> <span class="fu">variogram</span>(MG1 <span class="sc">~</span> <span class="dv">1</span>, <span class="at">locations =</span> <span class="sc">~</span> XCOORD <span class="sc">+</span> YCOORD, <span class="at">data =</span> oxford)</span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a>var_mg</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    np     dist    gamma dir.hor dir.ver   id
1  225 100.0000 1601.404       0       0 var1
2  200 141.4214 1950.805       0       0 var1
3  548 215.0773 2171.231       0       0 var1
4  623 303.6283 2422.245       0       0 var1
5  258 360.5551 2704.366       0       0 var1
6  144 400.0000 2948.774       0       0 var1
7  570 427.5569 2994.621       0       0 var1
8  291 500.0000 3402.058       0       0 var1
9  366 522.8801 3844.165       0       0 var1
10 200 577.1759 3603.060       0       0 var1
11 458 619.8400 3816.595       0       0 var1
12  90 670.8204 3345.739       0       0 var1</code></pre>
</div>
</div>
<p>La formule <code>MG1 ~ 1</code> indique qu’aucun prédicteur linéaire n’est inclus dans ce modèle, tandis que l’argument <code>locations</code> indique quelles variables du tableau correspondent aux coordonnées spatiales.</p>
<p>Dans le tableau obtenu, <code>gamma</code> est la valeur du variogramme pour la classe de distance centrée sur <code>dist</code>, tandis que <code>np</code> est le nombre de paires de points dans cette classe. Ici, puisque les points sont situés sur une grille, nous obtenons des classes de distance régulières (ex.: 100 m pour les points voisins sur la grille, 141 m pour les voisins en diagonale, etc.).</p>
<p>Nous nous limitons ici à l’estimation de variogrammes isotropiques, c’est-à-dire que le variogramme dépend seulement de la distance entre les deux points et non de la direction. Bien que nous n’ayons pas le temps de le voir aujourd’hui, il est possible avec <em>gstat</em> d’estimer séparément le variogramme dans différentes directions.</p>
<p>Nous pouvons illustrer le variogramme avec <code>plot</code>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-124_ca0a474a676de6872283aecd1d7057df">
<div class="sourceCode cell-code" id="cb189"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(var_mg, <span class="at">col =</span> <span class="st">"black"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-124-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Si nous voulons estimer la corrélation spatiale résiduelle de <code>MG1</code> après avoir inclus l’effet de <code>PH1</code>, nous pouvons ajouter ce prédicteur à la formule.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-125_11cddc5b7e870cd1cc0cda1a95fac338">
<div class="sourceCode cell-code" id="cb190"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a>var_mg <span class="ot">&lt;-</span> <span class="fu">variogram</span>(MG1 <span class="sc">~</span> PH1, <span class="at">locations =</span> <span class="sc">~</span> XCOORD <span class="sc">+</span> YCOORD, <span class="at">data =</span> oxford)</span>
<span id="cb190-2"><a href="#cb190-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(var_mg, <span class="at">col =</span> <span class="st">"black"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-125-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>En incluant l’effet du pH, la portée de la corrélation spatiale semble diminuer, alors que le plateau est atteint autour de 300 m. Il semble même que le variogramme diminue au-delà de 400 m. En général, nous supposons que la variance entre deux points ne diminue pas avec la distance, à moins d’avoir un patron spatial périodique.</p>
<p>La fonction <code>fit.variogram</code> accepte comme arguments un variogramme estimé à partir des données, ainsi qu’un modèle théorique décrit dans une fonction <code>vgm</code>, puis estime les paramètres de ce modèle en fonction des données. L’ajustement se fait par la méthode des moindres carrés.</p>
<p>Par exemple, <code>vgm("Exp")</code> indique d’ajuster un modèle exponentiel.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-126_03d3f3aa8b262e89fa7d8da65b62e30c">
<div class="sourceCode cell-code" id="cb191"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a>vfit <span class="ot">&lt;-</span> <span class="fu">fit.variogram</span>(var_mg, <span class="fu">vgm</span>(<span class="st">"Exp"</span>))</span>
<span id="cb191-2"><a href="#cb191-2" aria-hidden="true" tabindex="-1"></a>vfit</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  model    psill    range
1   Nug    0.000  0.00000
2   Exp 1951.496 95.11235</code></pre>
</div>
</div>
<p>Il n’y a aucun effet de pépite, car <code>psill = 0</code> pour la partie <code>Nug</code> (<em>nugget</em>) du modèle. La partie exponentielle a un palier à 1951 et une portée de 95 m.</p>
<p>Pour comparer différents modèles, on peut donner un vecteur de noms de modèles à <code>vgm</code>. Dans l’exemple suivant, nous incluons les modèles exponentiel, gaussien (“Gau”) et sphérique (“Sph”).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-127_2f3bfeceade9f4f4dfc5b3eba9eda432">
<div class="sourceCode cell-code" id="cb193"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a>vfit <span class="ot">&lt;-</span> <span class="fu">fit.variogram</span>(var_mg, <span class="fu">vgm</span>(<span class="fu">c</span>(<span class="st">"Exp"</span>, <span class="st">"Gau"</span>, <span class="st">"Sph"</span>)))</span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a>vfit</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  model    psill    range
1   Nug    0.000  0.00000
2   Exp 1951.496 95.11235</code></pre>
</div>
</div>
<p>La fonction nous donne le résultat du modèle le mieux ajusté (plus faible somme des écarts au carré), qui est ici le même modèle exponentiel.</p>
<p>Finalement, nous pouvons superposer le modèle théorique et le variogramme empirique sur un même graphique.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-128_c877e0be691daa5fe18f6d2ba00dfdcd">
<div class="sourceCode cell-code" id="cb195"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(var_mg, vfit, <span class="at">col =</span> <span class="st">"black"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-128-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<section id="régression-avec-corrélation-spatiale" class="level2">
<h2 class="anchored" data-anchor-id="régression-avec-corrélation-spatiale">Régression avec corrélation spatiale</h2>
<p>Nous avons vu ci-dessus que le package <em>gstat</em> permet d’estimer le variogramme des résidus d’un modèle linéaire. Dans notre exemple, la concentration de magnésium était modélisée en fonction du pH, avec des résidus spatialement corrélés.</p>
<p>Un autre outil pour ajuster ce même type de modèle est la fonction <code>gls</code> du package <em>nlme</em>, qui est inclus avec l’installation de R.</p>
<p>Cette fonction applique la méthode des moindres carrés généralisés (<em>generalized least squares</em>) pour ajuster des modèles de régression linéaire lorsque les résidus ne sont pas indépendants ou lorsque la variance résiduelle n’est pas la même pour toutes les observations. Comme les estimés des coefficients dépendent de l’estimé des corrélations entre les résidus et que ces derniers dépendent eux-mêmes des coefficients, le modèle est ajusté par un algorithme itératif:</p>
<ol type="1">
<li><p>On ajuste un modèle de régression linéaire classique (sans corrélation) pour obtenir des résidus.</p></li>
<li><p>On ajuste le modèle de corrélation spatiale (variogramme) avec ses résidus.</p></li>
<li><p>On ré-estime les coefficients de la régression en tenant compte maintenant des corrélations.</p></li>
</ol>
<p>Les étapes 2 et 3 sont répétées jusqu’à ce que les estimés soient stables à une précision voulue.</p>
<p>Voici l’application de cette méthode au même modèle pour la concentration de magnésium dans le jeu de données <code>oxford</code>. Dans l’argument <code>correlation</code> de <code>gls</code>, nous spécifions un modèle de corrélation exponentielle en fonction de nos coordonnées spatiales et indiquons que nous voulons aussi estimer un effet de pépite.</p>
<p>En plus de la corrélation exponentielle <code>corExp</code>, la fonction <code>gls</code> peut aussi estimer un modèle gaussien (<code>corGaus</code>) ou sphérique (<code>corSpher</code>).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-129_c4131310eb8ea32e0ccf4187e678e982">
<div class="sourceCode cell-code" id="cb196"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(nlme)</span>
<span id="cb196-2"><a href="#cb196-2" aria-hidden="true" tabindex="-1"></a>gls_mg <span class="ot">&lt;-</span> <span class="fu">gls</span>(MG1 <span class="sc">~</span> PH1, oxford, </span>
<span id="cb196-3"><a href="#cb196-3" aria-hidden="true" tabindex="-1"></a>              <span class="at">correlation =</span> <span class="fu">corExp</span>(<span class="at">form =</span> <span class="sc">~</span> XCOORD <span class="sc">+</span> YCOORD, <span class="at">nugget =</span> <span class="cn">TRUE</span>))</span>
<span id="cb196-4"><a href="#cb196-4" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(gls_mg)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Generalized least squares fit by REML
  Model: MG1 ~ PH1 
  Data: oxford 
      AIC      BIC   logLik
  1278.65 1292.751 -634.325

Correlation Structure: Exponential spatial correlation
 Formula: ~XCOORD + YCOORD 
 Parameter estimate(s):
      range      nugget 
478.0322964   0.2944753 

Coefficients:
               Value Std.Error   t-value p-value
(Intercept) 391.1387  50.42343  7.757084       0
PH1         -41.0836   6.15662 -6.673079       0

 Correlation: 
    (Intr)
PH1 -0.891

Standardized residuals:
       Min         Q1        Med         Q3        Max 
-2.1846957 -0.6684520 -0.3687813  0.4627580  3.1918604 

Residual standard error: 53.8233 
Degrees of freedom: 126 total; 124 residual</code></pre>
</div>
</div>
<p>Pour comparer ce résultat au variogramme ajusté ci-dessus, il faut transformer les paramètres donnés par <code>gls</code>. La portée (range) a le même sens dans les deux cas et correspond à 478 m pour le résultat de <code>gls</code>. La variance globale des résidus est le carré de <code>Residual standard error</code>. L’effet de pépite ici (0.294) est exprimé comme fraction de cette variance. Finalement, pour obtenir le palier partiel de la partie exponentielle, il faut soustraire l’effet de pépite de la variance totale.</p>
<p>Après avoir réalisé ces calculs, nous pouvons donner ces paramètres à la fonction <code>vgm</code> de <em>gstat</em> pour superposer ce variogramme estimé par <code>gls</code> à notre variogramme des résidus du modèle linéaire classique.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-130_1b4118890801a03647e2f78590f222be">
<div class="sourceCode cell-code" id="cb198"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a>gls_range <span class="ot">&lt;-</span> <span class="dv">478</span></span>
<span id="cb198-2"><a href="#cb198-2" aria-hidden="true" tabindex="-1"></a>gls_var <span class="ot">&lt;-</span> <span class="fl">53.823</span><span class="sc">^</span><span class="dv">2</span></span>
<span id="cb198-3"><a href="#cb198-3" aria-hidden="true" tabindex="-1"></a>gls_nugget <span class="ot">&lt;-</span> <span class="fl">0.294</span> <span class="sc">*</span> gls_var</span>
<span id="cb198-4"><a href="#cb198-4" aria-hidden="true" tabindex="-1"></a>gls_psill <span class="ot">&lt;-</span> gls_var <span class="sc">-</span> gls_nugget</span>
<span id="cb198-5"><a href="#cb198-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-6"><a href="#cb198-6" aria-hidden="true" tabindex="-1"></a>gls_vgm <span class="ot">&lt;-</span> <span class="fu">vgm</span>(<span class="st">"Exp"</span>, <span class="at">psill =</span> gls_psill, <span class="at">range =</span> gls_range, <span class="at">nugget =</span> gls_nugget)</span>
<span id="cb198-7"><a href="#cb198-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-8"><a href="#cb198-8" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(var_mg, gls_vgm, <span class="at">col =</span> <span class="st">"black"</span>, <span class="at">ylim =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">4000</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-130-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Est-ce que le modèle est moins bien ajusté aux données ici? En fait, ce variogramme empirique représenté par les points avait été obtenu à partir des résidus du modèle linéaire ignorant la corrélation spatiale, donc c’est un estimé biaisé des corrélations spatiales réelles. La méthode est quand même adéquate pour vérifier rapidement s’il y a présence de corrélations spatiales. Toutefois, pour ajuster simultanément les coefficients de la régression et les paramètres de corrélation spatiale, l’approche des moindres carrés généralisés (GLS) est préférable et produira des estimés plus justes.</p>
<p>Finalement, notez que le résultat du modèle <code>gls</code> donne aussi l’AIC, que nous pouvons utiliser pour comparer l’ajustement de différents modèles (avec différents prédicteurs ou différentes formes de corrélation spatiale).</p>
</section>
<section id="exercice" class="level2">
<h2 class="anchored" data-anchor-id="exercice">Exercice</h2>
<p>Le fichier <a href="data/bryo_belg.csv">bryo_belg.csv</a> est adapté des données de l’étude:</p>
<blockquote class="blockquote">
<p>Neyens, T., Diggle, P.J., Faes, C., Beenaerts, N., Artois, T. et Giorgi, E. (2019) Mapping species richness using opportunistic samples: a case study on ground-floor bryophyte species richness in the Belgian province of Limburg. <em>Scientific Reports</em> 9, 19122. https://doi.org/10.1038/s41598-019-55593-x</p>
</blockquote>
<p>Ce tableau de données indique la richesse spécifique des bryophytes au sol (<em>richness</em>) pour différents points d’échantillonnage de la province belge de Limbourg, avec leur position <em>(x, y)</em> en km, en plus de l’information sur la proportion de forêts (<em>forest</em>) et de milieux humides (<em>wetland</em>) dans une cellule de 1 km<span class="math inline">\(^2\)</span> contenant le point d’échantillonnage.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-131_9e78f0ec8229f51b3dcf95f72b18a23a">
<div class="sourceCode cell-code" id="cb199"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a>bryo_belg <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">"data/bryo_belg.csv"</span>)</span>
<span id="cb199-2"><a href="#cb199-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(bryo_belg)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  richness    forest   wetland        x        y
1        9 0.2556721 0.5036614 228.9516 220.8869
2        6 0.6449114 0.1172068 227.6714 219.8613
3        5 0.5039905 0.6327003 228.8252 220.1073
4        3 0.5987329 0.2432942 229.2775 218.9035
5        2 0.7600775 0.1163538 209.2435 215.2414
6       10 0.6865434 0.0000000 210.4142 216.5579</code></pre>
</div>
</div>
<p>Pour cet exercice, nous utiliserons la racine carrée de la richesse spécifique comme variable réponse. La transformation racine carrée permet souvent d’homogénéiser la variance des données de comptage afin d’y appliquer une régression linéaire.</p>
<ol type="a">
<li><p>Ajustez un modèle linéaire de la richesse spécifique transformée en fonction de la fraction de forêt et de milieux humides, sans tenir compte des corrélations spatiales. Quel est l’effet des deux prédicteurs selon ce modèle?</p></li>
<li><p>Calculez le variogramme empirique des résidus du modèle en (a). Semble-t-il y avoir une corrélation spatiale entre les points?</p></li>
</ol>
<p><em>Note</em>: L’argument <code>cutoff</code> de la fonction <code>variogram</code> spécifie la distance maximale à laquelle le variogramme est calculé. Vous pouvez ajuster manuellement cette valeur pour bien voir le palier.</p>
<ol start="3" type="a">
<li><p>Ré-ajustez le modèle linéaire en (a) avec la fonction <code>gls</code> du package <em>nlme</em>, en essayant différents types de corrélations spatiales (exponentielle, gaussienne, sphérique). Comparez les modèles (incluant celui sans corrélation spatiale) avec l’AIC.</p></li>
<li><p>Quel est l’effet de la fraction de forêts et de milieux humides selon le modèle en (c)? Expliquez les différences entre les conclusions de ce modèle et du modèle en (a).</p></li>
</ol>
</section>
</section>
<section id="krigeage" class="level1" data-number="23">
<h1 data-number="23"><span class="header-section-number">23</span> Krigeage</h1>
<p>Tel que mentionné précédemment, une application courante des modèles géostatistiques consiste à prédire la valeur de la variable de réponse à des points non-échantillonnés, une forme d’interpolation spatiale appelée krigeage (<em>kriging</em>).</p>
<p>Il existe trois principaux types de krigeage selon les suppositions faites au sujet de la variable réponse:</p>
<ul>
<li><p>Krigeage ordinaire: variable stationnaire avec une moyenne inconnue.</p></li>
<li><p>Krigeage simple: Variable stationnaire avec une moyenne connue.</p></li>
<li><p>Krigeage universel: Variable dont la tendance est donnée par un modèle linéaire ou non linéaire.</p></li>
</ul>
<p>Pour toutes les méthodes de krigeage, les prédictions à un nouveau point sont une moyenne pondérée des valeurs à des points connus. Ces pondérations sont choisies de manière à ce que le krigeage fournisse la meilleure prédiction linéaire non biaisée de la variable de réponse, si les hypothèses du modèle (en particulier le variogramme) sont correctes. C’est-à-dire que, parmi toutes les prédictions non biaisées possibles, les poids sont choisis de manière à donner l’erreur quadratique moyenne minimale. Le krigeage fournit également une estimation de l’incertitude de chaque prédiction.</p>
<p>Bien que nous ne présentions pas ici les équations détaillées du krigeage, les poids dépendent à la fois des corrélations (estimées par le variogramme) entre les points échantillonnés et le nouveau point, ainsi que des corrélations entre les points échantillonnés eux-mêmes. Autrement dit, les points échantillonnés proches du nouveau point ont plus de poids, mais les points échantillonnés isolés ont également plus de poids, car les points échantillonnés proches les uns des autres fournissent une informations redondante.</p>
<p>Le krigeage est une méthode d’interpolation, donc la prédiction à un point échantillonné sera toujours égale à la valeur mesurée (la variable est supposée être mesurée sans erreur, elle varie seulement entre les points). Cependant, en présence d’un effet de pépite, tout petit déplacement par rapport à l’endroit échantillonné présentera une variabilité en fonction de la pépite.</p>
<p>Dans l’exemple ci-dessous, nous générons un nouvel ensemble de données composé de coordonnées (x, y) générées de façon aléatoire dans la zone d’étude ainsi que des valeurs de pH générées de façon aléatoire sur la base des données <code>oxford</code>. Nous appliquons ensuite la fonction <code>krige</code> pour prédire les valeurs de magnésium à ces nouveaux points. Notez que nous spécifions le variogramme dérivé des résultats du <code>gls</code> dans l’argument <code>model</code> de <code>krige</code>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-132_027c26268d41b1f7157bb584e297db99">
<div class="sourceCode cell-code" id="cb201"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">14</span>)</span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a>new_points <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">XCOORD =</span> <span class="fu">runif</span>(<span class="dv">100</span>, <span class="fu">min</span>(oxford<span class="sc">$</span>XCOORD), <span class="fu">max</span>(oxford<span class="sc">$</span>XCOORD)),</span>
<span id="cb201-4"><a href="#cb201-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">YCOORD =</span> <span class="fu">runif</span>(<span class="dv">100</span>, <span class="fu">min</span>(oxford<span class="sc">$</span>YCOORD), <span class="fu">max</span>(oxford<span class="sc">$</span>YCOORD)),</span>
<span id="cb201-5"><a href="#cb201-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">PH1 =</span> <span class="fu">rnorm</span>(<span class="dv">100</span>, <span class="fu">mean</span>(oxford<span class="sc">$</span>PH1), <span class="fu">sd</span>(oxford<span class="sc">$</span>PH1))</span>
<span id="cb201-6"><a href="#cb201-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb201-7"><a href="#cb201-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-8"><a href="#cb201-8" aria-hidden="true" tabindex="-1"></a>pred <span class="ot">&lt;-</span> <span class="fu">krige</span>(MG1 <span class="sc">~</span> PH1, <span class="at">locations =</span> <span class="sc">~</span> XCOORD <span class="sc">+</span> YCOORD, <span class="at">data =</span> oxford,</span>
<span id="cb201-9"><a href="#cb201-9" aria-hidden="true" tabindex="-1"></a>              <span class="at">newdata =</span> new_points, <span class="at">model =</span> gls_vgm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[using universal kriging]</code></pre>
</div>
<div class="sourceCode cell-code" id="cb203"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(pred)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    XCOORD    YCOORD var1.pred var1.var
1 227.0169  162.1185  47.13065 1269.002
2 418.9136  465.9013  79.68437 1427.269
3 578.5943 2032.7477  60.30539 1264.471
4 376.2734 1530.7193 127.22366 1412.875
5 591.5336  421.6290 105.88124 1375.485
6 355.7369  404.3378 127.73055 1250.114</code></pre>
</div>
</div>
<p>Le résultat de <code>krige</code> comprend les nouvelles coordonnées du point, la prédiction de la variable <code>var1.pred</code> ainsi que sa variance estimée <code>var1.var</code>. Dans le graphique ci-dessous, nous montrons les prédictions moyennes de MG1 à partir du krigeage (triangles) ainsi que les mesures (cercles).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-133_1b4299bab8f6eba5fe4ea3b112a66235">
<div class="sourceCode cell-code" id="cb205"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a>pred<span class="sc">$</span>MG1 <span class="ot">&lt;-</span> pred<span class="sc">$</span>var1.pred</span>
<span id="cb205-2"><a href="#cb205-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb205-3"><a href="#cb205-3" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(oxford, <span class="fu">aes</span>(<span class="at">x =</span> YCOORD, <span class="at">y =</span> XCOORD, <span class="at">color =</span> MG1)) <span class="sc">+</span></span>
<span id="cb205-4"><a href="#cb205-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb205-5"><a href="#cb205-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>(<span class="at">data =</span> pred, <span class="at">shape =</span> <span class="dv">17</span>, <span class="at">size =</span> <span class="dv">2</span>) <span class="sc">+</span></span>
<span id="cb205-6"><a href="#cb205-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">coord_fixed</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-133-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>La moyenne et la variance estimées par krigeage peuvent être utilisées pour simuler les valeurs possibles de la variable à chaque nouveau point, conditionnellement aux valeurs échantillonnées. Dans l’exemple ci-dessous, nous avons effectué 4 simulations conditionnelles en ajoutant l’argument <code>nsim = 4</code> à la même instruction <code>krige</code>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-134_9a008c1eb0ae0b7b22fbfc9aa9ca64ba">
<div class="sourceCode cell-code" id="cb206"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true" tabindex="-1"></a>sim_mg <span class="ot">&lt;-</span> <span class="fu">krige</span>(MG1 <span class="sc">~</span> PH1, <span class="at">locations =</span> <span class="sc">~</span> XCOORD <span class="sc">+</span> YCOORD, <span class="at">data =</span> oxford,</span>
<span id="cb206-2"><a href="#cb206-2" aria-hidden="true" tabindex="-1"></a>                <span class="at">newdata =</span> new_points, <span class="at">model =</span> gls_vgm, <span class="at">nsim =</span> <span class="dv">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>drawing 4 GLS realisations of beta...
[using conditional Gaussian simulation]</code></pre>
</div>
<div class="sourceCode cell-code" id="cb208"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(sim_mg)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    XCOORD    YCOORD       sim1      sim2      sim3      sim4
1 227.0169  162.1185   9.638739  34.53159  46.08685  77.86376
2 418.9136  465.9013  60.029144  20.17179  76.46333  59.57924
3 578.5943 2032.7477 100.791412  77.47887  73.50058  59.40279
4 376.2734 1530.7193 112.615730 150.96664  78.76125 146.83928
5 591.5336  421.6290  70.925240  72.85522 153.90610 126.63758
6 355.7369  404.3378 161.608032 118.93640 134.45695 142.20074</code></pre>
</div>
</div>
<div class="cell" data-fig.dim="[10,5]" data-hash="index_cache/html/unnamed-chunk-135_3de9cc48384c950ead05df0c82810126">
<div class="sourceCode cell-code" id="cb210"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyr)</span>
<span id="cb210-2"><a href="#cb210-2" aria-hidden="true" tabindex="-1"></a>sim_mg <span class="ot">&lt;-</span> <span class="fu">pivot_longer</span>(sim_mg, <span class="at">cols =</span> <span class="fu">c</span>(sim1, sim2, sim3, sim4), </span>
<span id="cb210-3"><a href="#cb210-3" aria-hidden="true" tabindex="-1"></a>                       <span class="at">names_to =</span> <span class="st">"sim"</span>, <span class="at">values_to =</span> <span class="st">"MG1"</span>)</span>
<span id="cb210-4"><a href="#cb210-4" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(sim_mg, <span class="fu">aes</span>(<span class="at">x =</span> YCOORD, <span class="at">y =</span> XCOORD, <span class="at">color =</span> MG1)) <span class="sc">+</span></span>
<span id="cb210-5"><a href="#cb210-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb210-6"><a href="#cb210-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">coord_fixed</span>() <span class="sc">+</span></span>
<span id="cb210-7"><a href="#cb210-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">facet_wrap</span>(<span class="sc">~</span> sim)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-135-1.png" class="img-fluid" width="960"></p>
</div>
</div>
</section>
<section id="solutions-3" class="level1" data-number="24">
<h1 data-number="24"><span class="header-section-number">24</span> Solutions</h1>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-136_e5d36a60c009aa3f50973208ae8f2f5b">
<div class="sourceCode cell-code" id="cb211"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb211-1"><a href="#cb211-1" aria-hidden="true" tabindex="-1"></a>bryo_lm <span class="ot">&lt;-</span> <span class="fu">lm</span>(<span class="fu">sqrt</span>(richness) <span class="sc">~</span> forest <span class="sc">+</span> wetland, <span class="at">data =</span> bryo_belg)</span>
<span id="cb211-2"><a href="#cb211-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(bryo_lm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = sqrt(richness) ~ forest + wetland, data = bryo_belg)

Residuals:
    Min      1Q  Median      3Q     Max 
-1.8847 -0.4622  0.0545  0.4974  2.3116 

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)  2.34159    0.08369  27.981  &lt; 2e-16 ***
forest       1.11883    0.13925   8.034 9.74e-15 ***
wetland     -0.59264    0.17216  -3.442 0.000635 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 0.7095 on 417 degrees of freedom
Multiple R-squared:  0.2231,    Adjusted R-squared:  0.2193 
F-statistic: 59.86 on 2 and 417 DF,  p-value: &lt; 2.2e-16</code></pre>
</div>
</div>
<p>La proportion de forêts a un effet positif significatif et la proportion de milieux humides a un effet négatif significatif sur la richesse des bryophytes.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-137_ec3dcc9a8a06613df18c98b96808666b">
<div class="sourceCode cell-code" id="cb213"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">variogram</span>(<span class="fu">sqrt</span>(richness) <span class="sc">~</span> forest <span class="sc">+</span> wetland, <span class="at">locations =</span> <span class="sc">~</span> x <span class="sc">+</span> y,</span>
<span id="cb213-2"><a href="#cb213-2" aria-hidden="true" tabindex="-1"></a>               <span class="at">data =</span> bryo_belg, <span class="at">cutoff =</span> <span class="dv">50</span>), <span class="at">col =</span> <span class="st">"black"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-137-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Le variogramme augmente au moins jusqu’à une distance de 40 km, il semble donc y avoir des corrélations spatiales dans les résidus du modèle.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-138_7c7f1feca29413974ebbf1ffe2ed08c2">
<div class="sourceCode cell-code" id="cb214"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a>bryo_exp <span class="ot">&lt;-</span> <span class="fu">gls</span>(<span class="fu">sqrt</span>(richness) <span class="sc">~</span> forest <span class="sc">+</span> wetland, <span class="at">data =</span> bryo_belg,</span>
<span id="cb214-2"><a href="#cb214-2" aria-hidden="true" tabindex="-1"></a>                <span class="at">correlation =</span> <span class="fu">corExp</span>(<span class="at">form =</span> <span class="sc">~</span> x <span class="sc">+</span> y, <span class="at">nugget =</span> <span class="cn">TRUE</span>))</span>
<span id="cb214-3"><a href="#cb214-3" aria-hidden="true" tabindex="-1"></a>bryo_gaus <span class="ot">&lt;-</span> <span class="fu">gls</span>(<span class="fu">sqrt</span>(richness) <span class="sc">~</span> forest <span class="sc">+</span> wetland, <span class="at">data =</span> bryo_belg,</span>
<span id="cb214-4"><a href="#cb214-4" aria-hidden="true" tabindex="-1"></a>                <span class="at">correlation =</span> <span class="fu">corGaus</span>(<span class="at">form =</span> <span class="sc">~</span> x <span class="sc">+</span> y, <span class="at">nugget =</span> <span class="cn">TRUE</span>))</span>
<span id="cb214-5"><a href="#cb214-5" aria-hidden="true" tabindex="-1"></a>bryo_spher <span class="ot">&lt;-</span> <span class="fu">gls</span>(<span class="fu">sqrt</span>(richness) <span class="sc">~</span> forest <span class="sc">+</span> wetland, <span class="at">data =</span> bryo_belg,</span>
<span id="cb214-6"><a href="#cb214-6" aria-hidden="true" tabindex="-1"></a>                  <span class="at">correlation =</span> <span class="fu">corSpher</span>(<span class="at">form =</span> <span class="sc">~</span> x <span class="sc">+</span> y, <span class="at">nugget =</span> <span class="cn">TRUE</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-139_8c08d48b4eaefbe6cc8947569ca14603">
<div class="sourceCode cell-code" id="cb215"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true" tabindex="-1"></a><span class="fu">AIC</span>(bryo_lm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 908.6358</code></pre>
</div>
<div class="sourceCode cell-code" id="cb217"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb217-1"><a href="#cb217-1" aria-hidden="true" tabindex="-1"></a><span class="fu">AIC</span>(bryo_exp)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 867.822</code></pre>
</div>
<div class="sourceCode cell-code" id="cb219"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a><span class="fu">AIC</span>(bryo_gaus)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 870.9592</code></pre>
</div>
<div class="sourceCode cell-code" id="cb221"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb221-1"><a href="#cb221-1" aria-hidden="true" tabindex="-1"></a><span class="fu">AIC</span>(bryo_spher)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 866.9117</code></pre>
</div>
</div>
<p>Le modèle sphérique a l’AIC le plus faible.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-140_6c6c64ec797a7b31d531a376b94c8dbc">
<div class="sourceCode cell-code" id="cb223"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb223-1"><a href="#cb223-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(bryo_spher)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Generalized least squares fit by REML
  Model: sqrt(richness) ~ forest + wetland 
  Data: bryo_belg 
       AIC      BIC    logLik
  866.9117 891.1102 -427.4558

Correlation Structure: Spherical spatial correlation
 Formula: ~x + y 
 Parameter estimate(s):
     range     nugget 
43.1727664  0.6063187 

Coefficients:
                 Value Std.Error   t-value p-value
(Intercept)  2.0368769 0.2481636  8.207800   0.000
forest       0.6989844 0.1481690  4.717481   0.000
wetland     -0.2441130 0.1809118 -1.349348   0.178

 Correlation: 
        (Intr) forest
forest  -0.251       
wetland -0.235  0.241

Standardized residuals:
        Min          Q1         Med          Q3         Max 
-1.75204183 -0.06568688  0.61415597  1.15240370  3.23322743 

Residual standard error: 0.7998264 
Degrees of freedom: 420 total; 417 residual</code></pre>
</div>
</div>
<p>La magnitude des deux effets est moins importante et l’effet des milieux humides n’est plus significatif. Comme c’est le cas pour d’autres types de résidus non indépendants, la “taille effective” de l’échantillon est ici inférieure au nombre de points, car des points proches les uns des autres fournissent une information redondante. Par conséquent, la relation entre les prédicteurs et la réponse est moins claire que celle donnée par le modèle supposant que tous ces points étaient indépendants.</p>
<p>Notez que les résultats pour les trois modèles <code>gls</code> sont assez similaires, donc le choix d’inclure des corrélations spatiales était plus important que la forme exacte supposée pour le variogramme.</p>
</section>
<section id="areal-data-fr" class="level1" data-number="25">
<h1 data-number="25"><span class="header-section-number">25</span> Données aréales</h1>
<p>Les données aréales sont des variables mesurées pour des régions de l’espace; ces régions sont définies par des polygones. Ce type de données est plus courant en sciences sociales, en géographie humaine et en épidémiologie, où les données sont souvent disponibles à l’échelle de divisions administratives du territoire.</p>
<p>Ce type de données apparaît aussi fréquemment dans la gestion des ressources naturelles. Par exemple, la carte suivante montre les unités d’aménagement forestier du Ministère de la Forêts, de la Faune et des Parcs du Québec.</p>
<p><img src="images/cartes_unites.png" class="img-fluid"></p>
<p>Supposons qu’une certaine variable soit disponible au niveau de ces divisions du territoire. Comment pouvons-nous modéliser la corrélation spatiale entre les unités qui sont spatialement rapprochées?</p>
<p>Une option serait d’appliquer les méthodes géostatistiques vues précédemment, en calculant par exemple la distance entre les centres des polygones.</p>
<p>Une autre option, qui est davantage privilégiée pour les données aréales, consiste à définir un réseau où chaque région est connectée aux régions voisines par un lien. On suppose ensuite que les variables sont directement corrélées entre régions voisines seulement. (Notons toutefois que les corrélations directes entre voisins immédiats génèrent aussi des corrélations indirectes pour une chaîne de voisins.)</p>
<p>Dans ce type de modèle, la corrélation n’est pas nécessairement la même d’un lien à un autre. Dans ce cas, chaque lien du réseau peut être associé à un <em>poids</em> représentant son importance pour la corrélation spatiale. Nous représentons ces poids par une matrice <span class="math inline">\(W\)</span> où <span class="math inline">\(w_{ij}\)</span> est le poids du lien entre les régions <span class="math inline">\(i\)</span> et <span class="math inline">\(j\)</span>. Une région n’a pas de lien avec elle-même, donc <span class="math inline">\(w_{ii} = 0\)</span>.</p>
<p>Un choix simple pour <span class="math inline">\(W\)</span> consiste à assigner un poids égal à 1 si les régions sont voisines, sinon 0 (poids binaires).</p>
<p>Outre les divisions du territoire en polygones, un autre exemple de données aréales consiste en une grille où la variable est compilée pour chaque cellule de la grille. Dans ce cas, une cellule a généralement 4 ou 8 cellules voisines, selon que les diagonales soient incluses ou non.</p>
</section>
<section id="moran-i-fr" class="level1" data-number="26">
<h1 data-number="26"><span class="header-section-number">26</span> Indice de Moran</h1>
<p>Avant de discuter des modèles d’autocorrélation spatiale, nous présentons l’indice <span class="math inline">\(I\)</span> de Moran, qui permet de tester si une corrélation significative est présente entre régions voisines.</p>
<p>L’indice de Moran est un coefficient d’autocorrélation spatiale des <span class="math inline">\(z\)</span>, pondéré par les poids <span class="math inline">\(w_{ij}\)</span>. Il prend donc des valeurs entre -1 et 1.</p>
<p><span class="math display">\[I = \frac{N}{\sum_i \sum_j w_{ij}} \frac{\sum_i \sum_j w_{ij} (z_i - \bar{z}) (z_j - \bar{z})}{\sum_i (z_i - \bar{z})^2}\]</span></p>
<p>Dans cette équation, nous reconnaissons l’expression d’une corrélation, soit le produit des écarts à la moyenne de deux variables <span class="math inline">\(z_i\)</span> et <span class="math inline">\(z_j\)</span>, divisé par le produit de leurs écarts-types (qui est le même, donc on obtient la variance). La contribution de chaque paire <span class="math inline">\((i, j)\)</span> est multipliée par son poids <span class="math inline">\(w_{ij}\)</span> et le terme à gauche (le nombre de régions <span class="math inline">\(N\)</span> divisé par la somme des poids) assure que le résultat soit borné entre -1 et 1.</p>
<p>Puisque la distribution de <span class="math inline">\(I\)</span> est connue en l’absence d’autocorrélation spatiale, cette statistique permet de tester l’hypothèse nulle selon laquelle il n’y a pas de corrélation spatiale entre régions voisines.</p>
<p>Bien que nous ne verrons pas d’exemple dans ce cours-ci, l’indice de Moran peut aussi être appliqué aux données ponctuelles. Dans ce cas, on divise les paires de points en classes de distance et on calcule <span class="math inline">\(I\)</span> pour chaque classe de distance; le poids <span class="math inline">\(w_{ij} = 1\)</span> si la distance entre <span class="math inline">\(i\)</span> et <span class="math inline">\(j\)</span> se trouve dans la classe de distance voulue, 0 autrement.</p>
</section>
<section id="spatial-autoreg-fr" class="level1" data-number="27">
<h1 data-number="27"><span class="header-section-number">27</span> Modèles d’autorégression spatiale</h1>
<p>Rappelons-nous la formule pour une régression linéaire avec dépendance spatiale:</p>
<p><span class="math display">\[v = \beta_0 + \sum_i \beta_i u_i + z + \epsilon\]</span></p>
<p>où <span class="math inline">\(z\)</span> est la portion de la variance résiduelle qui est spatialement corrélée.</p>
<p>Il existe deux principaux types de modèles autorégressifs pour représenter la dépendance spatiale de <span class="math inline">\(z\)</span>: l’autorégression conditionnelle (CAR) et l’autorégression simultanée (SAR).</p>
<section id="autorégression-conditionnelle-car" class="level2">
<h2 class="anchored" data-anchor-id="autorégression-conditionnelle-car">Autorégression conditionnelle (CAR)</h2>
<p>Dans le modèle d’autorégression conditionnelle, la valeur de <span class="math inline">\(z_i\)</span> pour la région <span class="math inline">\(i\)</span> suit une distribution normale: sa moyenne dépend de la valeur <span class="math inline">\(z_j\)</span> des régions voisines, multipliée par le poids <span class="math inline">\(w_{ij}\)</span> et un coefficient de corrélation <span class="math inline">\(\rho\)</span>; son écart-type <span class="math inline">\(\sigma_{z_i}\)</span> peut varier d’une région à l’autre.</p>
<p><span class="math display">\[z_i \sim \text{N}\left(\sum_j \rho w_{ij} z_j,\sigma_{z_i} \right)\]</span></p>
<p>Dans ce modèle, si <span class="math inline">\(w_{ij}\)</span> est une matrice binaire (0 pour les non-voisins, 1 pour les voisins), alors <span class="math inline">\(\rho\)</span> est le coefficient de corrélation partielle entre régions voisines. Cela est semblable à un modèle autorégressif d’ordre 1 dans le contexte de séries temporelles, où le coefficient d’autorégression indique la corrélation partielle.</p>
</section>
<section id="autorégression-simultanée-sar" class="level2">
<h2 class="anchored" data-anchor-id="autorégression-simultanée-sar">Autorégression simultanée (SAR)</h2>
<p>Dans le modèle d’autorégression simultanée, la valeur de <span class="math inline">\(z_i\)</span> est donnée directement par la somme de contributions des valeurs voisines <span class="math inline">\(z_j\)</span>, multipliées par <span class="math inline">\(\rho w_{ij}\)</span>, avec un résidu indépendant <span class="math inline">\(\nu_i\)</span> d’écart-type <span class="math inline">\(\sigma_z\)</span>.</p>
<p><span class="math display">\[z_i = \sum_j \rho w_{ij} z_j + \nu_i\]</span></p>
<p>À première vue, cela ressemble à un modèle autorégressif temporel. Il existe cependant une différence conceptuelle importante. Pour les modèles temporels, l’influence causale est dirigée dans une seule direction: <span class="math inline">\(v(t-2)\)</span> affecte <span class="math inline">\(v(t-1)\)</span> qui affecte ensuite <span class="math inline">\(v(t)\)</span>. Pour un modèle spatial, chaque <span class="math inline">\(z_j\)</span> qui affecte <span class="math inline">\(z_i\)</span> dépend à son tour de <span class="math inline">\(z_i\)</span>. Ainsi, pour déterminer la distribution conjointe des <span class="math inline">\(z\)</span>, il faut résoudre simultanément (d’où le nom du modèle) un système d’équations.</p>
<p>Pour cette raison, même si ce modèle ressemble à la formule du modèle conditionnel (CAR), les solutions des deux modèles diffèrent et dans le cas du SAR, le coefficient <span class="math inline">\(\rho\)</span> n’est pas directement égal à la corrélation partielle due à chaque région voisine.</p>
<p>Pour plus de détails sur les aspects mathématiques de ces modèles, vous pouvez consulter l’article de Ver Hoef et al.&nbsp;(2018) suggéré en référence.</p>
<p>Pour l’instant, nous considérerons les SAR et les CAR comme deux types de modèles possibles pour représenter une corrélation spatiale sur un réseau. Nous pouvons toujours ajuster plusieurs modèles et les comparer avec l’AIC pour choisir la meilleure forme de la corrélation ou la meilleure matrice de poids.</p>
<p>Les modèles CAR et SAR partagent un avantage sur les modèles géostatistiques au niveau de l’efficacité. Dans un modèle géostatistique, les corrélations spatiales sont définies entre chaque paire de points, même si elles deviennent négligeables lorsque la distance augmente. Pour un modèle CAR ou SAR, seules les régions voisines contribuent et la plupart des poids sont égaux à 0, ce qui rend ces modèles plus rapides à ajuster qu’un modèle géostatistique lorsque les données sont massives.</p>
</section>
</section>
<section id="analysis-areal-fr" class="level1" data-number="28">
<h1 data-number="28"><span class="header-section-number">28</span> Analyse des données aréales dans R</h1>
<p>Pour illustrer l’analyse de données aréales dans R, nous chargeons les packages <em>sf</em> (pour lire des données géospatiales), <em>spdep</em> (pour définir des réseaux spatiaux et calculer l’indice de Moran) et <em>spatialreg</em> (pour les modèles SAR et CAR).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-141_8c941e8bafdfac85f5eb2821d17ab03b">
<div class="sourceCode cell-code" id="cb225"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb225-1"><a href="#cb225-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(sf)</span>
<span id="cb225-2"><a href="#cb225-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(spdep)</span>
<span id="cb225-3"><a href="#cb225-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(spatialreg)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Nous utiliserons comme exemple un jeu de données qui présente une partie des résultats de l’élection provinciale de 2018 au Québec, avec des caractéristiques de la population de chaque circonscription. Ces données sont inclues dans un fichier de type <em>shapefile</em> (.shp), que nous pouvons lire avec la fonction <code>read_sf</code> du package <em>sf</em>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-142_f24372ba1482109fbffa68f052fd7dfb">
<div class="sourceCode cell-code" id="cb226"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb226-1"><a href="#cb226-1" aria-hidden="true" tabindex="-1"></a>elect2018 <span class="ot">&lt;-</span> <span class="fu">read_sf</span>(<span class="st">"data/elect2018.shp"</span>)</span>
<span id="cb226-2"><a href="#cb226-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(elect2018)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Simple feature collection with 6 features and 9 fields
Geometry type: MULTIPOLYGON
Dimension:     XY
Bounding box:  xmin: 97879.03 ymin: 174515.3 xmax: 694261.1 ymax: 599757.1
Projected CRS: LambertAQ
# A tibble: 6 × 10
  circ             age_moy pct_frn pct_prp rev_med propCAQ propPQ propPLQ propQS
  &lt;chr&gt;              &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;int&gt;   &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;
1 Abitibi-Est         40.8   0.963   0.644   34518    42.7   19.5    18.8   15.7
2 Abitibi-Ouest       42.2   0.987   0.735   33234    34.1   33.3    11.3   16.6
3 Acadie              40.3   0.573   0.403   25391    16.5    9      53.8   13.8
4 Anjou-Louis-Riel    43.5   0.821   0.416   31275    28.9   14.7    39.1   14.5
5 Argenteuil          43.3   0.858   0.766   31097    38.9   21.1    17.4   12.2
6 Arthabaska          43.4   0.989   0.679   30082    61.8    9.4    11.4   12.6
# … with 1 more variable: geometry &lt;MULTIPOLYGON [m]&gt;</code></pre>
</div>
</div>
<p><em>Note</em>: Le jeu de données est en fait composé de 4 fichiers avec les extensions .dbf, .prj, .shp et .shx, mais il suffit d’inscrire le nom du fichier .shp dans <code>read_sf</code>.</p>
<p>Les colonnes du jeu de données sont dans l’ordre:</p>
<ul>
<li>le nom de la circonscription électorale;</li>
<li>quatre caractéristiques de la population (âge moyen, fraction de la population qui parle principalement français à la maison, fraction des ménages qui sont propriétaires de leur logement, revenu médian);</li>
<li>quatre colonnes montrant la fraction des votes obtenues par les principaux partis (CAQ, PQ, PLQ, QS);</li>
<li>une colonne <code>geometry</code> qui contient l’objet géométrique (multipolygone) correspondant à la circonscription.</li>
</ul>
<p>Pour illustrer une des variables sur une carte, nous appelons la fonction <code>plot</code> avec le nom de la colonne entre crochets et guillemets.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-143_118d70deac183e230a7c64b3208cd1a7">
<div class="sourceCode cell-code" id="cb228"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb228-1"><a href="#cb228-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(elect2018[<span class="st">"rev_med"</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-143-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Dans cet exemple, nous voulons modéliser la fraction des votes obtenue par la CAQ en fonction des caractéristiques de la population dans chaque circonscription et en tenant compte des corrélations spatiales entre circonscriptions voisines.</p>
<section id="définition-du-réseau-de-voisinage" class="level2">
<h2 class="anchored" data-anchor-id="définition-du-réseau-de-voisinage">Définition du réseau de voisinage</h2>
<p>La fonction <code>poly2nb</code> du package <em>spdep</em> définit un réseau de voisinage à partir de polygones. Le résultat <code>vois</code> est une liste de 125 éléments où chaque élément contient les indices des polygones voisins (limitrophes) d’un polygone donné.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-144_e6285b834db05d427f22b7669e5dbee2">
<div class="sourceCode cell-code" id="cb229"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb229-1"><a href="#cb229-1" aria-hidden="true" tabindex="-1"></a>vois <span class="ot">&lt;-</span> <span class="fu">poly2nb</span>(elect2018)</span>
<span id="cb229-2"><a href="#cb229-2" aria-hidden="true" tabindex="-1"></a>vois[[<span class="dv">1</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1]   2  37  63  88 101 117</code></pre>
</div>
</div>
<p>Ainsi, la première circonscription (Abitibi-Est) a 6 circonscriptions voisines, dont on peut trouver les noms ainsi:</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-145_2fc04a4a3fbb352f0ae58db913423a12">
<div class="sourceCode cell-code" id="cb231"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb231-1"><a href="#cb231-1" aria-hidden="true" tabindex="-1"></a>elect2018<span class="sc">$</span>circ[vois[[<span class="dv">1</span>]]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Abitibi-Ouest"               "Gatineau"                   
[3] "Laviolette-Saint-Maurice"    "Pontiac"                    
[5] "Rouyn-Noranda-Témiscamingue" "Ungava"                     </code></pre>
</div>
</div>
<p>Nous pouvons illustrer ce réseau en faisant l’extraction des coordonnées du centre de chaque circonscription, en créant une carte muette avec <code>plot(elect2018["geometry"])</code>, puis en ajoutant le réseau comme couche additionnelle avec <code>plot(vois, add = TRUE, coords = coords)</code>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-146_56fcb69c11c78b9880373ab1b16efb12">
<div class="sourceCode cell-code" id="cb233"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb233-1"><a href="#cb233-1" aria-hidden="true" tabindex="-1"></a>coords <span class="ot">&lt;-</span> <span class="fu">st_centroid</span>(elect2018) <span class="sc">%&gt;%</span></span>
<span id="cb233-2"><a href="#cb233-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">st_coordinates</span>()</span>
<span id="cb233-3"><a href="#cb233-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(elect2018[<span class="st">"geometry"</span>])</span>
<span id="cb233-4"><a href="#cb233-4" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(vois, <span class="at">add =</span> <span class="cn">TRUE</span>, <span class="at">col =</span> <span class="st">"red"</span>, <span class="at">coords =</span> coords)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-146-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>On peut faire un “zoom” sur le sud du Québec en choisissant les limites <code>xlim</code> et <code>ylim</code> appropriées.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-147_b0a05b92ad9c5bc6e15ecbc77d7fd239">
<div class="sourceCode cell-code" id="cb234"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb234-1"><a href="#cb234-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(elect2018[<span class="st">"geometry"</span>], </span>
<span id="cb234-2"><a href="#cb234-2" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlim =</span> <span class="fu">c</span>(<span class="dv">400000</span>, <span class="dv">800000</span>), <span class="at">ylim =</span> <span class="fu">c</span>(<span class="dv">100000</span>, <span class="dv">500000</span>))</span>
<span id="cb234-3"><a href="#cb234-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(vois, <span class="at">add =</span> <span class="cn">TRUE</span>, <span class="at">col =</span> <span class="st">"red"</span>, <span class="at">coords =</span> coords)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-147-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Il nous reste à ajouter des poids à chaque lien du réseau avec la fonction <code>nb2listw</code>. Le style de poids “B” correspond aux poids binaires, soit 1 pour la présence de lien et 0 pour l’absence de lien entre deux circonscriptions.</p>
<p>Une fois ces poids définis, nous pouvons vérifier avec le test de Moran s’il y a une autocorrélation significative des votes obtenus par la CAQ entre circonscriptions voisines.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-148_59eb24f4ba758ea6399bc94ea1c419ba">
<div class="sourceCode cell-code" id="cb235"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb235-1"><a href="#cb235-1" aria-hidden="true" tabindex="-1"></a>poids <span class="ot">&lt;-</span> <span class="fu">nb2listw</span>(vois, <span class="at">style =</span> <span class="st">"B"</span>)</span>
<span id="cb235-2"><a href="#cb235-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-3"><a href="#cb235-3" aria-hidden="true" tabindex="-1"></a><span class="fu">moran.test</span>(elect2018<span class="sc">$</span>propCAQ, poids)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Moran I test under randomisation

data:  elect2018$propCAQ  
weights: poids    

Moran I statistic standard deviate = 13.148, p-value &lt; 2.2e-16
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
      0.680607768      -0.008064516       0.002743472 </code></pre>
</div>
</div>
<p>La valeur de <span class="math inline">\(I = 0.68\)</span> est très significative à en juger par la valeur <span class="math inline">\(p\)</span> du test.</p>
<p>Vérifions si la corrélation spatiale persiste après avoir tenu compte des quatre caractéristiques de la population, donc en inspectant les résidus d’un modèle linéaire incluant ces quatre prédicteurs.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-149_7d8643515ed0e408c5e5163ec8e3740c">
<div class="sourceCode cell-code" id="cb237"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb237-1"><a href="#cb237-1" aria-hidden="true" tabindex="-1"></a>elect_lm <span class="ot">&lt;-</span> <span class="fu">lm</span>(propCAQ <span class="sc">~</span> age_moy <span class="sc">+</span> pct_frn <span class="sc">+</span> pct_prp <span class="sc">+</span> rev_med, <span class="at">data =</span> elect2018)</span>
<span id="cb237-2"><a href="#cb237-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(elect_lm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = propCAQ ~ age_moy + pct_frn + pct_prp + rev_med, 
    data = elect2018)

Residuals:
     Min       1Q   Median       3Q      Max 
-30.9890  -4.4878   0.0562   6.2653  25.8146 

Coefficients:
              Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)  1.354e+01  1.836e+01   0.737    0.463    
age_moy     -9.170e-01  3.855e-01  -2.378    0.019 *  
pct_frn      4.588e+01  5.202e+00   8.820 1.09e-14 ***
pct_prp      3.582e+01  6.527e+00   5.488 2.31e-07 ***
rev_med     -2.624e-05  2.465e-04  -0.106    0.915    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 9.409 on 120 degrees of freedom
Multiple R-squared:  0.6096,    Adjusted R-squared:  0.5965 
F-statistic: 46.84 on 4 and 120 DF,  p-value: &lt; 2.2e-16</code></pre>
</div>
<div class="sourceCode cell-code" id="cb239"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb239-1"><a href="#cb239-1" aria-hidden="true" tabindex="-1"></a><span class="fu">moran.test</span>(<span class="fu">residuals</span>(elect_lm), poids)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Moran I test under randomisation

data:  residuals(elect_lm)  
weights: poids    

Moran I statistic standard deviate = 6.7047, p-value = 1.009e-11
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
      0.340083290      -0.008064516       0.002696300 </code></pre>
</div>
</div>
<p>L’indice de Moran a diminué mais demeure significatif, donc une partie de la corrélation précédente était induite par ces prédicteurs, mais il reste une corrélation spatiale due à d’autres facteurs.</p>
</section>
<section id="modèles-dautorégression-spatiale" class="level2">
<h2 class="anchored" data-anchor-id="modèles-dautorégression-spatiale">Modèles d’autorégression spatiale</h2>
<p>Finalement, nous ajustons des modèles SAR et CAR à ces données avec la fonction <code>spautolm</code> (<em>spatial autoregressive linear model</em>) de <em>spatialreg</em>. Voici le code pour un modèle SAR incluant l’effet des même quatre prédicteurs.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-150_34bc73005b64f5a3ee73549b2cbc9b5e">
<div class="sourceCode cell-code" id="cb241"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb241-1"><a href="#cb241-1" aria-hidden="true" tabindex="-1"></a>elect_sar <span class="ot">&lt;-</span> <span class="fu">spautolm</span>(propCAQ <span class="sc">~</span> age_moy <span class="sc">+</span> pct_frn <span class="sc">+</span> pct_prp <span class="sc">+</span> rev_med, </span>
<span id="cb241-2"><a href="#cb241-2" aria-hidden="true" tabindex="-1"></a>                      <span class="at">data =</span> elect2018, <span class="at">listw =</span> poids)</span>
<span id="cb241-3"><a href="#cb241-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(elect_sar)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call: spautolm(formula = propCAQ ~ age_moy + pct_frn + pct_prp + rev_med, 
    data = elect2018, listw = poids)

Residuals:
      Min        1Q    Median        3Q       Max 
-23.08342  -4.10573   0.24274   4.29941  23.08245 

Coefficients: 
               Estimate  Std. Error z value  Pr(&gt;|z|)
(Intercept) 15.09421119 16.52357745  0.9135   0.36098
age_moy     -0.70481703  0.32204139 -2.1886   0.02863
pct_frn     39.09375061  5.43653962  7.1909 6.435e-13
pct_prp     14.32329345  6.96492611  2.0565   0.03974
rev_med      0.00016730  0.00023209  0.7208   0.47101

Lambda: 0.12887 LR test value: 42.274 p-value: 7.9339e-11 
Numerical Hessian standard error of lambda: 0.012069 

Log likelihood: -433.8862 
ML residual variance (sigma squared): 53.028, (sigma: 7.282)
Number of observations: 125 
Number of parameters estimated: 7 
AIC: 881.77</code></pre>
</div>
</div>
<p>La valeur donnée par <code>Lambda</code> dans le sommaire correspond au coefficient <span class="math inline">\(\rho\)</span> dans notre description du modèle. Le test du rapport de vraisemblance (<code>LR test</code>) confirme que cette corrélation spatiale résiduelle (après avoir tenu compte de l’effet des prédicteurs) est significative.</p>
<p>Les effets estimés pour les prédicteurs sont semblables à ceux du modèle linéaire sans corrélation spatiale. Les effets de l’âge moyen, de la fraction de francophones et la fraction de propriétaires demeurent significatifs, bien que leur magnitude ait un peu diminué.</p>
<p>Pour évaluer un modèle CAR plutôt que SAR, nous devons spécifier <code>family = "CAR"</code>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-151_7ba6f7fcd4cc33a20eb6848945d3cce4">
<div class="sourceCode cell-code" id="cb243"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb243-1"><a href="#cb243-1" aria-hidden="true" tabindex="-1"></a>elect_car <span class="ot">&lt;-</span> <span class="fu">spautolm</span>(propCAQ <span class="sc">~</span> age_moy <span class="sc">+</span> pct_frn <span class="sc">+</span> pct_prp <span class="sc">+</span> rev_med, </span>
<span id="cb243-2"><a href="#cb243-2" aria-hidden="true" tabindex="-1"></a>                      <span class="at">data =</span> elect2018, <span class="at">listw =</span> poids, <span class="at">family =</span> <span class="st">"CAR"</span>)</span>
<span id="cb243-3"><a href="#cb243-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(elect_car)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call: spautolm(formula = propCAQ ~ age_moy + pct_frn + pct_prp + rev_med, 
    data = elect2018, listw = poids, family = "CAR")

Residuals:
      Min        1Q    Median        3Q       Max 
-21.73315  -4.24623  -0.24369   3.44228  23.43749 

Coefficients: 
               Estimate  Std. Error z value  Pr(&gt;|z|)
(Intercept) 16.57164696 16.84155327  0.9840  0.325128
age_moy     -0.79072151  0.32972225 -2.3981  0.016478
pct_frn     38.99116707  5.43667482  7.1719 7.399e-13
pct_prp     17.98557474  6.80333470  2.6436  0.008202
rev_med      0.00012639  0.00023106  0.5470  0.584364

Lambda: 0.15517 LR test value: 40.532 p-value: 1.9344e-10 
Numerical Hessian standard error of lambda: 0.0026868 

Log likelihood: -434.7573 
ML residual variance (sigma squared): 53.9, (sigma: 7.3416)
Number of observations: 125 
Number of parameters estimated: 7 
AIC: 883.51</code></pre>
</div>
</div>
<p>Pour un modèle CAR avec des poids binaires, la valeur de <code>Lambda</code> (que nous avions appelé <span class="math inline">\(\rho\)</span>) donne directement le coefficient de corrélation partielle entre circonscriptions voisines. Notez que l’AIC ici est légèrement supérieur au modèle SAR, donc ce dernier donnait un meilleur ajustement.</p>
</section>
<section id="exercice-3" class="level2">
<h2 class="anchored" data-anchor-id="exercice-3">Exercice</h2>
<p>Le jeu de données <code>rls_covid</code>, en format <em>shapefile</em>, contient des données sur les cas de COVID-19 détectés, le nombre de cas par 1000 personnes (<code>taux_1k</code>) et la densité de population (<code>dens_pop</code>) dans chacun des réseaux locaux de service de santé (RLS) du Québec. (Source: Données téléchargées de l’Institut national de santé publique du Québec en date du 17 janvier 2021.)</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-152_117a49f704cd9751636b707b593f6428">
<div class="sourceCode cell-code" id="cb245"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb245-1"><a href="#cb245-1" aria-hidden="true" tabindex="-1"></a>rls_covid <span class="ot">&lt;-</span> <span class="fu">read_sf</span>(<span class="st">"data/rls_covid.shp"</span>)</span>
<span id="cb245-2"><a href="#cb245-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(rls_covid)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Simple feature collection with 6 features and 5 fields
Geometry type: MULTIPOLYGON
Dimension:     XY
Bounding box:  xmin: 785111.2 ymin: 341057.8 xmax: 979941.5 ymax: 541112.7
Projected CRS: Conique_conforme_de_Lambert_du_MTQ_utilis_e_pour_Adresse_Qu_be
# A tibble: 6 × 6
  RLS_code RLS_nom                 cas taux_1k dens_…¹                  geometry
  &lt;chr&gt;    &lt;chr&gt;                 &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;        &lt;MULTIPOLYGON [m]&gt;
1 0111     RLS de Kamouraska       152    7.34    6.76 (((827028.3 412772.4, 82…
2 0112     RLS de Rivière-du-Lo…   256    7.34   19.6  (((855905 452116.9, 8557…
3 0113     RLS de Témiscouata       81    4.26    4.69 (((911829.4 441311.2, 91…
4 0114     RLS des Basques          28    3.3     5.35 (((879249.6 471975.6, 87…
5 0115     RLS de Rimouski         576    9.96   15.5  (((917748.1 503148.7, 91…
6 0116     RLS de La Mitis          76    4.24    5.53 (((951316 523499.3, 9525…
# … with abbreviated variable name ¹​dens_pop</code></pre>
</div>
</div>
<p>Ajustez un modèle linéaire du nombre de cas par 1000 en fonction de la densité de population (il est suggéré d’appliquer une transformation logarithmique à cette dernière). Vérifiez si les résidus du modèle sont corrélés entre RLS limitrophes avec un test de Moran, puis modélisez les mêmes données avec un modèle autorégressif conditionnel.</p>
</section>
<section id="référence" class="level2">
<h2 class="anchored" data-anchor-id="référence">Référence</h2>
<p>Ver Hoef, J.M., Peterson, E.E., Hooten, M.B., Hanks, E.M. et Fortin, M.-J. (2018) Spatial autoregressive models for statistical inference from ecological data. <em>Ecological Monographs</em> 88: 36-59.</p>
</section>
</section>
<section id="glmm-spatial-gaussian-fr" class="level1" data-number="29">
<h1 data-number="29"><span class="header-section-number">29</span> GLMM avec processus spatial gaussien</h1>
<p>Dans les parties précédentes, nous avons vu comment tenir compte de la dépendance spatiale dans les modèles de régression linéaire avec des modèles géostatistiques (également appelés processus gaussiens) ou des modèles d’autocorrélation spatiale (CAR/SAR). Dans cette dernière partie, nous verrons comment combiner ces caractéristiques avec des modèles de régression plus complexes, en particulier les modèles linéaires généralisés à effets mixtes (GLMM).</p>
<section id="données" class="level2">
<h2 class="anchored" data-anchor-id="données">Données</h2>
<p>Le jeu de données <code>gambia</code> inclus avec le package <em>geoR</em> présente les résultats d’une étude sur la prévalence du paludisme chez les enfants de 65 villages en Gambie. Nous utiliserons une version légèrement transformée des données contenues dans le fichier <a href="data/gambia.csv">gambia.csv</a>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-153_94be0528ee530f4b0d9120a3e4a412d9">
<div class="sourceCode cell-code" id="cb247"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb247-1"><a href="#cb247-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(geoR)</span>
<span id="cb247-2"><a href="#cb247-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb247-3"><a href="#cb247-3" aria-hidden="true" tabindex="-1"></a>gambia <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">"data/gambia.csv"</span>)</span>
<span id="cb247-4"><a href="#cb247-4" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(gambia)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  id_village        x        y pos  age netuse treated green phc
1          1 349.6313 1458.055   1 1783      0       0 40.85   1
2          1 349.6313 1458.055   0  404      1       0 40.85   1
3          1 349.6313 1458.055   0  452      1       0 40.85   1
4          1 349.6313 1458.055   1  566      1       0 40.85   1
5          1 349.6313 1458.055   0  598      1       0 40.85   1
6          1 349.6313 1458.055   1  590      1       0 40.85   1</code></pre>
</div>
</div>
<p>Voici les champs de ce jeu de données:</p>
<ul>
<li><em>id_village</em>: Identifiant du village.</li>
<li><em>x</em> and <em>y</em>: Coordonnées spatiales du village (en km, basé sur les coordonnées UTM).</li>
<li><em>pos</em>: Réponse binaire, si l’enfant a eu un test positif du paludisme.</li>
<li><em>age</em>: Âge de l’enfant en jours.</li>
<li><em>netuse</em>: Si l’enfant dort sous un moustiquaire ou non.</li>
<li><em>treated</em>: Si le moustiquaire est traité ou non.</li>
<li><em>green</em>: Mesure de la végétation basée sur les données de télédétection (disponible à l’échelle du village).</li>
<li><em>phc</em>: Présence ou absence d’un centre de santé publique pour le village.</li>
</ul>
<p>Nous pouvons compter le nombre de cas positifs et le nombre total d’enfants testés par village pour cartographier la fraction des cas positifs (ou prévalence, <em>prev</em>).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-154_f2e9fe8cc46d29ee6147236d160f6a1a">
<div class="sourceCode cell-code" id="cb249"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb249-1"><a href="#cb249-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Jeu de données à l'échelle du village</span></span>
<span id="cb249-2"><a href="#cb249-2" aria-hidden="true" tabindex="-1"></a>gambia_agg <span class="ot">&lt;-</span> <span class="fu">group_by</span>(gambia, id_village, x, y, green, phc) <span class="sc">%&gt;%</span></span>
<span id="cb249-3"><a href="#cb249-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">summarize</span>(<span class="at">pos =</span> <span class="fu">sum</span>(pos), <span class="at">total =</span> <span class="fu">n</span>()) <span class="sc">%&gt;%</span></span>
<span id="cb249-4"><a href="#cb249-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mutate</span>(<span class="at">prev =</span> pos <span class="sc">/</span> total) <span class="sc">%&gt;%</span></span>
<span id="cb249-5"><a href="#cb249-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ungroup</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>`summarise()` has grouped output by 'id_village', 'x', 'y', 'green'. You can
override using the `.groups` argument.</code></pre>
</div>
<div class="sourceCode cell-code" id="cb251"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb251-1"><a href="#cb251-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(gambia_agg)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 6 × 8
  id_village     x     y green   phc   pos total  prev
       &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;
1          1  350. 1458.  40.8     1    17    33 0.515
2          2  359. 1460.  40.8     1    19    63 0.302
3          3  360. 1460.  40.1     0     7    17 0.412
4          4  364. 1497.  40.8     0     8    24 0.333
5          5  366. 1460.  40.8     0    10    26 0.385
6          6  367. 1463.  40.8     0     7    18 0.389</code></pre>
</div>
</div>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-155_b02463961b3424baa4da82ed27a5ca7e">
<div class="sourceCode cell-code" id="cb253"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb253-1"><a href="#cb253-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(gambia_agg, <span class="fu">aes</span>(<span class="at">x =</span> x, <span class="at">y =</span> y)) <span class="sc">+</span></span>
<span id="cb253-2"><a href="#cb253-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">color =</span> prev)) <span class="sc">+</span></span>
<span id="cb253-3"><a href="#cb253-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_path</span>(<span class="at">data =</span> gambia.borders, <span class="fu">aes</span>(<span class="at">x =</span> x <span class="sc">/</span> <span class="dv">1000</span>, <span class="at">y =</span> y <span class="sc">/</span> <span class="dv">1000</span>)) <span class="sc">+</span></span>
<span id="cb253-4"><a href="#cb253-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">coord_fixed</span>() <span class="sc">+</span></span>
<span id="cb253-5"><a href="#cb253-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb253-6"><a href="#cb253-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">scale_color_viridis_c</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-155-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Nous utilisons le jeu de données <code>gambia.borders</code> du package <em>geoR</em> pour tracer les frontières des pays avec <code>geom_path</code>. Comme ces frontières sont en mètres, nous les divisons par 1000 pour obtenir la même échelle que nos points. Nous utilisons également <code>coord_fixed</code> pour assurer un rapport d’aspect de 1:1 entre les axes et utilisons la palette de couleur <code>viridis</code>, qui permet de visualiser plus facilement une variable continue par rapport à la palette par défaut dans <em>ggplot2</em>.</p>
<p>Sur la base de cette carte, il semble y avoir une corrélation spatiale dans la prévalence du paludisme, le groupe de villages de l’est montrant des valeurs de prévalence plus élevées (jaune-vert) et le groupe du milieu montrant des valeurs de prévalence plus faibles (violet).</p>
</section>
<section id="glmm-non-spatial" class="level2">
<h2 class="anchored" data-anchor-id="glmm-non-spatial">GLMM non spatial</h2>
<p>Pour ce premier exemple, nous allons ignorer l’aspect spatial des données et modéliser la présence du paludisme (<em>pos</em>) en fonction de l’utilisation d’une moustiquaire (<em>netuse</em>) et de la présence d’un centre de santé publique (<em>phc</em>). Comme nous avons une réponse binaire, nous devons utiliser un modèle de régression logistique (un GLM). Comme nous avons des prédicteurs au niveau individuel et au niveau du village et que nous nous attendons à ce que les enfants d’un même village aient une probabilité plus similaire d’avoir le paludisme même après avoir pris en compte ces prédicteurs, nous devons ajouter un effet aléatoire du village. Le résultat est un GLMM que nous ajustons en utilisant la fonction <code>glmer</code> du package <em>lme4</em>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-156_7c91bce3c832a01ae8f8b3f26d71b9fa">
<div class="sourceCode cell-code" id="cb254"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb254-1"><a href="#cb254-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(lme4)</span>
<span id="cb254-2"><a href="#cb254-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb254-3"><a href="#cb254-3" aria-hidden="true" tabindex="-1"></a>mod_glmm <span class="ot">&lt;-</span> <span class="fu">glmer</span>(pos <span class="sc">~</span> netuse <span class="sc">+</span> phc <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> id_village), </span>
<span id="cb254-4"><a href="#cb254-4" aria-hidden="true" tabindex="-1"></a>                  <span class="at">data =</span> gambia, <span class="at">family =</span> binomial)</span>
<span id="cb254-5"><a href="#cb254-5" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(mod_glmm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Generalized linear mixed model fit by maximum likelihood (Laplace
  Approximation) [glmerMod]
 Family: binomial  ( logit )
Formula: pos ~ netuse + phc + (1 | id_village)
   Data: gambia

     AIC      BIC   logLik deviance df.resid 
  2428.0   2450.5  -1210.0   2420.0     2031 

Scaled residuals: 
    Min      1Q  Median      3Q     Max 
-2.1286 -0.7120 -0.4142  0.8474  3.3434 

Random effects:
 Groups     Name        Variance Std.Dev.
 id_village (Intercept) 0.8149   0.9027  
Number of obs: 2035, groups:  id_village, 65

Fixed effects:
            Estimate Std. Error z value Pr(&gt;|z|)    
(Intercept)   0.1491     0.2297   0.649   0.5164    
netuse       -0.6044     0.1442  -4.190 2.79e-05 ***
phc          -0.4985     0.2604  -1.914   0.0556 .  
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Correlation of Fixed Effects:
       (Intr) netuse
netuse -0.422       
phc    -0.715 -0.025</code></pre>
</div>
</div>
<p>D’après ces résultats, les variables <em>netuse</em> et <em>phc</em> sont toutes deux associées à une diminution de la prévalence du paludisme, bien que l’effet de <em>phc</em> ne soit pas significatif à un seuil <span class="math inline">\(\alpha = 0.05\)</span>. L’ordonnée à l’origine (0.149) est le logit de la probabilité de présence du paludisme pour un enfant sans moustiquaire et sans centre de santé publique, mais c’est l’ordonnée à l’origine moyenne pour tous les villages. Il y a beaucoup de variation entre les villages selon l’écart-type de l’effet aléatoire (0.90). Nous pouvons obtenir l’ordonnée à l’origine estimée pour chaque village avec la fonction <code>coef</code>:</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-157_63042bdf37fbb1a41197653e4f00698a">
<div class="sourceCode cell-code" id="cb256"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb256-1"><a href="#cb256-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(<span class="fu">coef</span>(mod_glmm)<span class="sc">$</span>id_village)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  (Intercept)     netuse        phc
1  0.93727515 -0.6043602 -0.4984835
2  0.09204843 -0.6043602 -0.4984835
3  0.22500620 -0.6043602 -0.4984835
4 -0.46271089 -0.6043602 -0.4984835
5  0.13680037 -0.6043602 -0.4984835
6 -0.03723346 -0.6043602 -0.4984835</code></pre>
</div>
</div>
<p>Par exemple, l’ordonnée à l’origine pour le village 1 est environ 0.94, équivalente à une probabilité de 72%:</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-158_4a79548bf948a9a1dd6b953821a54623">
<div class="sourceCode cell-code" id="cb258"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb258-1"><a href="#cb258-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plogis</span>(<span class="fl">0.937</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.7184933</code></pre>
</div>
</div>
<p>tandis que celle pour le village 2 est équivalente à une probabilité de 52%:</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-159_4c5678258eaea6caef0b0f87f03a5423">
<div class="sourceCode cell-code" id="cb260"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb260-1"><a href="#cb260-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plogis</span>(<span class="fl">0.092</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.5229838</code></pre>
</div>
</div>
<p>Le <a href="https://cran.r-project.org/web/packages/DHARMa/vignettes/DHARMa.html">package DHARMa</a> fournit une méthode générale pour vérifier si les résidus d’un GLMM sont distribués selon le modèle spécifié et s’il existe une tendance résiduelle. Il simule des réplicats de chaque observation selon le modèle ajusté et détermine ensuite un “résidu standardisé”, qui est la position relative de la valeur observée par rapport aux valeurs simulées, par exemple 0 si l’observation est plus petite que toutes les simulations, 0.5 si elle se trouve au milieu, etc. Si le modèle représente bien les données, chaque valeur du résidu standardisé entre 0 et 1 doit avoir la même probabilité, de sorte que les résidus standardisés doivent produire une distribution uniforme entre 0 et 1.</p>
<p>La fonction <code>simulateResiduals</code> effectue le calcul des résidus standardisés, puis la fonction <code>plot</code> trace les graphiques de diagnostic avec les résultats de certains tests.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-160_9f18e83c75ae6d568f2e7722da9a3235">
<div class="sourceCode cell-code" id="cb262"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb262-1"><a href="#cb262-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(DHARMa)</span>
<span id="cb262-2"><a href="#cb262-2" aria-hidden="true" tabindex="-1"></a>res_glmm <span class="ot">&lt;-</span> <span class="fu">simulateResiduals</span>(mod_glmm)</span>
<span id="cb262-3"><a href="#cb262-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(res_glmm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-160-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Le graphique de gauche est un graphique quantile-quantile des résidus standardisés. Les résultats de trois tests statistiques sont également présentés: un test de Kolmogorov-Smirnov (<em>KS</em>) qui vérifie s’il y a un écart par rapport à la distribution théorique, un test de dispersion qui vérifie s’il y a une sous-dispersion ou une surdispersion et un test de valeurs aberrantes (<em>outlier</em>) basé sur le nombre de résidus qui sont plus extrêmes que toutes les simulations. Ici, nous obtenons un résultat significatif pour les valeurs aberrantes, bien que le message indique que ce résultat pourrait avoir un taux d’erreur de type I plus grand que prévu dans ce cas.</p>
<p>À droite, nous obtenons généralement un graphique des résidus standardisés (en <em>y</em>) en fonction du rang des valeurs prédites, afin de vérifier l’absence de tendance résiduelle. Ici, les prédictions sont regroupées par quartile, il serait donc préférable d’agréger les prédictions et les résidus par village, ce que nous pouvons faire avec la fonction <code>recalculateResiduals</code>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-161_24ccd295095906cee82b1b1c09edfb05">
<div class="sourceCode cell-code" id="cb263"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb263-1"><a href="#cb263-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">recalculateResiduals</span>(res_glmm, <span class="at">group =</span> gambia<span class="sc">$</span>id_village))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>DHARMa:testOutliers with type = binomial may have inflated Type I error rates for integer-valued distributions. To get a more exact result, it is recommended to re-run testOutliers with type = 'bootstrap'. See ?testOutliers for details</code></pre>
</div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-161-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Le graphique de droite montre les points individuels, ainsi qu’une régression quantile pour le 1er quartile, la médiane et le 3e quartile. En théorie, ces trois courbes devraient être des lignes droites horizontales (pas de tendance des résidus par rapport aux prévisions). La courbe pour le 3e quartile (en rouge) est significativement différente d’une ligne horizontale, ce qui pourrait indiquer un effet systématique manquant dans le modèle.</p>
</section>
<section id="glmm-spatial-avec-spamm" class="level2">
<h2 class="anchored" data-anchor-id="glmm-spatial-avec-spamm">GLMM spatial avec spaMM</h2>
<p>Le package <em>spaMM</em> (modèles mixtes spatiaux) est un package R relativement récent qui permet d’effectuer une estimation approximative du maximum de vraisemblance des paramètres pour les GLM avec dépendance spatiale, modélisés soit comme un processus gaussien, soit avec un CAR (nous verrons ce dernier dans la dernière section). Le package implémente différents algorithmes, mais il existe une fonction unique <code>fitme</code> qui choisit l’algorithme approprié pour chaque type de modèle. Par exemple, voici le même modèle (non spatial) que nous avons vu ci-dessus, ajusté avec <em>spaMM</em>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-162_54461b112807b785cded2a0cabf936b4">
<div class="sourceCode cell-code" id="cb265"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb265-1"><a href="#cb265-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(spaMM)</span>
<span id="cb265-2"><a href="#cb265-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-3"><a href="#cb265-3" aria-hidden="true" tabindex="-1"></a>mod_spamm_glmm <span class="ot">&lt;-</span> <span class="fu">fitme</span>(pos <span class="sc">~</span> netuse <span class="sc">+</span> phc <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> id_village),</span>
<span id="cb265-4"><a href="#cb265-4" aria-hidden="true" tabindex="-1"></a>                        <span class="at">data =</span> gambia, <span class="at">family =</span> binomial)</span>
<span id="cb265-5"><a href="#cb265-5" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(mod_spamm_glmm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>formula: pos ~ netuse + phc + (1 | id_village)
Estimation of lambda by ML (p_v approximation of logL).
Estimation of fixed effects by ML (p_v approximation of logL).
family: binomial( link = logit ) 
 ------------ Fixed effects (beta) ------------
            Estimate Cond. SE t-value
(Intercept)   0.1491   0.2287  0.6519
netuse       -0.6045   0.1420 -4.2567
phc          -0.4986   0.2593 -1.9231
 --------------- Random effects ---------------
Family: gaussian( link = identity ) 
           --- Variance parameters ('lambda'):
lambda = var(u) for u ~ Gaussian; 
   id_village  :  0.8151  
             --- Coefficients for log(lambda):
      Group        Term Estimate Cond.SE
 id_village (Intercept)  -0.2045  0.2008
# of obs: 2035; # of groups: id_village, 65 
 ------------- Likelihood values  -------------
                        logLik
logL       (p_v(h)): -1210.016</code></pre>
</div>
</div>
<p>Notez que les estimés des effets fixes ainsi que la variance des effets aléatoires sont presque identiques à ceeux obtenues par <code>glmer</code> ci-dessus.</p>
<p>Nous pouvons maintenant utiliser <em>spaMM</em> pour ajuster le même modèle avec l’ajout de corrélations spatiales entre les villages. Dans la formule du modèle, ceci est représenté comme un effet aléatoire <code>Matern(1 | x + y)</code>, ce qui signifie que les ordonnées à l’origine sont spatialement corrélées entre les villages suivant une fonction de corrélation de Matérn des coordonnées (<em>x, y</em>). La fonction de Matérn est une fonction flexible de corrélation spatiale qui comprend un paramètre de forme <span class="math inline">\(\nu\)</span> (<code>nu</code>), de sorte que lorsque <span class="math inline">\(\nu = 0,5\)</span>, elle est équivalente à la corrélation exponentielle, mais quand <span class="math inline">\(\nu\)</span> prend de grandes valeurs, elle se rapproche d’une corrélation gaussienne. Nous pourrions laisser la fonction estimer <span class="math inline">\(\nu\)</span>, mais ici nous le fixons à 0.5 avec l’argument <code>fixed</code> de <code>fitme</code>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-163_94f8693a9a4ea45698056ea7d175adbc">
<div class="sourceCode cell-code" id="cb267"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb267-1"><a href="#cb267-1" aria-hidden="true" tabindex="-1"></a>mod_spamm <span class="ot">&lt;-</span> <span class="fu">fitme</span>(pos <span class="sc">~</span> netuse <span class="sc">+</span> phc <span class="sc">+</span> <span class="fu">Matern</span>(<span class="dv">1</span> <span class="sc">|</span> x <span class="sc">+</span> y) <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> id_village),</span>
<span id="cb267-2"><a href="#cb267-2" aria-hidden="true" tabindex="-1"></a>                   <span class="at">data =</span> gambia, <span class="at">family =</span> binomial, <span class="at">fixed =</span> <span class="fu">list</span>(<span class="at">nu =</span> <span class="fl">0.5</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Increase spaMM.options(separation_max=&lt;.&gt;) to at least 21 if you want to check separation (see 'help(separation)').</code></pre>
</div>
<div class="sourceCode cell-code" id="cb269"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb269-1"><a href="#cb269-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(mod_spamm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>formula: pos ~ netuse + phc + Matern(1 | x + y) + (1 | id_village)
Estimation of corrPars and lambda by ML (p_v approximation of logL).
Estimation of fixed effects by ML (p_v approximation of logL).
Estimation of lambda by 'outer' ML, maximizing logL.
family: binomial( link = logit ) 
 ------------ Fixed effects (beta) ------------
            Estimate Cond. SE t-value
(Intercept)  0.06861   0.3352  0.2047
netuse      -0.51719   0.1407 -3.6757
phc         -0.44416   0.2052 -2.1648
 --------------- Random effects ---------------
Family: gaussian( link = identity ) 
                   --- Correlation parameters:
      1.nu      1.rho 
0.50000000 0.05128692 
           --- Variance parameters ('lambda'):
lambda = var(u) for u ~ Gaussian; 
   x + y  :  0.6421 
   id_village  :  0.1978  
# of obs: 2035; # of groups: x + y, 65; id_village, 65 
 ------------- Likelihood values  -------------
                        logLik
logL       (p_v(h)): -1197.968</code></pre>
</div>
</div>
<p>Commençons par vérifier les effets aléatoires du modèle. La fonction de corrélation spatiale a un paramètre <code>rho</code> égal à 0.0513. Ce paramètre dans <em>spaMM</em> est l’inverse de la portée, donc ici la portée de la corrélation exponentielle est de 1/0.0513 ou environ 19.5 km. Il y a maintenant deux pramètres de variance, celui identifié comme <code>x + y</code> est la variance à longue distance (i.e.&nbsp;le palier) pour le modèle de corrélation exponentielle alors que celui identifié comme <code>id_village</code> montre la portion non corrélée de la variation entre les villages.</p>
<p>Si nous avions ici laissé les effets aléatoires <code>(1 | id_village)</code> dans la formule pour représenter la partie non spatiale de la variation entre les villages, nous pourrions également représenter ceci avec un effet de pépite dans le modèle géostatistique. Dans les deux cas, cela représenterait l’idée que même deux villages très proches l’un de l’autre auraient des prévalences de base différentes dans le modèle.</p>
<p>Par défaut, la fonction <code>Matern</code> n’a pas d’effet de pépite, mais nous pouvons en ajouter un en spécifiant une <code>pépite</code> non nulle dans la liste initiale des paramètres <code>init</code>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-164_7807f13fbd48e4a433573a5160e106f1">
<div class="sourceCode cell-code" id="cb271"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb271-1"><a href="#cb271-1" aria-hidden="true" tabindex="-1"></a>mod_spamm2 <span class="ot">&lt;-</span> <span class="fu">fitme</span>(pos <span class="sc">~</span> netuse <span class="sc">+</span> phc <span class="sc">+</span> <span class="fu">Matern</span>(<span class="dv">1</span> <span class="sc">|</span> x <span class="sc">+</span> y),</span>
<span id="cb271-2"><a href="#cb271-2" aria-hidden="true" tabindex="-1"></a>                    <span class="at">data =</span> gambia, <span class="at">family =</span> binomial, <span class="at">fixed =</span> <span class="fu">list</span>(<span class="at">nu =</span> <span class="fl">0.5</span>),</span>
<span id="cb271-3"><a href="#cb271-3" aria-hidden="true" tabindex="-1"></a>                    <span class="at">init =</span> <span class="fu">list</span>(<span class="at">Nugget =</span> <span class="fl">0.1</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Increase spaMM.options(separation_max=&lt;.&gt;) to at least 21 if you want to check separation (see 'help(separation)').</code></pre>
</div>
<div class="sourceCode cell-code" id="cb273"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb273-1"><a href="#cb273-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(mod_spamm2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>formula: pos ~ netuse + phc + Matern(1 | x + y)
Estimation of corrPars and lambda by ML (p_v approximation of logL).
Estimation of fixed effects by ML (p_v approximation of logL).
Estimation of lambda by 'outer' ML, maximizing logL.
family: binomial( link = logit ) 
 ------------ Fixed effects (beta) ------------
            Estimate Cond. SE t-value
(Intercept)  0.06861   0.3352  0.2047
netuse      -0.51719   0.1407 -3.6757
phc         -0.44416   0.2052 -2.1648
 --------------- Random effects ---------------
Family: gaussian( link = identity ) 
                   --- Correlation parameters:
      1.nu   1.Nugget      1.rho 
0.50000000 0.23551027 0.05128692 
           --- Variance parameters ('lambda'):
lambda = var(u) for u ~ Gaussian; 
   x + y  :  0.8399  
# of obs: 2035; # of groups: x + y, 65 
 ------------- Likelihood values  -------------
                        logLik
logL       (p_v(h)): -1197.968</code></pre>
</div>
</div>
<p>Comme vous pouvez le voir, toutes les estimations sont les mêmes, sauf que la variance de la portion spatiale (palier) est maintenant de 0.84 et que la pépite est égale à une fraction 0.235 de ce palier, soit une variance de 0.197, ce qui est identique à l’effet aléatoire <code>id_village</code> dans la version ci-dessus. Les deux formulations sont donc équivalentes.</p>
<p>Maintenant, rappelons les coefficients que nous avions obtenus pour le GLMM non spatial :</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-165_d9e37edd6e102c7e0e32c00182b4c98d">
<div class="sourceCode cell-code" id="cb275"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb275-1"><a href="#cb275-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(mod_glmm)<span class="sc">$</span>coefficients</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>              Estimate Std. Error    z value     Pr(&gt;|z|)
(Intercept)  0.1490596  0.2296971  0.6489399 5.163772e-01
netuse      -0.6043602  0.1442448 -4.1898243 2.791706e-05
phc         -0.4984835  0.2604083 -1.9142382 5.558973e-02</code></pre>
</div>
</div>
<p>Dans la version spatiale, les deux effets fixes se sont légèrement rapprochés de zéro, mais l’erreur-type de l’effet de <code>phc</code> a diminué. Il est intéressant de noter que l’inclusion de la dépendance spatiale nous a permis d’estimer plus précisément l’effet de la présence d’un centre de santé publique dans le village. Ce ne serait pas toujours le cas: pour un prédicteur qui est également fortement corrélé dans l’espace, la corrélation spatiale dans la réponse rend plus difficile l’estimation de l’effet de ce prédicteur, puisqu’il est confondu avec l’effet spatial. Cependant, pour un prédicteur qui n’est pas corrélé dans l’espace, l’inclusion de l’effet spatial réduit la variance résiduelle (non spatiale) et peut donc augmenter la précision de l’effet du prédicteur.</p>
<p>Le package <em>spaMM</em> est également compatible avec <em>DHARMa</em> pour les diagnostics résiduels. (Vous pouvez ignorer l’avertissement selon lequel il ne fait pas partie de la classe des modèles pris en charge, cela est dû à l’utilisation de la fonction <code>fitme</code> plutôt que d’une fonction d’algorithme spécifique dans <em>spaMM</em>).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-166_482f0fc040c81b2f1de2f8ee99aed0d1">
<div class="sourceCode cell-code" id="cb277"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb277-1"><a href="#cb277-1" aria-hidden="true" tabindex="-1"></a>res_spamm <span class="ot">&lt;-</span> <span class="fu">simulateResiduals</span>(mod_spamm2)</span>
<span id="cb277-2"><a href="#cb277-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(res_spamm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>DHARMa:testOutliers with type = binomial may have inflated Type I error rates for integer-valued distributions. To get a more exact result, it is recommended to re-run testOutliers with type = 'bootstrap'. See ?testOutliers for details</code></pre>
</div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-166-1.png" class="img-fluid" width="672"></p>
</div>
<div class="sourceCode cell-code" id="cb279"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb279-1"><a href="#cb279-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">recalculateResiduals</span>(res_spamm, <span class="at">group =</span> gambia<span class="sc">$</span>id_village))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>DHARMa:testOutliers with type = binomial may have inflated Type I error rates for integer-valued distributions. To get a more exact result, it is recommended to re-run testOutliers with type = 'bootstrap'. See ?testOutliers for details</code></pre>
</div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-166-2.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Enfin, bien que nous allons montrer comment calculer et visualiser des prédictions spatiales ci-dessous, nous pouvons produire une carte rapide des effets spatiaux estimés dans un modèle <em>spaMM</em> avec la fonction <code>filled.mapMM</code>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-167_e868e1e85e43353fb2484a914c5ac95b">
<div class="sourceCode cell-code" id="cb281"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb281-1"><a href="#cb281-1" aria-hidden="true" tabindex="-1"></a><span class="fu">filled.mapMM</span>(mod_spamm2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-167-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
<section id="processus-gaussiens-vs.-splines-de-lissage" class="level2">
<h2 class="anchored" data-anchor-id="processus-gaussiens-vs.-splines-de-lissage">Processus gaussiens vs.&nbsp;splines de lissage</h2>
<p>Si vous connaissez bien les modèles additifs généralisés (GAM), vous avez peut-être pensé à représenter la variation spatiale de la prévalence du paludisme (comme le montre la carte ci-dessus) par une spline de lissage en 2D (en fonction de <span class="math inline">\(x\)</span> et <span class="math inline">\(y\)</span>) dans un GAM.</p>
<p>Le code ci-dessous correspond à l’équivalent GAM de notre GLMM avec processus gaussien ci-dessus, ajusté avec la fonction <code>gam</code> du package <em>mgcv</em>. L’effet spatial est représenté par la spline 2D <code>s(x, y)</code> alors que l’effet aléatoire non spatial de village est représenté par <code>s(id_village, bs = "re")</code>, qui est équivalent à <code>(1 | id_village)</code> dans les modèles précédents. Notez que pour la fonction <code>gam</code>, les variables catégorielles doivent être explicitement converties en facteurs.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-168_5bc46e857407589375ab5b89e189742e">
<div class="sourceCode cell-code" id="cb282"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb282-1"><a href="#cb282-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mgcv)</span>
<span id="cb282-2"><a href="#cb282-2" aria-hidden="true" tabindex="-1"></a>gambia<span class="sc">$</span>id_village <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(gambia<span class="sc">$</span>id_village)</span>
<span id="cb282-3"><a href="#cb282-3" aria-hidden="true" tabindex="-1"></a>mod_gam <span class="ot">&lt;-</span> <span class="fu">gam</span>(pos <span class="sc">~</span> netuse <span class="sc">+</span> phc <span class="sc">+</span> <span class="fu">s</span>(id_village, <span class="at">bs =</span> <span class="st">"re"</span>) <span class="sc">+</span> <span class="fu">s</span>(x, y), </span>
<span id="cb282-4"><a href="#cb282-4" aria-hidden="true" tabindex="-1"></a>               <span class="at">data =</span> gambia, <span class="at">family =</span> binomial)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Pour visualiser la spline en 2D, nous utiliserons le package <a href="https://fromthebottomoftheheap.net/2018/10/23/introducing-gratia/"><em>gratia</em></a>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-169_07227aba979cb7fed1f2b23e7e58bfaa">
<div class="sourceCode cell-code" id="cb283"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb283-1"><a href="#cb283-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(gratia)</span>
<span id="cb283-2"><a href="#cb283-2" aria-hidden="true" tabindex="-1"></a><span class="fu">draw</span>(mod_gam)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-169-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Notez que le graphique de la spline <code>s(x, y)</code> (en haut à droite) ne s’étend pas trop loin des emplacements des données (les autres zones sont vides). Dans ce graphique, on peut également voir que les effets aléatoires des villages suivent la distribution gaussienne attendue (en haut à gauche).</p>
<p>Ensuite, nous utiliserons à la fois le GLMM spatial de la section précédente et ce GAMM pour prédire la prévalence moyenne sur une grille spatiale de points contenue dans le fichier <a href="data/gambia_pred.csv">gambia_pred.csv</a>. Le graphique ci-dessous ajoute ces points de prédiction (en noir) sur la carte précédente des points de données.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-170_a944ccbc8f583a47e766a152bff9062f">
<div class="sourceCode cell-code" id="cb284"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb284-1"><a href="#cb284-1" aria-hidden="true" tabindex="-1"></a>gambia_pred <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">"data/gambia_pred.csv"</span>)</span>
<span id="cb284-2"><a href="#cb284-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb284-3"><a href="#cb284-3" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(gambia_agg, <span class="fu">aes</span>(<span class="at">x =</span> x, <span class="at">y =</span> y)) <span class="sc">+</span></span>
<span id="cb284-4"><a href="#cb284-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>(<span class="at">data =</span> gambia_pred) <span class="sc">+</span></span>
<span id="cb284-5"><a href="#cb284-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">color =</span> prev)) <span class="sc">+</span></span>
<span id="cb284-6"><a href="#cb284-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_path</span>(<span class="at">data =</span> gambia.borders, <span class="fu">aes</span>(<span class="at">x =</span> x <span class="sc">/</span> <span class="dv">1000</span>, <span class="at">y =</span> y <span class="sc">/</span> <span class="dv">1000</span>)) <span class="sc">+</span></span>
<span id="cb284-7"><a href="#cb284-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">coord_fixed</span>() <span class="sc">+</span></span>
<span id="cb284-8"><a href="#cb284-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb284-9"><a href="#cb284-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">scale_color_viridis_c</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-170-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Pour faire des prédictions à partir du modèle GAMM à ces endroits, le code ci-dessous effectue les étapes suivantes:</p>
<ul>
<li><p>Tous les prédicteurs du modèle doivent se trouver dans le tableau de données de prédiction, nous ajoutons donc des valeurs constantes de <em>netuse</em> et <em>phc</em> (toutes deux égales à 1) pour tous les points. Ainsi, nous ferons des prédictions sur la prévalence du paludisme dans le cas où un moustiquaire est utilisée et où un centre de santé publique est présent. Nous ajoutons également un <em>id_village</em> constant, bien qu’il ne soit pas utilisé dans les prédictions (voir ci-dessous).</p></li>
<li><p>Nous appelons la fonction <code>predict</code> à la sortie de <code>gam</code> pour produire des prédictions aux nouveaux points de données (argument <code>newdata</code>), en incluant les erreurs-types (<code>se.fit = TRUE</code>) et en excluant les effets aléatoires du village, donc la prédiction est faite pour un “village moyen”. L’objet résultant <code>gam_pred</code> aura des colonnes <code>fit</code> (prédiction moyenne) et <code>se.fit</code> (erreur-type). Ces prédictions et erreurs-types sont sur l’échelle du lien (logit).</p></li>
<li><p>Nous rattachons le jeu de données de prédiction original à <code>gam_pred</code> avec <code>cbind</code>.</p></li>
<li><p>Nous ajoutons des colonnes pour la prédiction moyenne et les limites de l’intervalle de confiance à 50% (moyenne <span class="math inline">\(\pm\)</span> 0.674 erreur-type), converties de l’échelle logit à l’échelle de probabilité avec <code>plogis</code>. Nous choisissons un intervalle de 50% car un intervalle de 95% peut être trop large ici pour contraster les différentes prédictions sur la carte à la fin de cette section.</p></li>
</ul>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-171_357ffbfea872595db79ace469d64440a">
<div class="sourceCode cell-code" id="cb285"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb285-1"><a href="#cb285-1" aria-hidden="true" tabindex="-1"></a>gambia_pred <span class="ot">&lt;-</span> <span class="fu">mutate</span>(gambia_pred, <span class="at">netuse =</span> <span class="dv">1</span>, <span class="at">phc =</span> <span class="dv">1</span>, <span class="at">id_village =</span> <span class="dv">1</span>)</span>
<span id="cb285-2"><a href="#cb285-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb285-3"><a href="#cb285-3" aria-hidden="true" tabindex="-1"></a>gam_pred <span class="ot">&lt;-</span> <span class="fu">predict</span>(mod_gam, <span class="at">newdata =</span> gambia_pred, <span class="at">se.fit =</span> <span class="cn">TRUE</span>, </span>
<span id="cb285-4"><a href="#cb285-4" aria-hidden="true" tabindex="-1"></a>                    <span class="at">exclude =</span> <span class="st">"s(id_village)"</span>)</span>
<span id="cb285-5"><a href="#cb285-5" aria-hidden="true" tabindex="-1"></a>gam_pred <span class="ot">&lt;-</span> <span class="fu">cbind</span>(gambia_pred, <span class="fu">as.data.frame</span>(gam_pred))</span>
<span id="cb285-6"><a href="#cb285-6" aria-hidden="true" tabindex="-1"></a>gam_pred <span class="ot">&lt;-</span> <span class="fu">mutate</span>(gam_pred, <span class="at">pred =</span> <span class="fu">plogis</span>(fit), </span>
<span id="cb285-7"><a href="#cb285-7" aria-hidden="true" tabindex="-1"></a>                   <span class="at">lo =</span> <span class="fu">plogis</span>(fit <span class="sc">-</span> <span class="fl">0.674</span> <span class="sc">*</span> se.fit), <span class="co"># 50% CI</span></span>
<span id="cb285-8"><a href="#cb285-8" aria-hidden="true" tabindex="-1"></a>                   <span class="at">hi =</span> <span class="fu">plogis</span>(fit <span class="sc">+</span> <span class="fl">0.674</span> <span class="sc">*</span> se.fit))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><em>Note</em> : La raison pour laquelle nous ne faisons pas de prédictions directement sur l’échelle de probabilité (réponse) est que la formule normale des intervalles de confiance s’applique plus précisément sur l’échelle logit. L’ajout d’un certain nombre d’erreurs-types autour de la moyenne sur l’échelle de probabilité conduirait à des intervalles moins précis et peut-être même à des intervalles de confiance en dehors de la plage de valeurs possible (0, 1) pour une probabilité.</p>
<p>Nous appliquons la même stratégie pour faire des prédictions à partir du GLMM spatial avec <em>spaMM</em>. Il y a quelques différences dans la méthode <code>predict</code> par rapport au cas du GAMM.</p>
<ul>
<li><p>L’argument <code>binding = "fit"</code> signifie que les prédictions moyennes (colonne <code>fit</code>) seront attachées à l’ensemble de données de prédiction et retournées sous forme de tableau de données <code>spamm_pred</code>.</p></li>
<li><p>L’argument <code>variances = list(linPred = TRUE)</code> indique à <code>predict</code> de calculer la variance du prédicteur linéaire (donc le carré de l’erreur-type). Cependant, il apparaît comme un attribut <code>predVar</code> dans le tableau de données de sortie plutôt que dans une colonne <code>se.fit</code>, donc nous le déplaçons vers une colonne sur la ligne suivante.</p></li>
</ul>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-172_4419491a3882f147cdc904a6d1ed9d9c">
<div class="sourceCode cell-code" id="cb286"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb286-1"><a href="#cb286-1" aria-hidden="true" tabindex="-1"></a>spamm_pred <span class="ot">&lt;-</span> <span class="fu">predict</span>(mod_spamm, <span class="at">newdata =</span> gambia_pred, <span class="at">type =</span> <span class="st">"link"</span>,</span>
<span id="cb286-2"><a href="#cb286-2" aria-hidden="true" tabindex="-1"></a>                      <span class="at">binding =</span> <span class="st">"fit"</span>, <span class="at">variances =</span> <span class="fu">list</span>(<span class="at">linPred =</span> <span class="cn">TRUE</span>))</span>
<span id="cb286-3"><a href="#cb286-3" aria-hidden="true" tabindex="-1"></a>spamm_pred<span class="sc">$</span>se.fit <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(<span class="fu">attr</span>(spamm_pred, <span class="st">"predVar"</span>))</span>
<span id="cb286-4"><a href="#cb286-4" aria-hidden="true" tabindex="-1"></a>spamm_pred <span class="ot">&lt;-</span> <span class="fu">mutate</span>(spamm_pred, <span class="at">pred =</span> <span class="fu">plogis</span>(fit), </span>
<span id="cb286-5"><a href="#cb286-5" aria-hidden="true" tabindex="-1"></a>                     <span class="at">lo =</span> <span class="fu">plogis</span>(fit <span class="sc">-</span> <span class="fl">0.674</span> <span class="sc">*</span> se.fit),</span>
<span id="cb286-6"><a href="#cb286-6" aria-hidden="true" tabindex="-1"></a>                     <span class="at">hi =</span> <span class="fu">plogis</span>(fit <span class="sc">+</span> <span class="fl">0.674</span> <span class="sc">*</span> se.fit))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Enfin, nous combinons les deux ensembles de prédictions sous la forme de différentes rangées d’un tableau de données <code>pred_all</code> avec <code>bind_rows</code>. Le nom du tableau de données d’où provient chaque prédiction (<code>gam</code> ou <code>spamm</code>) apparaîtra dans la colonne “model” (argument <code>.id</code>). Pour simplifier la production du prochain graphique, nous utilisons ensuite <code>pivot_longer</code> dans le package <em>tidyr</em> pour changer les trois colonnes “pred”, “lo” et “hi” en deux colonnes, “stat” et “value” (<code>pred_tall</code> a donc trois rangées pour chaque rangée dans <code>pred_all</code>).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-173_1fc1b4f68f5b10a718d8d768a968469c">
<div class="sourceCode cell-code" id="cb287"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb287-1"><a href="#cb287-1" aria-hidden="true" tabindex="-1"></a>pred_all <span class="ot">&lt;-</span> <span class="fu">bind_rows</span>(<span class="at">gam =</span> gam_pred, <span class="at">spamm =</span> spamm_pred, <span class="at">.id =</span> <span class="st">"model"</span>)</span>
<span id="cb287-2"><a href="#cb287-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb287-3"><a href="#cb287-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyr)</span>
<span id="cb287-4"><a href="#cb287-4" aria-hidden="true" tabindex="-1"></a>pred_tall <span class="ot">&lt;-</span> <span class="fu">pivot_longer</span>(pred_all, <span class="fu">c</span>(pred, lo, hi), <span class="at">names_to =</span> <span class="st">"stat"</span>,</span>
<span id="cb287-5"><a href="#cb287-5" aria-hidden="true" tabindex="-1"></a>                          <span class="at">values_to =</span> <span class="st">"value"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Une fois ces étapes franchies, nous pouvons enfin examiner les cartes de prédiction (moyenne, limites inférieure et supérieure de l’intervalle de confiance à 50 %) à l’aide d’un graphique <code>ggplot</code>. Les points de données originaux sont indiqués en rouge.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-174_f5e1618501cf8d5cc8fb3b12843ae8e2">
<div class="sourceCode cell-code" id="cb288"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb288-1"><a href="#cb288-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(pred_tall, <span class="fu">aes</span>(<span class="at">x =</span> x, <span class="at">y =</span> y)) <span class="sc">+</span></span>
<span id="cb288-2"><a href="#cb288-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">color =</span> value)) <span class="sc">+</span></span>
<span id="cb288-3"><a href="#cb288-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>(<span class="at">data =</span> gambia_agg, <span class="at">color =</span> <span class="st">"red"</span>, <span class="at">size =</span> <span class="dv">0</span>) <span class="sc">+</span></span>
<span id="cb288-4"><a href="#cb288-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">coord_fixed</span>() <span class="sc">+</span></span>
<span id="cb288-5"><a href="#cb288-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">facet_grid</span>(stat<span class="sc">~</span>model) <span class="sc">+</span></span>
<span id="cb288-6"><a href="#cb288-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">scale_color_viridis_c</span>() <span class="sc">+</span></span>
<span id="cb288-7"><a href="#cb288-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_minimal</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-174-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Bien que les deux modèles s’accordent à dire que la prévalence est plus élevée près du groupe de villages de l’est, le GAMM estime également une prévalence plus élevée en quelques points (bord ouest et autour du centre) où il n’y a pas de données. Il s’agit d’un artefact de la forme de la spline autour des points de données, puisqu’une spline est censée correspondre à une tendance globale, bien que non linéaire. En revanche, le modèle géostatistique représente l’effet spatial sous forme de corrélations locales et revient à la prévalence moyenne globale lorsqu’il est éloigné de tout point de données, ce qui est une supposition plus sûre. C’est l’une des raisons pour lesquelles il est préférable de choisir un modèle géostatistique / processus gaussien dans ce cas.</p>
</section>
<section id="méthodes-bayésiennes-pour-les-glmm-avec-processus-gaussiens" class="level2">
<h2 class="anchored" data-anchor-id="méthodes-bayésiennes-pour-les-glmm-avec-processus-gaussiens">Méthodes bayésiennes pour les GLMM avec processus gaussiens</h2>
<p>Les modèles bayésiens fournissent un cadre flexible pour exprimer des modèles avec une structure de dépendance complexe entre les données, y compris la dépendance spatiale. Cependant, l’ajustement d’un modèle de processus gaussien avec une approche entièrement bayésienne peut être lent, en raison de la nécessité de calculer une matrice de covariance spatiale entre toutes les paires de points à chaque itération.</p>
<p>La méthode INLA (pour <em>integrated nested Laplace approximation</em>) effectue un calcul approximatif de la distribution postérieure bayésienne, ce qui la rend adaptée aux problèmes de régression spatiale. Nous ne l’abordons pas dans ce cours, mais je recommande le manuel de Paula Moraga (dans la section des références ci-dessous) qui fournit des exemples concrets d’utilisation de la méthode INLA pour divers modèles de données géostatistiques et aréales, dans le contexte de l’épidémiologie, y compris des modèles avec une dépendance à la fois spatiale et temporelle. Le livre présente les mêmes données sur le paludisme en Gambie comme exemple d’un ensemble de données géostatistiques, ce qui a inspiré son utilisation dans ce cours.</p>
</section>
</section>
<section id="glmm-spatial-autoreg-fr" class="level1" data-number="30">
<h1 data-number="30"><span class="header-section-number">30</span> GLMM avec autorégression spatiale</h1>
<p>Nous revenons au dernier exemple de la partie précédente, où nous avions modélisé le taux de cas de COVID-19 (cas / 1000) pour les divisions administratives du réseau de la santé (RLS) au Québec en fonction de leur densité de population. Le taux est donné par la colonne “taux_1k” dans le <em>shapefile</em> <code>rls_covid</code>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-175_d979460e37556b83e05dc8fb16e15b65">
<div class="sourceCode cell-code" id="cb289"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb289-1"><a href="#cb289-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(sf)</span>
<span id="cb289-2"><a href="#cb289-2" aria-hidden="true" tabindex="-1"></a>rls_covid <span class="ot">&lt;-</span> <span class="fu">read_sf</span>(<span class="st">"data/rls_covid.shp"</span>)</span>
<span id="cb289-3"><a href="#cb289-3" aria-hidden="true" tabindex="-1"></a>rls_covid <span class="ot">&lt;-</span> rls_covid[<span class="sc">!</span><span class="fu">is.na</span>(rls_covid<span class="sc">$</span>dens_pop), ]</span>
<span id="cb289-4"><a href="#cb289-4" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(rls_covid[<span class="st">"taux_1k"</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-175-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Auparavant, nous avions modélisé le logarithme de ce taux comme une fonction linéaire du logarithme de la densité de population, la variance résiduelle étant corrélée entre les unités voisines via une structure CAR (autorégression conditionnelle), comme le montre le code ci-dessous.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-176_eabbd635c0d88a1a771574c50afa7c53">
<div class="sourceCode cell-code" id="cb290"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb290-1"><a href="#cb290-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(spdep)</span>
<span id="cb290-2"><a href="#cb290-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(spatialreg)</span>
<span id="cb290-3"><a href="#cb290-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb290-4"><a href="#cb290-4" aria-hidden="true" tabindex="-1"></a>rls_nb <span class="ot">&lt;-</span> <span class="fu">poly2nb</span>(rls_covid)</span>
<span id="cb290-5"><a href="#cb290-5" aria-hidden="true" tabindex="-1"></a>rls_w <span class="ot">&lt;-</span> <span class="fu">nb2listw</span>(rls_nb, <span class="at">style =</span> <span class="st">"B"</span>)</span>
<span id="cb290-6"><a href="#cb290-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb290-7"><a href="#cb290-7" aria-hidden="true" tabindex="-1"></a>car_lm <span class="ot">&lt;-</span> <span class="fu">spautolm</span>(<span class="fu">log</span>(taux_1k) <span class="sc">~</span> <span class="fu">log</span>(dens_pop), <span class="at">data =</span> rls_covid,</span>
<span id="cb290-8"><a href="#cb290-8" aria-hidden="true" tabindex="-1"></a>                   <span class="at">listw =</span> rls_w, <span class="at">family =</span> <span class="st">"CAR"</span>)</span>
<span id="cb290-9"><a href="#cb290-9" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(car_lm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call: spautolm(formula = log(taux_1k) ~ log(dens_pop), data = rls_covid, 
    listw = rls_w, family = "CAR")

Residuals:
      Min        1Q    Median        3Q       Max 
-1.201858 -0.254084 -0.053348  0.281482  1.427053 

Coefficients: 
              Estimate Std. Error z value  Pr(&gt;|z|)
(Intercept)   1.702068   0.168463 10.1035 &lt; 2.2e-16
log(dens_pop) 0.206623   0.032848  6.2903 3.169e-10

Lambda: 0.15762 LR test value: 23.991 p-value: 9.6771e-07 
Numerical Hessian standard error of lambda: 0.0050486 

Log likelihood: -80.68953 
ML residual variance (sigma squared): 0.2814, (sigma: 0.53048)
Number of observations: 95 
Number of parameters estimated: 4 
AIC: 169.38</code></pre>
</div>
</div>
<p><em>Rappel</em>: La fonction <code>poly2nb</code> du package <em>spdep</em> crée une liste de voisins basée sur les polygones limitrophes dans un <em>shapefile</em>, puis <code>nb2listw</code> la convertit en une liste de poids, ici des poids binaires (<code>style = "B"</code>) de sorte que chaque région limitrophe reçoive le même poids de 1 dans le modèle autorégressif.</p>
<p>Au lieu d’utiliser les taux, il serait possible de modéliser directement les cas avec une régression de Poisson, qui est appropriée pour les données de comptage. Pour tenir compte du fait que si le risque par personne était égal, les cas seraient proportionnels à la population, nous pouvons ajouter la population de l’unité <code>pop</code> comme <em>offset</em> dans la régression de Poisson. Par conséquent, le modèle ressemblerait à : <code>cas ~ log(dens_pop) + offset(log(pop))</code>. Notez que puisque la régression de Poisson utilise un lien logarithmique, ce modèle avec <code>log(pop)</code> comme <em>offset</em> suppose que <code>log(cas / pop)</code> (donc le taux logarithmique) est proportionnel à <code>log(dens_pop)</code>, tout comme le modèle linéaire ci-dessus, mais il a l’avantage de modéliser la variabilité des données brutes (le nombre de cas) directement avec une distribution de Poisson.</p>
<p>Nous n’avons pas la population dans ces données, mais nous pouvons l’estimer à partir des cas et du taux (cas / 1000) comme suit:</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-177_6dfaa30fb79c49e08cda1647cb0cd013">
<div class="sourceCode cell-code" id="cb292"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb292-1"><a href="#cb292-1" aria-hidden="true" tabindex="-1"></a>rls_covid<span class="sc">$</span>pop <span class="ot">&lt;-</span> rls_covid<span class="sc">$</span>cas <span class="sc">/</span> rls_covid<span class="sc">$</span>taux_1k <span class="sc">*</span> <span class="dv">1000</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Pour définir un modèle CAR dans <em>spaMM</em>, nous avons besoin d’une matrice de poids plutôt que d’une liste de poids comme dans le package <em>spatialreg</em>. Heureusement, le package <em>spdep</em> comprend également une fonction <code>nb2mat</code> pour convertir la liste des voisins en une matrice de poids, là encore en utilisant des poids binaires. Pour éviter un avertissement dans R, nous spécifions que les noms des lignes et des colonnes de cette matrice doivent être égaux aux identifiants associés à chaque unité (<code>RLS_code</code>). Ensuite, nous ajoutons un terme <code>adjacency(1 | RLS_code)</code> au modèle pour spécifier que la variation résiduelle entre les différents groupes définis par <code>RLS_code</code> est spatialement corrélée avec une structure CAR (ici, chaque groupe n’a qu’une observation puisque nous avons un point de données par unité RLS).</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-178_c3221c2defe378081625dfcfb8bdbe89">
<div class="sourceCode cell-code" id="cb293"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb293-1"><a href="#cb293-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(spaMM)</span>
<span id="cb293-2"><a href="#cb293-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb293-3"><a href="#cb293-3" aria-hidden="true" tabindex="-1"></a>rls_mat <span class="ot">&lt;-</span> <span class="fu">nb2mat</span>(rls_nb, <span class="at">style =</span> <span class="st">"B"</span>)</span>
<span id="cb293-4"><a href="#cb293-4" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(rls_mat) <span class="ot">&lt;-</span> rls_covid<span class="sc">$</span>RLS_code</span>
<span id="cb293-5"><a href="#cb293-5" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(rls_mat) <span class="ot">&lt;-</span> rls_covid<span class="sc">$</span>RLS_code</span>
<span id="cb293-6"><a href="#cb293-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb293-7"><a href="#cb293-7" aria-hidden="true" tabindex="-1"></a>rls_spamm <span class="ot">&lt;-</span> <span class="fu">fitme</span>(cas <span class="sc">~</span> <span class="fu">log</span>(dens_pop) <span class="sc">+</span> <span class="fu">offset</span>(<span class="fu">log</span>(pop)) <span class="sc">+</span> <span class="fu">adjacency</span>(<span class="dv">1</span> <span class="sc">|</span> RLS_code),</span>
<span id="cb293-8"><a href="#cb293-8" aria-hidden="true" tabindex="-1"></a>                   <span class="at">data =</span> rls_covid, <span class="at">adjMatrix =</span> rls_mat, <span class="at">family =</span> poisson)</span>
<span id="cb293-9"><a href="#cb293-9" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(rls_spamm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>formula: cas ~ log(dens_pop) + offset(log(pop)) + adjacency(1 | RLS_code)
Estimation of corrPars and lambda by ML (p_v approximation of logL).
Estimation of fixed effects by ML (p_v approximation of logL).
Estimation of lambda by 'outer' ML, maximizing logL.
family: poisson( link = log ) 
 ------------ Fixed effects (beta) ------------
              Estimate Cond. SE t-value
(Intercept)    -5.1618  0.16855 -30.625
log(dens_pop)   0.1999  0.03267   6.119
 --------------- Random effects ---------------
Family: gaussian( link = identity ) 
                   --- Correlation parameters:
    1.rho 
0.1576605 
           --- Variance parameters ('lambda'):
lambda = var(u) for u ~ Gaussian; 
   RLS_code  :  0.266  
# of obs: 95; # of groups: RLS_code, 95 
 ------------- Likelihood values  -------------
                        logLik
logL       (p_v(h)): -709.3234</code></pre>
</div>
</div>
<p>Notez que le coefficient de corrélation spatiale <code>rho</code> (0.158) est similaire à la quantité équivalente dans le modèle <code>spautolm</code> ci-dessus, où il était appelé <code>Lambda</code>. L’effet de <code>log(dens_pop)</code> est également d’environ 0.2 dans les deux modèles.</p>
<section id="référence-1" class="level2">
<h2 class="anchored" data-anchor-id="référence-1">Référence</h2>
<p>Moraga, Paula (2019) Geospatial Health Data: Modeling and Visualization with R-INLA and Shiny. Chapman &amp; Hall/CRC Biostatistics Series. Disponible en ligne: <a href="https://www.paulamoraga.com/book-geospatial/">https://www.paulamoraga.com/book-geospatial/</a>.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>