{"title":"Introduction to Shiny Apps","markdown":{"yaml":{"title":"Introduction to Shiny Apps","description":"Introduction to interactive app development with R Shiny.","author":[{"name":"Katherine Hébert","affiliation":"Université de Sherbrooke"},{"name":"Andrew MacDonald","affiliation":"Université de Sherbrooke"},{"name":"Jake Lawlor","affiliation":"McGill University"},{"name":"Vincent Bellavance","affiliation":"Université de Sherbrooke"}],"date":"06-22-2021","image":"image.jpg","categories":["Technical","Fellow contributed","EN"],"toc":true,"number-sections":true,"number-depth":1},"headingText":"Why do you want to use Shiny?","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(eval = FALSE)\n```\n\n\nThere are many reasons to consider using Shiny for a project:\n\n-   Sharing results from a paper with your readers;\n-   Helping you explore a model, mathematics, simulations;\n-   Letting non R users use R.\n\n## Hello Shiny!\n\nHere is an example of a Shiny app that RStudio generates when you open a new Shiny Web App file:\n\n```{r eval = FALSE}\n# Define UI for app that draws a histogram ----\nui <- fluidPage(\n\n  # App title ----\n  titlePanel(\"Hello Shiny!\"),\n\n  # Sidebar layout with input and output definitions ----\n  sidebarLayout(\n\n    # Sidebar panel for inputs ----\n    sidebarPanel(\n\n      # Input: Slider for the number of bins ----\n      sliderInput(inputId = \"bins\",\n                  label = \"Number of bins:\",\n                  min = 1,\n                  max = 50,\n                  value = 30)\n\n    ),\n\n    # Main panel for displaying outputs ----\n    mainPanel(\n\n      # Output: Histogram ----\n      plotOutput(outputId = \"distPlot\")\n\n    )\n  )\n)\n```\n\n# How a Shiny app works\n\n## Building blocks\n\nWe've now seen the basic building blocks of a Shiny app:\n\n-   The **user interface**, which determines how the app \"looks\". This is how we tell Shiny where to ask for user inputs, and where to put any outputs we create.\n-   **Reactive values**, which are values that change according to user inputs. These are values that affect the outputs we create in the Shiny app, such as tables or plots.\n-   The **server**, where we use reactive values to generate some outputs.\n\n### IDs\n\nThe **user interface** and **server** communicate through IDs that we assign to inputs from the user and outputs from the server.\n\n![](images/app-ids.png)\n\nWe use an ID (*in orange*) to link the user input in the UI to the reactive values used in the server:\n\n![](images/app-reactiveid.png)\n\nWe use another ID (*in blue*) to link the output created in the server to the output shown in the user interface:\n\n![](images/app-output.png)\n\n### Organisation\n\nThese elements can all be placed in one script named `app.R` or separately in scripts named `ui.R` and `server.R`. The choice is up to you, although it becomes easier to work in separate `ui.R` and `server.R` scripts when the Shiny app becomes more complex.\n\n**Example 1: Everything in `app.R`**\n\n![](images/app-in1.png) **Example 2: Split things into `ui.R` and `server.R`**\n\n![](images/app-in2.png)\n\n## Plots\n\nShiny is an excellent tool for visual exploration - it is at its most useful when a user can *see* something change before their eyes according to some selections. This is a great way to allow users to explore a dataset, explore the results of some analyses according to different parameters, and so on!\n\nLet's now add a plot to our Shiny app, to visualize the distribution of a variable depending on user input. We'll be adding the `ggplot2` and `ggridges` packages in the set-up step at the top of our `app.R` to allow us to make a plot.\n\n```{r}\n# load packages\nlibrary(shiny)\nlibrary(ggridges)\nlibrary(ggplot2)\nlibrary(here)\nlibrary(readr)\n```\n\n### User interface\n\nTo add a plot in our Shiny, we need to indicate where the plot should appear in the app. We can do this with `plotOutput()`, a similar function to `tableOutput()` in the previous section that is meant for plot outputs, as the name suggests.\n\n```{r}\n# Define UI for application that makes a table andplots the Volcano Explosivity \n# Index for the most eruptive volcanoes within a selected range of years\n\nui <- fluidPage(\n  \n  # Application title ----\n  \n  titlePanel(\"Exploring volcano explosivity\"),\n  \n  # Input interface ----\n  \n  sidebarLayout(\n    sidebarPanel(\n      \n      # Sidebar with a slider range input\n      sliderInput(\"years\", # the id your server needs to use the selected value\n                  label = h3(\"Years\"),\n                  min = 1900, max = 2020, # maximum range that can be selected\n                  value = c(2010, 2020) # this is the default slider position\n      )\n    )\n  ),\n  \n  # Show the outputs from the server ---------------\n  mainPanel(\n    \n    # Show a ridgeplot of explosivity index for selected volcanoes\n    plotOutput(\"ridgePlot\"),\n    \n    # then, show the table we made in the previous step\n    tableOutput(\"erupt_table\")\n    \n  )\n)\n```\n\nNow our Shiny app knows where we want to place our plot.\n\n### Server\n\nWe now need to create the plot we want to show in our app. This plot will change depending on one or several reactive values that the user can input or select in our UI.\n\nWe link the UI and server together with IDs that are assigned to each object. Above, we told the UI to expect a plot output with the ID `\"ridgePlot\"`. In the server, we will create a plot and render it as a plot object using `renderPlot()`, and we will assign this plot output to the ID we call in the UI (as `output$ridgePlot`).\n\n```{r}\n# Define server logic required to make your output(s)\nserver <- function(input, output) {\n\n  \n  # prepare the data\n  # ----------------------------------------------------------\n  \n  # read the dataset\n  eruptions <- readr::read_rds(here::here(\"data\", \"eruptions.rds\"))\n  \n  # filter the dataset to avoid overloading the plot \n  eruptions <- eruptions[which(eruptions$volcano_name %in% names(which(table(eruptions$volcano_name) > 30))),]\n  # this subsets to volcanoes that have erupted more than 30 times\n  \n  \n  # make reactive dataset\n  # ----------------------------------------------------------\n  \n  # subset volcano data with input year range\n  eruptions_filtered <- reactive({\n    subset(eruptions, start_year >= input$years[1] & end_year <= input$years[2])\n  })\n  \n    \n  # create and render the outputs\n  # ----------------------------------------------------------\n  \n  # create the table of volcanoes\n  output$erupt_table <- renderTable({\n    head(eruptions_filtered())\n  })\n  \n  # render the plot output\n  output$ridgePlot <- renderPlot({\n    \n    # create the plot\n    ggplot(data = eruptions_filtered(),\n           aes(x = vei,\n               y = volcano_name,\n               fill = volcano_name)) +\n      # we are using a ridgeplot geom here, from the ggridges package\n      geom_density_ridges( size = .5) + # line width\n      \n      # label the axes\n      labs(x = \"Volcano Explosivity Index\", y = \"\") +\n      \n      # adjust the ggplot theme to make the plot \"prettier\"\n      theme_classic() + \n      theme(legend.position = \"none\",\n            axis.text = element_text(size = 12, face = \"bold\"),\n            axis.title = element_text(size = 14, face = \"bold\"))\n  })\n}\n```\n\n### The Shiny app\n\nNow, if we run the Shiny app, we have a plot above the table we made previously. They are positioned in this way because the `plotOutput()` comes before the `tableOutput()` in the UI.\n\n```{r eval = FALSE}\n# Run the application\nshinyApp(ui = ui, server = server)\n```\n\n![](images/plotOutput.png)\n\n## Customising the theme\n\nIf you'd like to go one step further, you can also customize the appearance of your Shiny app using built-in themes, or creating your own themes.\n\n### Using built-in themes\n\nThere are several built-in themes in Shiny, which allow you to quickly change the appearance of your app. You can browse a gallery of available themes here [here](https://rstudio.github.io/shinythemes/), or test themes out interactively [here](https://shiny.rstudio.com/gallery/shiny-theme-selector.html).\n\nLet's try the *darkly* theme on our Shiny app. To do this, we will need the `shinythemes` package.\n\n```{r}\nlibrary(shinythemes)\n```\n\nWe can change the theme of our previous app with one line of code:\n\n```{r}\n# Define UI for application that makes a table andplots the Volcano Explosivity \n# Index for the most eruptive volcanoes within a selected range of years\n\nui <- fluidPage(\n  \n  # Application title ----\n  \n  titlePanel(\"Exploring volcano explosivity\"),\n  \n  # Input interface ----\n  \n  sidebarLayout(\n    sidebarPanel(\n      \n      # Sidebar with a slider range input\n      sliderInput(\"years\", # the id your server needs to use the selected value\n                  label = h3(\"Years\"),\n                  min = 1900, max = 2020, # maximum range that can be selected\n                  value = c(2010, 2020) # this is the default slider position\n      )\n    )\n  ),\n  \n  # Show the outputs from the server ---------------\n  mainPanel(\n    \n    # Show a ridgeplot of explosivity index for selected volcanoes\n    plotOutput(\"ridgePlot\"),\n    \n    # then, show the table we made in the previous step\n    tableOutput(\"erupt_table\")\n    \n  ),\n  \n  # Customize the theme ----------------------\n  \n  # Use the darkly theme\n  theme = shinythemes::shinytheme(\"darkly\")\n)\n```\n\nNow, if we run the app, it looks a little different:\n\n![](images/darklytheme.png)\n\n### Using a custom theme\n\nYou can also go beyond the built-in themes, and create your own custom theme with the fonts and colours of your choice. You can also apply this theme to the outputs rendered in the app, to bring all the visuals together for a more cohesive look.\n\n#### Customizing a theme\n\nTo create a custom theme, we will be using the `bs_theme()` function from the `bslib` package.\n\n```{r}\nlibrary(bslib)\n```\n\n```{r}\n# Create a custom theme \ncute_theme <- bslib::bs_theme(\n  \n  bg = \"#36393B\", # background colour\n  fg = \"#FFD166\", # most of the text on your app\n  primary = \"#F26430\", # buttons, ...\n  \n  # you can also choose fonts\n  base_font = font_google(\"Open Sans\"),\n  heading_font = font_google(\"Open Sans\")\n)\n```\n\nTo apply this theme to our Shiny app (and the outputs), we will be using the `thematic` package.\n\n```{r}\nlibrary(thematic)\n```\n\nThere are two essential steps to apply a custom theme to a Shiny app:\n\n1.  Activating thematic.\n2.  Setting the user interface's theme to the custom theme (`cute_theme`).\n\n```{r}\n# Activate thematic\n# so your R outputs will be changed to match up with your chosen styling\nthematic::thematic_shiny()\n\n# Define UI for application that makes a table andplots the Volcano Explosivity \n# Index for the most eruptive volcanoes within a selected range of years\n\nui <- fluidPage(\n  \n  # Application title ----\n  \n  titlePanel(\"Exploring volcano explosivity\"),\n  \n  # Input interface ----\n  \n  sidebarLayout(\n    sidebarPanel(\n      \n      # Sidebar with a slider range input\n      sliderInput(\"years\", # the id your server needs to use the selected value\n                  label = h3(\"Years\"),\n                  min = 1900, max = 2020, # maximum range that can be selected\n                  value = c(2010, 2020) # this is the default slider position\n      )\n    )\n  ),\n  \n  # Show the outputs from the server ---------------\n  mainPanel(\n    \n    # Show a ridgeplot of explosivity index for selected volcanoes\n    plotOutput(\"ridgePlot\"),\n    \n    # then, show the table we made in the previous step\n    tableOutput(\"erupt_table\")\n    \n  ),\n  \n  # Customize the theme ----------------------\n  \n  # Use our custom theme\n  theme = cute_theme\n)\n```\n\nNow, if we run the app, the user interface and plot theme is set to the colours and fonts we set in `cute_theme`:\n\n![](images/thematic.png)\n\nHere, `thematic` is not changing the colours used to represent a variable in our plot, because this is an informative colour scale (unlike the colour of axis labels, lines, and the plot background). However, if we remove this colour variable in our ridgeplot in the server, thematic will change the plot colours as well. Here is a simplified example of our server to see what these changes would look like:\n\n```{r}\n# Define server logic required to make your output(s)\nserver <- function(input, output) {\n  \n  #... (all the good stuff we wrote above)\n  \n  # render the plot output\n  output$ridgePlot <- renderPlot({\n    \n    # create the plot\n    ggplot(data = eruptions_filtered(),\n           aes(x = vei,\n               y = volcano_name)) + # we are no longer setting \n             # the fill argument to a variable\n             \n             # we are using a ridgeplot geom here, from the ggridges package\n             geom_density_ridges(size = .5) + \n             \n             # label the axes\n             labs(x = \"Volcano Explosivity Index\", y = \"\") +\n             \n             # remove the \"classic\" ggplot2 so it doesn't override thematic's changes\n             # theme_classic() + \n             theme(legend.position = \"none\",\n                   axis.text = element_text(size = 12, face = \"bold\"),\n                   axis.title = element_text(size = 14, face = \"bold\"))\n           })\n    }\n```\n\nNow, our plot's theme follows the app's custom theme as well:\n\n![](images/thematic_plot.png)\n\n# Constructing a Shiny app using shinyDashboards\n\n## Taking advantage of good defaults\n\nHere, we will use shiny extension `shinyDashboards` and `leaflet` to construct a custom Shiny App to map volcanoes of the world. First, we need a few additional packages.\n\n**Note: All Source code for this app can be found [here](https://github.com/bios2/shiny_day_2/tree/main/Jake_volcano_map/Volcano_Leaflet) on the BIOS2 Github.**\n\n```{r}\n# load packages\nlibrary(shiny)\nlibrary(shinydashboard)  # dashboard layout package\nlibrary(shinyWidgets)  # fancy widgets package\nlibrary(leaflet)  # interactive maps package\nlibrary(dplyr)\nlibrary(ggplot2)\n```\n\n### Using ShinyDashboard\n\nWe will create our app using defaults from the ShinyDashboard package, which always includes three main components: a header, using `dashboardHeader()`, a sidebar, using `dashboardSidebar()`, and a body, using `dashboardBody()`. These are then added together using the `dashboardPage()` function.\n\nBuilding these elements is less like usual R coding, and more like web design, since we are, in fact, designing a unser interface for a web app. Here, we'll make a basic layout before populating it.\n\n```{r, echo=TRUE}\n# create the header of our app\nheader <- dashboardHeader(\n    title = \"Exploring Volcanoes of the World\",\n    titleWidth = 350 # since we have a long title, we need to extend width element in pixels\n)\n\n\n# create dashboard body - this is the major UI element\nbody <- dashboardBody(\n\n    # make first row of elements (actually, this will be the only row)\n    fluidRow(\n        \n        # make first column, 25% of page - width = 3 of 12 columns\n        column(width = 3,\n               \n               \n               # Box 1: text explaining what this app is\n               #-----------------------------------------------\n               box( width = NULL,\n                    status=\"primary\", # this line can change the automatic color of the box.\n                    title = NULL,\n                    p(\"here, we'll include some info about this app\")\n\n                 \n               ), # end box 1\n               \n               \n               # box 2 : input for selecting volcano type\n               #-----------------------------------------------\n               box(width = NULL, status = \"primary\",\n                   title  = \"Selection Criteria\", solidHeader = T, \n                   \n                   p(\"here, we'll add a UI element for selecting volcano types\"),\n\n               ), # end box 2\n               \n               \n               \n               # box 3: ggplot of selected volcanoes by continent\n               #------------------------------------------------\n               box(width = NULL, status = \"primary\",\n                   solidHeader = TRUE, collapsible = T,\n                   title = \"Volcanoes by Continent\",\n                   p(\"here, we'll add a bar plot of volcanoes in each continent\")\n               ) # end box 3\n               \n        ), # end column 1\n         \n        # second column - 75% of page (9 of 12 columns)\n        #--------------------------------------------------\n        column(width = 9,\n               # Box 4: leaflet map\n               box(width = NULL, background = \"light-blue\", height = 850,\n                   p(\"here, we'll show volcanoes on a map\"),\n               ) # end box with map\n        ) # end second column\n        \n    ) # end fluidrow\n) # end body\n\n\n# add elements together\ndashboardPage(\n    skin = \"blue\",\n    header = header,\n    sidebar = dashboardSidebar(disable = TRUE), # here, we only have one tab of our app, so we don't need a sidebar\n    body = body\n)\n\n\n```\n\n![](images/shiny_dashboard_layout.png)\n\n## Populating the Layout\n\nNow, we are going to fill out app with elements. In this app, we will only have one user input: a selection of the volcano type to show. We will use this input (`input$volcano_type`), which will be used to filter data in the server (i.e. make a smaller dataset using only volcanoes of the selected types), then use this filtered dataset to create output elements (plots and maps).\n\nBelow, we show the necessary code to include in both the UI and the Server to create each plot element. Notice that after the reactive value `selected_volcanoes` is created in the selection box, this is the only object that is used to create the other elements in the app.\n\n| Location | Element              | UI                                                  | Server                                                                                                                                                |\n|:----------------|:----------------|:------------------|:------------------|\n| Box 1    | **Intro Textbox**    | Markdown/HTML text code                             |                                                                                                                                                       |\n| Box 2    | **Selection Wigets** | `checkboxGroupButtons(` `inputID = \"volcano_type\")` | `selected_volcanoes <- reactive({` `volcano_df %>% filter(type %in% input$volcano_type)})` to create a filtered dataset that will react to user input |\n| Box 3    | **Bar Graph**        | `plotOutput(\"continentplot\")`                       | `output$continentplot <- renderPlot(...))` which will plot from the `selectied_volcanoes` reactive object                                             |\n| Box 4    | **Leaflet Map**      | `leafletOutput(\"volcanomap\")`                       | `output$volcanomap <- renderLeaflet(...)` to map points from the `selectied_volcanoes` reactive object                                                |\n\n![](images/populated_shiny.png)\n\n## Challenge!\n\nUse the code provided to add your own additional user input to the Shiny App. The code (which you can access [here](https://github.com/bios2/shiny_day_2/tree/main/Jake_volcano_map/Volcano_Leaflet) leaves a space for an additional UI input inside box 2). Then, you'll need to use your new input element to the reactive value in the Server, as noted in the server code.\n\nUse the [Default Shiny Widgets](https://shiny.rstudio.com/gallery/widget-gallery.html) or [shinyWidgets extended package](http://shinyapps.dreamrs.fr/shinyWidgets/) galleries to explore the types of elements you can add.\n\n![](images/add_elements_diagram.png)\n\n### See the completed app\n\nSee our completed app [HERE](https://jakelawlor.shinyapps.io/Volcanoes_of_the_World/)\n\n# Constructing a Shiny app using Golem\n\nFirst step is creating your own golem project:\n\n![](Capture%20d%E2%80%99e%CC%81cran,%20le%202021-06-23%20a%CC%80%2005.25.32.png)\n\nGolem provides you with some very helpful \"workflow\" scripts:\n\nEdit the Description by filling in this function in `01_dev.R`\n\nThen, add all the dependencies\n\nTogether, this edits the `DESCRIPTION` of your R package to look something like this:\n\nNow we can start building the app.\n\n```{r eval = FALSE}\napp_ui <- function(request) {\n  tagList(\n    # Leave this function for adding external resources\n    golem_add_external_resources(),\n    # Your application UI logic \n    shinydashboard::dashboardPage(\n      header = shinydashboard::dashboardHeader(\n        title = \"Exploring Volcanoes of the World\",\n        titleWidth = 350 # since we have a long title, we need to extend width element in pixels\n      ),\n      sidebar = shinydashboard::dashboardSidebar(disable = TRUE), # here, we only have one tab, so we don't need a sidebar\n      body = shinydashboard::dashboardBody(\n        # make first row of elements (actually, this will be the only row)\n        fluidRow(\n          # make first column, 25% of page - width = 3 of 12 colums\n          column(width = 3,\n                 # box 1 : input for selecting volcano type\n                 #-----------------------------------------------\n                 shinydashboard::box(width = NULL, status = \"primary\",\n                     title  = \"Selection Criteria\", solidHeader = T\n                     \n                     ## CHECKBOX HERE\n                     \n                 ), # end box 1\n                 # box 2: ggplot of selected volcanoes by continent\n                 #------------------------------------------------\n                 shinydashboard::box(width = NULL, status = \"primary\",\n                     solidHeader = TRUE, collapsible = T,\n                     title = \"Volcanoes by Continent\"\n                     \n                     ## PLOT HERE\n\n                 ) # end box 2\n          ), # end column 1\n          \n          # second column - 75% of page (9 of 12 columns)\n          column(width = 9,\n                 \n                 # Box 3: leaflet map\n                 shinydashboard::box(width = NULL, background = \"light-blue\"\n                                     \n                                     ## MAP HERE \n                                     \n                 ) # end box with map\n          ) # end second column\n        ) # end fluidrow\n      ) # end body\n    )\n  )\n}\n```\n\nThis indicates where each of the three components of the app would go.\n\nAt this point we can run the app to get a very empty-looking UI:\n\n![](Capture%20d%E2%80%99e%CC%81cran,%20le%202021-06-23%20a%CC%80%2005.58.08.png)\n\n### Golem modules\n\nWe could split this app into three different sections, corresponding to each of the three boxes:\n\n1.  Filter the type of volcano we see\n2.  take the filtered volcanoes and plot a stacked bar chart\n3.  take the filtered volcanoes and plot a map\n\n### Selecting the volcanoes\n\n```{r, eval=FALSE}\n#' volcano_select UI Function\n#'\n#' @description A shiny Module.\n#'\n#' @param id,input,output,session Internal parameters for {shiny}.\n#'\n#' @noRd \n#'\n#' @importFrom shiny NS tagList \nmod_volcano_select_ui <- function(id){\n  ns <- NS(id)\n  tagList(\n    # Widget specifying the species to be included on the plot\n    shinyWidgets::checkboxGroupButtons(\n      inputId = ns(\"volcano_type\"),\n      label = \"Volcano Type\",\n      choices = c(\"Stratovolcano\" , \"Shield\" ,\"Cone\" ,   \"Caldera\" ,    \"Volcanic Field\",\n                  \"Complex\" , \"Other\",   \"Lava Dome\"  , \"Submarine\"    ),\n      checkIcon = list(\n        yes = tags$i(class = \"fa fa-check-square\", \n                     style = \"color: steelblue\"),\n        no = tags$i(class = \"fa fa-square-o\", \n                    style = \"color: steelblue\"))\n    ) # end checkboxGroupButtons\n  )\n}\n    \n#' volcano_select Server Functions\n#'\n#' @noRd \nmod_volcano_select_server <- function(id, volcano){\n  moduleServer( id, function(input, output, session){\n    ns <- session$ns\n    \n    # make reactive dataset\n    # ------------------------------------------------\n    # Make a subset of the data as a reactive value\n    # this subset pulls volcano rows only in the selected types of volcano\n    selected_volcanoes <- reactive({\n      \n      req(input$volcano_type)\n      \n      volcano %>%\n        \n        # select only volcanoes in the selected volcano type (by checkboxes in the UI)\n        dplyr::filter(volcano_type_consolidated %in% input$volcano_type) %>%\n        # Space to add your suggested filter here!! \n        # --- --- --- --- --- --- --- --- --- --- --- --- ---\n        # filter() %>%\n        # --- --- --- --- --- --- --- --- --- --- --- --- ---\n        # change volcano type into factor (this makes plotting it more consistent)\n        dplyr::mutate(volcano_type_consolidated = factor(volcano_type_consolidated,\n                                                  levels = c(\"Stratovolcano\" , \"Shield\",  \"Cone\",   \"Caldera\", \"Volcanic Field\",\n                                                             \"Complex\" ,  \"Other\" ,  \"Lava Dome\" , \"Submarine\" ) ) )\n    })\n    \n  })\n}\n    \n## To be copied in the UI\n# mod_volcano_select_ui(\"volcano_select_1\")\n    \n## To be copied in the server\n# mod_volcano_select_server(\"volcano_select_1\")\n\n```\n\nI also like to test my modules by using them to create a toy Shiny app. The best place to do this is by using a testthat directory. This is another great advantage of using a package workflow. You can set this up easily with `usethis::use_test()`: just run `usethis::use_test` from the R console when you have the module open.\n\nThen write a simple test like this\n\n```{r eval=FALSE}\ntest_that(\"volcano selection module works\", {\n  \n  testthat::skip_if_not(interactive())\n  \n  \n  ui <- fluidPage(\n  ## To be copied in the UI\n  mod_volcano_select_ui(\"volcano_select_1\"),\n  tableOutput(\"table\")\n  )\n  \n  server <- function(input, output) {\n    ## To be copied in the server\n    volcano_data <- readRDS(\"data/volcanoes.rds\")\n    selected_data <- mod_volcano_select_server(\"volcano_select_1\",\n                                               volcano = volcano_data)\n    \n    output$table <- renderTable(selected_data())\n  }\n  \n  shinyApp(ui = ui, server = server)\n  \n})\n```\n\nWhich generates the following simple app:\n\n![](Capture%20d%E2%80%99e%CC%81cran,%20le%202021-06-23%20a%CC%80%2006.25.38.png)\n\n### Barplot of continents\n\n```{r eval=FALSE}\n#' continentplot UI Function\n#'\n#' @description A shiny Module.\n#'\n#' @param id,input,output,session Internal parameters for {shiny}.\n#'\n#' @noRd \n#'\n#' @importFrom shiny NS tagList \nmod_continentplot_ui <- function(id){\n  ns <- NS(id)\n  tagList(\n    plotOutput(ns(\"barplot\"), # this calls to object continentplot that is made in the server page\n               height = 350)\n  )\n}\n    \n#' continentplot Server Functions\n#'\n#' @noRd \nmod_continentplot_server <- function(id, volcano, selected_volcanoes){\n  \n  # kind of helpful\n  stopifnot(is.reactive(selected_volcanoes))\n  \n  moduleServer( id, function(input, output, session){\n    ns <- session$ns\n \n    output$barplot <- renderPlot({\n      \n      # create basic barplot\n      barplot <- ggplot2::ggplot(data = volcano,\n                                 ggplot2::aes(x=continent,\n                            fill = volcano_type_consolidated))+\n        # update theme and axis labels:\n        ggplot2::theme_bw()+\n        ggplot2::theme(plot.background  = ggplot2::element_rect(color=\"transparent\",fill = \"transparent\"),\n                       panel.background = ggplot2::element_rect(color=\"transparent\",fill=\"transparent\"),\n                       panel.border     = ggplot2::element_rect(color=\"transparent\",fill=\"transparent\"))+\n        ggplot2::labs(x=NULL, y=NULL, title = NULL) +\n        ggplot2::theme(axis.text.x = ggplot2::element_text(angle=45,hjust=1))\n      \n      \n      # IF a selected_volcanoes() object exists, update the blank ggplot. \n      # basically this makes it not mess up when nothing is selected\n      \n      barplot <- barplot +\n        ggplot2::geom_bar(data = selected_volcanoes(), show.legend = F) +\n        ggplot2::scale_fill_manual(values = RColorBrewer::brewer.pal(9,\"Set1\"), drop=F) +\n        ggplot2::scale_x_discrete(drop=F)\n      \n      \n      # print the plot\n      barplot\n      \n    }) # end renderplot command\n    \n    \n  })\n}\n    \n## To be copied in the UI\n# mod_continentplot_ui(\"continentplot_1\")\n    \n## To be copied in the server\n# mod_continentplot_server(\"continentplot_1\")\n\n```\n\nthe test\n\n```{r eval=FALSE}\ntest_that(\"volano barplot works\", {\n  \n  testthat::skip_if_not(interactive())\n  \n  \n  ui <- fluidPage(\n    ## To be copied in the UI\n    mod_continentplot_ui(\"continentplot_1\"),\n    tableOutput(\"table\")\n  )\n  \n  server <- function(input, output) {\n    ## To be copied in the server\n    volcano_data <- readRDS(\"data/volcanoes.rds\")\n    volcano_recent <- subset(volcano_data, last_eruption_year > 2000)\n    mod_continentplot_server(\"continentplot_1\",\n                                              volcano = volcano_data,\n                                              selected_volcanoes = reactive(volcano_recent))\n  }\n  \n  shinyApp(ui = ui, server = server)\n})\n```\n","srcMarkdownNoYaml":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(eval = FALSE)\n```\n\n## Why do you want to use Shiny?\n\nThere are many reasons to consider using Shiny for a project:\n\n-   Sharing results from a paper with your readers;\n-   Helping you explore a model, mathematics, simulations;\n-   Letting non R users use R.\n\n## Hello Shiny!\n\nHere is an example of a Shiny app that RStudio generates when you open a new Shiny Web App file:\n\n```{r eval = FALSE}\n# Define UI for app that draws a histogram ----\nui <- fluidPage(\n\n  # App title ----\n  titlePanel(\"Hello Shiny!\"),\n\n  # Sidebar layout with input and output definitions ----\n  sidebarLayout(\n\n    # Sidebar panel for inputs ----\n    sidebarPanel(\n\n      # Input: Slider for the number of bins ----\n      sliderInput(inputId = \"bins\",\n                  label = \"Number of bins:\",\n                  min = 1,\n                  max = 50,\n                  value = 30)\n\n    ),\n\n    # Main panel for displaying outputs ----\n    mainPanel(\n\n      # Output: Histogram ----\n      plotOutput(outputId = \"distPlot\")\n\n    )\n  )\n)\n```\n\n# How a Shiny app works\n\n## Building blocks\n\nWe've now seen the basic building blocks of a Shiny app:\n\n-   The **user interface**, which determines how the app \"looks\". This is how we tell Shiny where to ask for user inputs, and where to put any outputs we create.\n-   **Reactive values**, which are values that change according to user inputs. These are values that affect the outputs we create in the Shiny app, such as tables or plots.\n-   The **server**, where we use reactive values to generate some outputs.\n\n### IDs\n\nThe **user interface** and **server** communicate through IDs that we assign to inputs from the user and outputs from the server.\n\n![](images/app-ids.png)\n\nWe use an ID (*in orange*) to link the user input in the UI to the reactive values used in the server:\n\n![](images/app-reactiveid.png)\n\nWe use another ID (*in blue*) to link the output created in the server to the output shown in the user interface:\n\n![](images/app-output.png)\n\n### Organisation\n\nThese elements can all be placed in one script named `app.R` or separately in scripts named `ui.R` and `server.R`. The choice is up to you, although it becomes easier to work in separate `ui.R` and `server.R` scripts when the Shiny app becomes more complex.\n\n**Example 1: Everything in `app.R`**\n\n![](images/app-in1.png) **Example 2: Split things into `ui.R` and `server.R`**\n\n![](images/app-in2.png)\n\n## Plots\n\nShiny is an excellent tool for visual exploration - it is at its most useful when a user can *see* something change before their eyes according to some selections. This is a great way to allow users to explore a dataset, explore the results of some analyses according to different parameters, and so on!\n\nLet's now add a plot to our Shiny app, to visualize the distribution of a variable depending on user input. We'll be adding the `ggplot2` and `ggridges` packages in the set-up step at the top of our `app.R` to allow us to make a plot.\n\n```{r}\n# load packages\nlibrary(shiny)\nlibrary(ggridges)\nlibrary(ggplot2)\nlibrary(here)\nlibrary(readr)\n```\n\n### User interface\n\nTo add a plot in our Shiny, we need to indicate where the plot should appear in the app. We can do this with `plotOutput()`, a similar function to `tableOutput()` in the previous section that is meant for plot outputs, as the name suggests.\n\n```{r}\n# Define UI for application that makes a table andplots the Volcano Explosivity \n# Index for the most eruptive volcanoes within a selected range of years\n\nui <- fluidPage(\n  \n  # Application title ----\n  \n  titlePanel(\"Exploring volcano explosivity\"),\n  \n  # Input interface ----\n  \n  sidebarLayout(\n    sidebarPanel(\n      \n      # Sidebar with a slider range input\n      sliderInput(\"years\", # the id your server needs to use the selected value\n                  label = h3(\"Years\"),\n                  min = 1900, max = 2020, # maximum range that can be selected\n                  value = c(2010, 2020) # this is the default slider position\n      )\n    )\n  ),\n  \n  # Show the outputs from the server ---------------\n  mainPanel(\n    \n    # Show a ridgeplot of explosivity index for selected volcanoes\n    plotOutput(\"ridgePlot\"),\n    \n    # then, show the table we made in the previous step\n    tableOutput(\"erupt_table\")\n    \n  )\n)\n```\n\nNow our Shiny app knows where we want to place our plot.\n\n### Server\n\nWe now need to create the plot we want to show in our app. This plot will change depending on one or several reactive values that the user can input or select in our UI.\n\nWe link the UI and server together with IDs that are assigned to each object. Above, we told the UI to expect a plot output with the ID `\"ridgePlot\"`. In the server, we will create a plot and render it as a plot object using `renderPlot()`, and we will assign this plot output to the ID we call in the UI (as `output$ridgePlot`).\n\n```{r}\n# Define server logic required to make your output(s)\nserver <- function(input, output) {\n\n  \n  # prepare the data\n  # ----------------------------------------------------------\n  \n  # read the dataset\n  eruptions <- readr::read_rds(here::here(\"data\", \"eruptions.rds\"))\n  \n  # filter the dataset to avoid overloading the plot \n  eruptions <- eruptions[which(eruptions$volcano_name %in% names(which(table(eruptions$volcano_name) > 30))),]\n  # this subsets to volcanoes that have erupted more than 30 times\n  \n  \n  # make reactive dataset\n  # ----------------------------------------------------------\n  \n  # subset volcano data with input year range\n  eruptions_filtered <- reactive({\n    subset(eruptions, start_year >= input$years[1] & end_year <= input$years[2])\n  })\n  \n    \n  # create and render the outputs\n  # ----------------------------------------------------------\n  \n  # create the table of volcanoes\n  output$erupt_table <- renderTable({\n    head(eruptions_filtered())\n  })\n  \n  # render the plot output\n  output$ridgePlot <- renderPlot({\n    \n    # create the plot\n    ggplot(data = eruptions_filtered(),\n           aes(x = vei,\n               y = volcano_name,\n               fill = volcano_name)) +\n      # we are using a ridgeplot geom here, from the ggridges package\n      geom_density_ridges( size = .5) + # line width\n      \n      # label the axes\n      labs(x = \"Volcano Explosivity Index\", y = \"\") +\n      \n      # adjust the ggplot theme to make the plot \"prettier\"\n      theme_classic() + \n      theme(legend.position = \"none\",\n            axis.text = element_text(size = 12, face = \"bold\"),\n            axis.title = element_text(size = 14, face = \"bold\"))\n  })\n}\n```\n\n### The Shiny app\n\nNow, if we run the Shiny app, we have a plot above the table we made previously. They are positioned in this way because the `plotOutput()` comes before the `tableOutput()` in the UI.\n\n```{r eval = FALSE}\n# Run the application\nshinyApp(ui = ui, server = server)\n```\n\n![](images/plotOutput.png)\n\n## Customising the theme\n\nIf you'd like to go one step further, you can also customize the appearance of your Shiny app using built-in themes, or creating your own themes.\n\n### Using built-in themes\n\nThere are several built-in themes in Shiny, which allow you to quickly change the appearance of your app. You can browse a gallery of available themes here [here](https://rstudio.github.io/shinythemes/), or test themes out interactively [here](https://shiny.rstudio.com/gallery/shiny-theme-selector.html).\n\nLet's try the *darkly* theme on our Shiny app. To do this, we will need the `shinythemes` package.\n\n```{r}\nlibrary(shinythemes)\n```\n\nWe can change the theme of our previous app with one line of code:\n\n```{r}\n# Define UI for application that makes a table andplots the Volcano Explosivity \n# Index for the most eruptive volcanoes within a selected range of years\n\nui <- fluidPage(\n  \n  # Application title ----\n  \n  titlePanel(\"Exploring volcano explosivity\"),\n  \n  # Input interface ----\n  \n  sidebarLayout(\n    sidebarPanel(\n      \n      # Sidebar with a slider range input\n      sliderInput(\"years\", # the id your server needs to use the selected value\n                  label = h3(\"Years\"),\n                  min = 1900, max = 2020, # maximum range that can be selected\n                  value = c(2010, 2020) # this is the default slider position\n      )\n    )\n  ),\n  \n  # Show the outputs from the server ---------------\n  mainPanel(\n    \n    # Show a ridgeplot of explosivity index for selected volcanoes\n    plotOutput(\"ridgePlot\"),\n    \n    # then, show the table we made in the previous step\n    tableOutput(\"erupt_table\")\n    \n  ),\n  \n  # Customize the theme ----------------------\n  \n  # Use the darkly theme\n  theme = shinythemes::shinytheme(\"darkly\")\n)\n```\n\nNow, if we run the app, it looks a little different:\n\n![](images/darklytheme.png)\n\n### Using a custom theme\n\nYou can also go beyond the built-in themes, and create your own custom theme with the fonts and colours of your choice. You can also apply this theme to the outputs rendered in the app, to bring all the visuals together for a more cohesive look.\n\n#### Customizing a theme\n\nTo create a custom theme, we will be using the `bs_theme()` function from the `bslib` package.\n\n```{r}\nlibrary(bslib)\n```\n\n```{r}\n# Create a custom theme \ncute_theme <- bslib::bs_theme(\n  \n  bg = \"#36393B\", # background colour\n  fg = \"#FFD166\", # most of the text on your app\n  primary = \"#F26430\", # buttons, ...\n  \n  # you can also choose fonts\n  base_font = font_google(\"Open Sans\"),\n  heading_font = font_google(\"Open Sans\")\n)\n```\n\nTo apply this theme to our Shiny app (and the outputs), we will be using the `thematic` package.\n\n```{r}\nlibrary(thematic)\n```\n\nThere are two essential steps to apply a custom theme to a Shiny app:\n\n1.  Activating thematic.\n2.  Setting the user interface's theme to the custom theme (`cute_theme`).\n\n```{r}\n# Activate thematic\n# so your R outputs will be changed to match up with your chosen styling\nthematic::thematic_shiny()\n\n# Define UI for application that makes a table andplots the Volcano Explosivity \n# Index for the most eruptive volcanoes within a selected range of years\n\nui <- fluidPage(\n  \n  # Application title ----\n  \n  titlePanel(\"Exploring volcano explosivity\"),\n  \n  # Input interface ----\n  \n  sidebarLayout(\n    sidebarPanel(\n      \n      # Sidebar with a slider range input\n      sliderInput(\"years\", # the id your server needs to use the selected value\n                  label = h3(\"Years\"),\n                  min = 1900, max = 2020, # maximum range that can be selected\n                  value = c(2010, 2020) # this is the default slider position\n      )\n    )\n  ),\n  \n  # Show the outputs from the server ---------------\n  mainPanel(\n    \n    # Show a ridgeplot of explosivity index for selected volcanoes\n    plotOutput(\"ridgePlot\"),\n    \n    # then, show the table we made in the previous step\n    tableOutput(\"erupt_table\")\n    \n  ),\n  \n  # Customize the theme ----------------------\n  \n  # Use our custom theme\n  theme = cute_theme\n)\n```\n\nNow, if we run the app, the user interface and plot theme is set to the colours and fonts we set in `cute_theme`:\n\n![](images/thematic.png)\n\nHere, `thematic` is not changing the colours used to represent a variable in our plot, because this is an informative colour scale (unlike the colour of axis labels, lines, and the plot background). However, if we remove this colour variable in our ridgeplot in the server, thematic will change the plot colours as well. Here is a simplified example of our server to see what these changes would look like:\n\n```{r}\n# Define server logic required to make your output(s)\nserver <- function(input, output) {\n  \n  #... (all the good stuff we wrote above)\n  \n  # render the plot output\n  output$ridgePlot <- renderPlot({\n    \n    # create the plot\n    ggplot(data = eruptions_filtered(),\n           aes(x = vei,\n               y = volcano_name)) + # we are no longer setting \n             # the fill argument to a variable\n             \n             # we are using a ridgeplot geom here, from the ggridges package\n             geom_density_ridges(size = .5) + \n             \n             # label the axes\n             labs(x = \"Volcano Explosivity Index\", y = \"\") +\n             \n             # remove the \"classic\" ggplot2 so it doesn't override thematic's changes\n             # theme_classic() + \n             theme(legend.position = \"none\",\n                   axis.text = element_text(size = 12, face = \"bold\"),\n                   axis.title = element_text(size = 14, face = \"bold\"))\n           })\n    }\n```\n\nNow, our plot's theme follows the app's custom theme as well:\n\n![](images/thematic_plot.png)\n\n# Constructing a Shiny app using shinyDashboards\n\n## Taking advantage of good defaults\n\nHere, we will use shiny extension `shinyDashboards` and `leaflet` to construct a custom Shiny App to map volcanoes of the world. First, we need a few additional packages.\n\n**Note: All Source code for this app can be found [here](https://github.com/bios2/shiny_day_2/tree/main/Jake_volcano_map/Volcano_Leaflet) on the BIOS2 Github.**\n\n```{r}\n# load packages\nlibrary(shiny)\nlibrary(shinydashboard)  # dashboard layout package\nlibrary(shinyWidgets)  # fancy widgets package\nlibrary(leaflet)  # interactive maps package\nlibrary(dplyr)\nlibrary(ggplot2)\n```\n\n### Using ShinyDashboard\n\nWe will create our app using defaults from the ShinyDashboard package, which always includes three main components: a header, using `dashboardHeader()`, a sidebar, using `dashboardSidebar()`, and a body, using `dashboardBody()`. These are then added together using the `dashboardPage()` function.\n\nBuilding these elements is less like usual R coding, and more like web design, since we are, in fact, designing a unser interface for a web app. Here, we'll make a basic layout before populating it.\n\n```{r, echo=TRUE}\n# create the header of our app\nheader <- dashboardHeader(\n    title = \"Exploring Volcanoes of the World\",\n    titleWidth = 350 # since we have a long title, we need to extend width element in pixels\n)\n\n\n# create dashboard body - this is the major UI element\nbody <- dashboardBody(\n\n    # make first row of elements (actually, this will be the only row)\n    fluidRow(\n        \n        # make first column, 25% of page - width = 3 of 12 columns\n        column(width = 3,\n               \n               \n               # Box 1: text explaining what this app is\n               #-----------------------------------------------\n               box( width = NULL,\n                    status=\"primary\", # this line can change the automatic color of the box.\n                    title = NULL,\n                    p(\"here, we'll include some info about this app\")\n\n                 \n               ), # end box 1\n               \n               \n               # box 2 : input for selecting volcano type\n               #-----------------------------------------------\n               box(width = NULL, status = \"primary\",\n                   title  = \"Selection Criteria\", solidHeader = T, \n                   \n                   p(\"here, we'll add a UI element for selecting volcano types\"),\n\n               ), # end box 2\n               \n               \n               \n               # box 3: ggplot of selected volcanoes by continent\n               #------------------------------------------------\n               box(width = NULL, status = \"primary\",\n                   solidHeader = TRUE, collapsible = T,\n                   title = \"Volcanoes by Continent\",\n                   p(\"here, we'll add a bar plot of volcanoes in each continent\")\n               ) # end box 3\n               \n        ), # end column 1\n         \n        # second column - 75% of page (9 of 12 columns)\n        #--------------------------------------------------\n        column(width = 9,\n               # Box 4: leaflet map\n               box(width = NULL, background = \"light-blue\", height = 850,\n                   p(\"here, we'll show volcanoes on a map\"),\n               ) # end box with map\n        ) # end second column\n        \n    ) # end fluidrow\n) # end body\n\n\n# add elements together\ndashboardPage(\n    skin = \"blue\",\n    header = header,\n    sidebar = dashboardSidebar(disable = TRUE), # here, we only have one tab of our app, so we don't need a sidebar\n    body = body\n)\n\n\n```\n\n![](images/shiny_dashboard_layout.png)\n\n## Populating the Layout\n\nNow, we are going to fill out app with elements. In this app, we will only have one user input: a selection of the volcano type to show. We will use this input (`input$volcano_type`), which will be used to filter data in the server (i.e. make a smaller dataset using only volcanoes of the selected types), then use this filtered dataset to create output elements (plots and maps).\n\nBelow, we show the necessary code to include in both the UI and the Server to create each plot element. Notice that after the reactive value `selected_volcanoes` is created in the selection box, this is the only object that is used to create the other elements in the app.\n\n| Location | Element              | UI                                                  | Server                                                                                                                                                |\n|:----------------|:----------------|:------------------|:------------------|\n| Box 1    | **Intro Textbox**    | Markdown/HTML text code                             |                                                                                                                                                       |\n| Box 2    | **Selection Wigets** | `checkboxGroupButtons(` `inputID = \"volcano_type\")` | `selected_volcanoes <- reactive({` `volcano_df %>% filter(type %in% input$volcano_type)})` to create a filtered dataset that will react to user input |\n| Box 3    | **Bar Graph**        | `plotOutput(\"continentplot\")`                       | `output$continentplot <- renderPlot(...))` which will plot from the `selectied_volcanoes` reactive object                                             |\n| Box 4    | **Leaflet Map**      | `leafletOutput(\"volcanomap\")`                       | `output$volcanomap <- renderLeaflet(...)` to map points from the `selectied_volcanoes` reactive object                                                |\n\n![](images/populated_shiny.png)\n\n## Challenge!\n\nUse the code provided to add your own additional user input to the Shiny App. The code (which you can access [here](https://github.com/bios2/shiny_day_2/tree/main/Jake_volcano_map/Volcano_Leaflet) leaves a space for an additional UI input inside box 2). Then, you'll need to use your new input element to the reactive value in the Server, as noted in the server code.\n\nUse the [Default Shiny Widgets](https://shiny.rstudio.com/gallery/widget-gallery.html) or [shinyWidgets extended package](http://shinyapps.dreamrs.fr/shinyWidgets/) galleries to explore the types of elements you can add.\n\n![](images/add_elements_diagram.png)\n\n### See the completed app\n\nSee our completed app [HERE](https://jakelawlor.shinyapps.io/Volcanoes_of_the_World/)\n\n# Constructing a Shiny app using Golem\n\nFirst step is creating your own golem project:\n\n![](Capture%20d%E2%80%99e%CC%81cran,%20le%202021-06-23%20a%CC%80%2005.25.32.png)\n\nGolem provides you with some very helpful \"workflow\" scripts:\n\nEdit the Description by filling in this function in `01_dev.R`\n\nThen, add all the dependencies\n\nTogether, this edits the `DESCRIPTION` of your R package to look something like this:\n\nNow we can start building the app.\n\n```{r eval = FALSE}\napp_ui <- function(request) {\n  tagList(\n    # Leave this function for adding external resources\n    golem_add_external_resources(),\n    # Your application UI logic \n    shinydashboard::dashboardPage(\n      header = shinydashboard::dashboardHeader(\n        title = \"Exploring Volcanoes of the World\",\n        titleWidth = 350 # since we have a long title, we need to extend width element in pixels\n      ),\n      sidebar = shinydashboard::dashboardSidebar(disable = TRUE), # here, we only have one tab, so we don't need a sidebar\n      body = shinydashboard::dashboardBody(\n        # make first row of elements (actually, this will be the only row)\n        fluidRow(\n          # make first column, 25% of page - width = 3 of 12 colums\n          column(width = 3,\n                 # box 1 : input for selecting volcano type\n                 #-----------------------------------------------\n                 shinydashboard::box(width = NULL, status = \"primary\",\n                     title  = \"Selection Criteria\", solidHeader = T\n                     \n                     ## CHECKBOX HERE\n                     \n                 ), # end box 1\n                 # box 2: ggplot of selected volcanoes by continent\n                 #------------------------------------------------\n                 shinydashboard::box(width = NULL, status = \"primary\",\n                     solidHeader = TRUE, collapsible = T,\n                     title = \"Volcanoes by Continent\"\n                     \n                     ## PLOT HERE\n\n                 ) # end box 2\n          ), # end column 1\n          \n          # second column - 75% of page (9 of 12 columns)\n          column(width = 9,\n                 \n                 # Box 3: leaflet map\n                 shinydashboard::box(width = NULL, background = \"light-blue\"\n                                     \n                                     ## MAP HERE \n                                     \n                 ) # end box with map\n          ) # end second column\n        ) # end fluidrow\n      ) # end body\n    )\n  )\n}\n```\n\nThis indicates where each of the three components of the app would go.\n\nAt this point we can run the app to get a very empty-looking UI:\n\n![](Capture%20d%E2%80%99e%CC%81cran,%20le%202021-06-23%20a%CC%80%2005.58.08.png)\n\n### Golem modules\n\nWe could split this app into three different sections, corresponding to each of the three boxes:\n\n1.  Filter the type of volcano we see\n2.  take the filtered volcanoes and plot a stacked bar chart\n3.  take the filtered volcanoes and plot a map\n\n### Selecting the volcanoes\n\n```{r, eval=FALSE}\n#' volcano_select UI Function\n#'\n#' @description A shiny Module.\n#'\n#' @param id,input,output,session Internal parameters for {shiny}.\n#'\n#' @noRd \n#'\n#' @importFrom shiny NS tagList \nmod_volcano_select_ui <- function(id){\n  ns <- NS(id)\n  tagList(\n    # Widget specifying the species to be included on the plot\n    shinyWidgets::checkboxGroupButtons(\n      inputId = ns(\"volcano_type\"),\n      label = \"Volcano Type\",\n      choices = c(\"Stratovolcano\" , \"Shield\" ,\"Cone\" ,   \"Caldera\" ,    \"Volcanic Field\",\n                  \"Complex\" , \"Other\",   \"Lava Dome\"  , \"Submarine\"    ),\n      checkIcon = list(\n        yes = tags$i(class = \"fa fa-check-square\", \n                     style = \"color: steelblue\"),\n        no = tags$i(class = \"fa fa-square-o\", \n                    style = \"color: steelblue\"))\n    ) # end checkboxGroupButtons\n  )\n}\n    \n#' volcano_select Server Functions\n#'\n#' @noRd \nmod_volcano_select_server <- function(id, volcano){\n  moduleServer( id, function(input, output, session){\n    ns <- session$ns\n    \n    # make reactive dataset\n    # ------------------------------------------------\n    # Make a subset of the data as a reactive value\n    # this subset pulls volcano rows only in the selected types of volcano\n    selected_volcanoes <- reactive({\n      \n      req(input$volcano_type)\n      \n      volcano %>%\n        \n        # select only volcanoes in the selected volcano type (by checkboxes in the UI)\n        dplyr::filter(volcano_type_consolidated %in% input$volcano_type) %>%\n        # Space to add your suggested filter here!! \n        # --- --- --- --- --- --- --- --- --- --- --- --- ---\n        # filter() %>%\n        # --- --- --- --- --- --- --- --- --- --- --- --- ---\n        # change volcano type into factor (this makes plotting it more consistent)\n        dplyr::mutate(volcano_type_consolidated = factor(volcano_type_consolidated,\n                                                  levels = c(\"Stratovolcano\" , \"Shield\",  \"Cone\",   \"Caldera\", \"Volcanic Field\",\n                                                             \"Complex\" ,  \"Other\" ,  \"Lava Dome\" , \"Submarine\" ) ) )\n    })\n    \n  })\n}\n    \n## To be copied in the UI\n# mod_volcano_select_ui(\"volcano_select_1\")\n    \n## To be copied in the server\n# mod_volcano_select_server(\"volcano_select_1\")\n\n```\n\nI also like to test my modules by using them to create a toy Shiny app. The best place to do this is by using a testthat directory. This is another great advantage of using a package workflow. You can set this up easily with `usethis::use_test()`: just run `usethis::use_test` from the R console when you have the module open.\n\nThen write a simple test like this\n\n```{r eval=FALSE}\ntest_that(\"volcano selection module works\", {\n  \n  testthat::skip_if_not(interactive())\n  \n  \n  ui <- fluidPage(\n  ## To be copied in the UI\n  mod_volcano_select_ui(\"volcano_select_1\"),\n  tableOutput(\"table\")\n  )\n  \n  server <- function(input, output) {\n    ## To be copied in the server\n    volcano_data <- readRDS(\"data/volcanoes.rds\")\n    selected_data <- mod_volcano_select_server(\"volcano_select_1\",\n                                               volcano = volcano_data)\n    \n    output$table <- renderTable(selected_data())\n  }\n  \n  shinyApp(ui = ui, server = server)\n  \n})\n```\n\nWhich generates the following simple app:\n\n![](Capture%20d%E2%80%99e%CC%81cran,%20le%202021-06-23%20a%CC%80%2006.25.38.png)\n\n### Barplot of continents\n\n```{r eval=FALSE}\n#' continentplot UI Function\n#'\n#' @description A shiny Module.\n#'\n#' @param id,input,output,session Internal parameters for {shiny}.\n#'\n#' @noRd \n#'\n#' @importFrom shiny NS tagList \nmod_continentplot_ui <- function(id){\n  ns <- NS(id)\n  tagList(\n    plotOutput(ns(\"barplot\"), # this calls to object continentplot that is made in the server page\n               height = 350)\n  )\n}\n    \n#' continentplot Server Functions\n#'\n#' @noRd \nmod_continentplot_server <- function(id, volcano, selected_volcanoes){\n  \n  # kind of helpful\n  stopifnot(is.reactive(selected_volcanoes))\n  \n  moduleServer( id, function(input, output, session){\n    ns <- session$ns\n \n    output$barplot <- renderPlot({\n      \n      # create basic barplot\n      barplot <- ggplot2::ggplot(data = volcano,\n                                 ggplot2::aes(x=continent,\n                            fill = volcano_type_consolidated))+\n        # update theme and axis labels:\n        ggplot2::theme_bw()+\n        ggplot2::theme(plot.background  = ggplot2::element_rect(color=\"transparent\",fill = \"transparent\"),\n                       panel.background = ggplot2::element_rect(color=\"transparent\",fill=\"transparent\"),\n                       panel.border     = ggplot2::element_rect(color=\"transparent\",fill=\"transparent\"))+\n        ggplot2::labs(x=NULL, y=NULL, title = NULL) +\n        ggplot2::theme(axis.text.x = ggplot2::element_text(angle=45,hjust=1))\n      \n      \n      # IF a selected_volcanoes() object exists, update the blank ggplot. \n      # basically this makes it not mess up when nothing is selected\n      \n      barplot <- barplot +\n        ggplot2::geom_bar(data = selected_volcanoes(), show.legend = F) +\n        ggplot2::scale_fill_manual(values = RColorBrewer::brewer.pal(9,\"Set1\"), drop=F) +\n        ggplot2::scale_x_discrete(drop=F)\n      \n      \n      # print the plot\n      barplot\n      \n    }) # end renderplot command\n    \n    \n  })\n}\n    \n## To be copied in the UI\n# mod_continentplot_ui(\"continentplot_1\")\n    \n## To be copied in the server\n# mod_continentplot_server(\"continentplot_1\")\n\n```\n\nthe test\n\n```{r eval=FALSE}\ntest_that(\"volano barplot works\", {\n  \n  testthat::skip_if_not(interactive())\n  \n  \n  ui <- fluidPage(\n    ## To be copied in the UI\n    mod_continentplot_ui(\"continentplot_1\"),\n    tableOutput(\"table\")\n  )\n  \n  server <- function(input, output) {\n    ## To be copied in the server\n    volcano_data <- readRDS(\"data/volcanoes.rds\")\n    volcano_recent <- subset(volcano_data, last_eruption_year > 2000)\n    mod_continentplot_server(\"continentplot_1\",\n                                              volcano = volcano_data,\n                                              selected_volcanoes = reactive(volcano_recent))\n  }\n  \n  shinyApp(ui = ui, server = server)\n})\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"number-sections":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.42","editor":"source","listing":{"sort-ui":["date","author"]},"theme":"flatly","title-block-banner":true,"citation":{"container-title":"BIOS² Education Resources"},"title":"Introduction to Shiny Apps","description":"Introduction to interactive app development with R Shiny.","author":[{"name":"Katherine Hébert","affiliation":"Université de Sherbrooke"},{"name":"Andrew MacDonald","affiliation":"Université de Sherbrooke"},{"name":"Jake Lawlor","affiliation":"McGill University"},{"name":"Vincent Bellavance","affiliation":"Université de Sherbrooke"}],"date":"06-22-2021","image":"image.jpg","categories":["Technical","Fellow contributed","EN"],"number-depth":1},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}